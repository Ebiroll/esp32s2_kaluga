ESP32-S2

Technical Reference Manual

 

Preliminary V0.4
Espressif Systems
Copyright © 2020

ay

www.espressif.com
About This Manual

The ESP32-S2 Technical Reference Manual is addressed to application developers. The manual provides
detailed and complete information on how to use the ESP32-S2 memory and peripherals.

For pin definition, electrical characteristics and package information, please see ESPS2-S2 Datasheet.

Document Updates
Please always refer to the latest version on https:/Avww.espressif.com/en/support/download/documents.

 

Revision History
For any changes to this document over time, please refer to the last page.

Documentation Change Notification
Espressif provides email notifications to keep customers updated on changes to technical documentation.

Please subscribe at www.espressif.com/en/subscribe.

Certification
Download certificates for Espressif products from www.espressif.com/en/certificates.

 

Disclaimer and Copyright Notice

Information in this document, including URL references, is subject to change without notice. THIS DOCUMENT |S
PROVIDED AS IS WITH NO WARRANTIES WHATSOEVER, INCLUDING ANY WARRANTY OF MERCHANTABIL-
ITY, NON-INFRINGEMENT, FITNESS FOR ANY PARTICULAR PURPOSE, OR ANY WARRANTY OTHERWISE
ARISING OUT OF ANY PROPOSAL, SPECIFICATION OR SAMPLE.

All liability, including liability for infringement of any proprietary rights, relating to the use of information in this doc-
ument, is disclaimed. No licenses express or implied, by estoppel or otherwise, to any intellectual property rights
are granted herein. The Wi-Fi Alliance Member logo is a trademark of the Wi-Fi Alliance. The Bluetooth logo is a
registered trademark of Bluetooth SIG.

All trade names, trademarks and registered trademarks mentioned in this document are property of their respective
owners, and are hereby acknowledged.

Copyright © 2020 Espressif Systems (Shanghai) Co., Ltd. All rights reserved.

Espressif Systems 2 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
CONTENTS

 

Contents
1 System and Memory .....................0.0.0000000 00000. 20
1.4 OVENVIEW 2 22
1.2 Features... 22
1.8 Functional Description 2... 23
1.8.1. Address Mapping... 2. 23
1.8.2  InternalMemory. 2... 24
1.8.2.1. InternalROMO 2... ee 25
1.8.2.2 InternalhROM1 2... ee 25
1.8.2.3 InternalSRAMO.. ee 25
1.8.2.4 InternalSRAM1.. 2 ee 25
1.8.2.5 RICFAST Memory... 1... ee 26
1.8.2.6 RICSLOW Memory... 0. ee 26
1.8.3 ExternalMemory 2... 26
1.8.3.1. External Memory Address Mapping .. 2... ee 26
1.8.3.2 Cache... ee 27
1.8.3.3. Cache Operations. ©... ee 27
1.3.4 DMA... ee 28
1.8.6 Modules/Peripherals 2... 28
1.8.5.1. Naming Conventions for Peripheral Buses... 2. 28
1.8.5.2 Differences Between PeriBus1 and PeriBus2 .. 1... 0.0.0 ee 29
1.8.5.3. Module/ Peripheral Address Mapping... 1... 29
1.3.5.4 Addresses with Restricted Access from PeriBust. 2... ee 30
2 Resetand Clock .................000 0... e. 32
2.1 Reset 2 82
2.1.1 Overview 2. 82
2.1.2 Reset Source... 82
2.2 Clock 2 33
2.2.1 OVEIViIEW 2 33
2.2.2 Clock Source 26 34
2.2.3 CPUClock 22. 34
2.2.4 Peripheral Clock 2... 36
2.2.4.1 APB_CLK Source... 36
2.2.4.2 REFTICK Source... 2. 36
2.2.4.8 LEDC_PWM_CLK Source . 2... 37
2.2.4.4 APLL_SCLK Source 2... 37
2.2.4.5 PLL_160M_CLK Source . 1... 37
2.2.4.6 Clock Source Considerations 2... 0. 37
2.2.5 WI-FIClock 2. 37
2.2.6 RICClock 2... 38
2.2.7 Audio PLL Clock 2... ee 38
3 Chip Boot Control..............0000..0000 002, 39
Espressif Systems 3 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

B10 OVENVIEW 39
3.2 BootMode 2.2... 39
8.3 ROM Code Printingto UART .. 2... ee 40
3.4. VDD_SPI Voltage 2... ee 40
4 Interrupt Matrix .......00.0000.0000.0 00 ee, 41
41 OVEVIEW. 2 44
4.2 Features. 44
4.3. Functional Description 2... A
4.3.1. Peripheral Interrupt Sources 2... A
4.3.2  CPUlnterrupts 2... 45
4.3.3 Allocate Peripheral Interrupt Source to CPU Interrupt 2... ee ee 46
4.3.3.1. Allocate one peripheral interrupt source Source_Xto CPU... 2... ee 46

4.3.3.2 Allocate multiple peripheral interrupt sources Source_Xn to CPU 1... ee 46

4.3.3.8 Disable CPU peripheral interrupt source Source_X . 2... 46

4.3.4 Disable CPU NMI Interrupt Sources 2... 47
4.3.5 Query Current Interrupt Status of Peripheral Interrupt Source .. 2... ee ee 47

4.4 BaseAddress . 1... 47
4.5 Register Summary 2... ee 47
46 Registers 2... ee 52
5 IO MUX and GPIO Matrix.............0.............0000. 89
5.10 OVENVIEW 89
5.2 Peripheral Input via GPIO Matrix 2... 90
6.2.1 OVEIEW 2 ee 90
5.2.2. Synchronization. 2... 90
5.2.3 Functional Description 2... 91
5.2.4 Simple GPlO Input 2. 92

5.3. Peripheral Output via GPIO Matrix 2... ee 92
5.3.1 OVeEriew 2 ee 92
5.3.2. Functional Description 2... 92
5.3.3 Simple GPIO Output 2. 93
5.3.4. Sigma Delta Modulated Output 2... 94
5.3.4.1. Functional Description 2... 94

5.3.4.2 SDM Configuration 2... 94

5.4 DedicatedGPIO.. 2... 95
5.4.1 OVEiEeW 2 ee 95
5.4.2 Features. ee 95
5.4.3 Functional Description 2... 96
5.4.3.1. Accessing GPIO via Registers 2... 96

5.4.3.2 Accessing GPlIO with CPU... 96

6.5  DirectVOvialOMUX . 1. 97
5.5.1 OVEPiEeW 2 ee 97
5.5.2. Functional Description 2... 97

5.6 RTC IO MUX for Low Power and Analog /OQ 1... 0 ee 98
5.6.1. Overview 2 ee 98
Espressif Systems 4 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

5.6.2. Functional Description 2... 98
5.7 Pin Functions in Light-sleep 6 ww 98
5.8 PadHoldFeature .. 1... 99
5.9 VOPad Power Supplies 2... 99
5.9.1. Power Supply Management . 0... 99
5.10 Peripheral Signallist . 2. ee 99
5.11 IOMUXPad List... ee 108
6.12 RICIOMUXPinList 2... ee 105
5.18 Base Address 2... 106
5.14 Register Summary 2... ee 106
5.14.1 GPIO Matrix Register Summary 2... 106
5.14.2 IO MUX Register Summary. 2. 108
5.14.38 Sigma Delta Modulated Output Register Summary... 6. 109
5.14.4 Dedicated GPIO Register Summary... 0. 109
5.14.5 RTC IO MUX Register Summary... 109
5.15 Registers 2. 110
5.15.1 GPIO Matrix Registers 2... ee 111
5.15.2 IOMUX Registers... 123
5.15.38 Sigma Delta Modulated Output Registers... ee 125
5.15.4 Dedicated GPIO Registers... 126
5.15.5 RTC lO MUX Registers 2... 135
6 System Registers .........0..000 000s 149
6.1 OVEVIEW 2 149
6.2 Features 149
6.3 Function Description 2... 149
6.3.1. System and Memory Registers 2... 149
6.3.2 Reset and Clock Registers... 0. 151
6.3.3 Interrupt Matrix Registers... 151
6.3.4 JTAG Software Enable Registers 2... 151
6.3.5 Low-power Management Registers... 0. 152
6.3.6 Peripheral Clock Gating and Reset Registers .. 0... 152
6.4 BaseAddress 2... 154
6.5 Register Summary .. 6. 154
6.6 Registers 2... ee 155
7 DMAController........000000 0000 ee 170
T1 Overview. oe 170
7.2 Features 2 ee 170
7.3 Functional Description 2... 171
7.3.1. DMAEngine Architecture. 2 0 171
7.8.2 LinkedList 2. 171
7.3.8 EnablingDMA.. 2... ee 172
7.3.4 Linked List reading process 1... 178
7.3.5 EQF oe 173
7.3.6 Accessing External RAM . 0... ee 178
Espressif Systems 5 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

7.4. CopyDMA Controller... 174
7.6 UART DMA (UDMA) Controller... 0 ee 174
7.6  SPIDMAController 2. 175
7.@  PSDMAController 2. 176
8 UART Controller............00000000 00. 177
8.1 OVENVIEW 2 177
8.2 Features ee 177
8.3 Functional Description 2... ee 177
8.3.1. UART Introduction 2... 177
8.3.2  UART Structure. 2. 178
8.3.8 UARTRAM . 0... ee 179
8.3.4 Baud Rate Generation and Detection .. 0... ee 179
8.3.4.1 Baud Rate Generation 2... 0. 179

8.3.4.2 Baud Rate Detection... 0... 180

8.3.5 UARTDataFrame 2... 181
8.3.6 RS485 0... ee 182
8.3.6.1. Driver Control 2. 182

8.3.6.2 Turnaround Delay... 183

8.3.6.3 BusSnooping.. 2... ee 183

8.3.7 IDA Lee 183
8.3.8 Wake-up 2. 184
8.3.9 FlowControl 2... 184
8.3.9.1 Hardware Flow Control 2. 6 185

8.3.9.2 Software Flow Control 2... 186

8.3.10 UDMA 2. ee 186
8.3.11 UART Interrupts. 2. 186
8.3.12 UHCl Interrupts... 187

8.4 Base Address 2... ee 188
8.5 Register Summary . 6. ee 188
8.6 Registers 2... 191
9 LED PWM Controller ..........0000000........00000000.. 238
9.1 OVENVIEW 2 238
9.2 Features ee 238
9.3 Functional Description 2... ee 238
9.3.1 Architecture... 238
9.3.2 Timers... 239
9.3.8 PWM Generators... 240
9.3.4 Duty Cycle Fading 2... 2. 240
9.3.5 Interrupts 2. 241

9.4 BaseAddress 2... ee 241
9.5 Register Summary 2... ee 242
9.6 Registers 2... ee 244
10 Remote Control Peripheral ............................ 251
Espressif Systems 6 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

10.1 Introduction 2... 251
10.2 Functional Description 2... 251
10.2.1 RMT Architecture... 251
10.2.2 RMT RAM... 1. 252
10.2.3 Clock 2. ee 252
10.2.4 Transmitter 2. 252
10.2.5 Receiver. 2 253
10.2.6 Interrupts 2. 253
10.38 Base Address 2... 254
10.4 Register Summary 2... 254
10.6 Registers 2. 256
11 Pulse Count Controller....00... 0... 265
11.1 Features. 265
11.2 Functional Description 2... 266
11.3 Applications 2... 268
11.3.1. Channel 0 Incrementing Independently 2... 268
11.3.2 Channel 0 Decrementing Independently. 2... 2. 269
11.3.3 Channel 0 and Channel 1 Incrementing Together... 1. 269
11.4 BaseAddress 2... 270
11.5 Register Summary 2... 270
11.6 Registers 2... 272
12 64-bit Timers... eee 278
12.1 Overview. 2. 278
12.2 Functional Description 2... 279
12.2.1 16-bit Prescaler and Clock Selection 2... 2 279
12.2.2 64-bit Time-based Counter 2. 279
12.2.3 Alarm Generation... 0 279
12.2.4 TimerReload 2... 279
12.2.5 Interrupts 2. 280
12.3 Configuration and Usage 2... 281
12.3.1 Timerasa Simple Clock 2... 281
12.3.2 Timer as One-shot Alarm... 281
12.3.3 Timeras Periodic Alarm 6... 282
12.4 BaseAddress . 6... 282
12.5 Register Summary 2... 282
12.6 Registers 2. 284
13 Watchdog Timers .................00 00. c eee 298
18.1 Overview. 2. 293
18.2 Features . 293
18.3 Functional Description 2... 293
13.3.1 Clock Source and 32-Bit Counter 2... 293
13.3.2 Stages and Timeout Actions... 294
18.3.3 Write Protection. 2.0 294
Espressif Systems a ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

13.3.4 Flash Boot Protection. 2... 295
18.4 Registers 2. 295
14 XTAL382K Watchdog ...............000.. 000 eee 296
14.40 Overview. 2 ee 296
14.2 Features 296

14.2.1 XTAL382K Watchdog Interrupts and Wake-up 2... 296

14.2.2 BACKUPS82K_CLK 20. 296
14.3 Functional Description 2... 296

14.3.1 Workflow . 296

14.3.2 Configuring the Divisor of BACKUP32K_CLK . 0... 297
15 System Timer 0 ee. 298
15.1 Overview. 2 298
16.2 MainFeatures . 298
16.3 Clock Source Selection... 298
15.4 Functional Description 2... 298

15.4.1 Read System Timer Value 2. 299

15.4.2 Configure a Time-Delay Alarm 21. 299

15.4.3 Configure Periodic Alarms 2... 299

15.4.4 Update after Deep-sleep and Light-sleep 2... 299
165.5 BaseAddress . 0... ee 3800
15.6 Register Summary 2... 300
15.7 Registers 2 301
16 eFuse Controller 00.000... 309
16.1 Overview 2. ee 809
16.2 Features 809
16.3 Functional Description 2... 309

16.3.1 Structure 2. 809

16.3.1.1 EFUSE WRDIS 2.0... ee 318
16.3.1.2 EFUSE RDDIS... 2... ee 318
16.3.1.8 DataStorage 2... ee 314

16.3.2 Software Programming of Parameters... 6 314

16.3.3 Software Reading of Parameters 2... 316

16.3.4 Timing... 317

16.3.4.1. eFuse-Programming Timing 2... ee 317
16.3.4.2 eFuse VDDQ Timing Setting .. 2... 318
16.3.4.8 eFuse-Read Timing... 6. ee 318

16.3.5 The Use of Parameters by Hardware Modules 2... 319

16.3.6 Interrupts 2. 319
16.4  BaseAddress . 0... 319
16.5 Register Summary 2... 319
16.6 Registers 2. 323
17 1?C Controller... 0... nn, 345
Espressif Systems 8 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

V7.1 Overview. 2 ee 345
17.2 Features 345
17.3 |?C Functional Description 2... 345
17.3.1 PC Introduction... 345
17.3.2 l?C Architecture... 346
17.38.2.1 TX/RXRAM 20 ee 347

17.3.2.2 CMD Controller. 2... 347

17.3.2.3 SCL.FSM 2... ee 348

17.3.2.4 SCL_MAIN FSM 2... ee 349

17.3.2.5 DATA Shiffler oe ee 349

17.3.2.6 SCL Filterand SDA Filter 2... 349

17.3.3 PC Bus Timing 2... 349
17.4 Typical Applications . 2. 350
17.4.1. An l?C Master Writes to an |?C Slave with a 7-bit Address in One Command Sequence ..... 351

17.4.2 An l?C Master Writes to an l?C Slave with a 10-bit Address in One Command Sequence ... . 852
17.4.3 An l?C Master Writes to an |?C Slave with Two 7-bit Addresses in One Command Sequence . . 353
17.4.4 An l?C Master Writes to an |?C Slave with a 7-bit Address in Multiole Command Sequences . . 353
17.4.5 An l?C Master Reacs an ?C Slave with a 7-bit Address in One Command Sequence ...... 354
17.4.6 An l?C Master Reacs an IC Slave with a 10-bit Address in One Command Sequence. ..... 355
17.4.7 An l?C Master Reacs an ?C Slave with Two 7-bit Addresses in One Command Sequence .. . 356
17.4.8 An l?C Master Reads an 2?C Slave with a 7-bit Address in Multiple Command Sequences . . . . 857

17.5 Clock Stretching 2. 0. 357
17.6 Interrupts 2 358
17.7 BaseAddress 2... 359
17.8 Register Summary 2... 359
17.9 RegisterS 2. 360
18 TWAIL ee 383
18.1 Overview. 2. 383
18.2 Features . 383
18.3 Functional Protocol... 384
18.3.1 TWAI Properties. 2. 384
18.3.2 TWAIl Messages 2... 384
18.3.2.1 DataFrames and Remote Frames... 0. 0 385

18.3.2.2 Error and Overload Frames... 2. 387

18.3.2.3 Interframe Space 2... ee 388

18.3.3 TWAIErrors 20 389
18.3.3.1 ErrorTypeS 2. ee 389

18.3.3.2 ErrorStates 2. ee 389

18.3.3.38 Error Counters 2... 390

18.3.4 TWAIBitTiming. 2... 391
18.3.4.1 NominalBit 2... ee 391

18.3.4.2 Hard Synchronization and Resynchronization ... 0... 392

18.4 Architectural Overview 2.0. 392
18.4.1 Registers Block... 393
18.4.2 Bit Stream Processor. 2. 0 394
Espressif Systems 9 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

18.4.3 Error Management Logic... 6. 394
18.4.4 BitTiming Logic. 2... 394
18.4.5 Acceptance Filter... 394
18.4.6 Receive FIFO 2... 394
18.5 Functional Description 2... 395
18.5.1 Modes... 3895
18.5.1.1 ResetMode .. 2... 3895

18.5.1.2 OperationMode. 2... 395

18.5.2 BitTiming .. 395
18.5.3 Interrupt Management 2... 396
18.5.3.1 Receive Interrupt (RX). ee 396

18.5.3.2 Transmit Interrupt (TX) 2. 397

18.5.3.8 Error Warning Interrupt (EWI)... 397

18.5.3.4 Data Overrun Interrupt (DO) 2... 397

18.5.3.5 Error Passive Interrupt (XI)... 398

18.5.3.6 Arbitration Lost Interrupt (AL... 398

18.5.3.7 Bus Error Interrupt (BE). 2. ee 398

18.5.4 Transmit and Receive Buffers 2... 398
18.5.4.1 Overview of Buffers 2. 398

18.5.4.2 Frame Information. 2... 399

18.5.4.38 Frame Identifier 2... 399

18.5.4.4 FrameData .. 400

18.5.5 Receive FIFO and Data Overruns 2... 400
18.5.6 Acceptance Filter... 401
18.5.6.1 Single Filter Mode... ee 401

18.5.6.2 Dual FlilterMode.. .. 402

18.5.7 ErrorManagement .. 6. 403
18.5.7.1 Error Warning Limit 2... 404

18.5.7.2 ErrorPassive 20 404

18.5.7.38 Bus-Off and Bus-Off Recovery... 404

18.5.8 Error Code Capture. 2. 405
18.5.9 Arbitration Lost Capture 2. 406
18.6 Register Summary 2... 407
18.7 Register Description. ©... 408
19 AES Accelerator... 00000 ee, 401
19.1 Introduction 2. 421
19.2 Features 421
19.38 Working Modes . 6. 0 421
19.4 Typical AES Working Mode... 422
19.4.1 Key, Plaintext, and Ciphertext .. 2. 422
19.4.2 Endianness 2... 423
19.4.3 Operation Process 2... 427
19.6 DMA-AES Working Mode... 6. 428
19.5.1 Key, Plaintext, and Cipertext . 2. 428
19.5.2 Endianness 2... 429
Espressif Systems 10 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

19.5.3 Standard Incrementing Function. 2... 430
19.5.4 BlockNumber 2... 430
19.5.5 Initialization Vector 2. 430
19.5.6 Block Operation Process 2... 430
19.5.7 GCM Operation Process 2... 431
19.6 GCMAlgorithm 2... 432
19.6.1 Hash Subkey 2... 433
W9.6.2 Ty ce 433
19.6.3 Authenticated Tag 6. 433
19.6.4 AAD BlockNumber 2... 433
19.6.6 Remainder BitNumber 2... 434
19.7 BaseAddresSs 2... ee 434
19.8 Memory Summary 2... 434
19.9 RegisterSummary . 2... 434
19.10 Registers 2... 436
20 SHA Accelerator ......0.0.. 00000 eee 441
20.1 Introduction 2. 441
20.2 Features 441
20.3 Working Modes . 0... ee 441
20.4 Function Description 2... ee 442
20.4.1 Preprocessing. © 6. 442
20.4.1.1. Padding the Message. . 6. 442

20.4.1.2 Parsing the Message . 2. 443
20.4.1.3 Initial Hash Value 2. ee 444

20.4.2 Hash Computation Process 2... 445
20.4.2.1 Typical SHA Process «6. 445

20.4.2.2 DMA-SHAProcess .. 1. ee 447

20.4.8 Message Digest. 2... 448
20.4.4 Interrupt... 449
20.5 BaseAddress 2... 450
20.6 Register Summary . 6. ee 450
20.7 Registers 2 ee 452
21 RSA Accelerator ...... 0000s 456
21.1 Introduction 2... 456
21.2 Features 456
21.3 Functional Description 2... ee 456
21.3.1 Large Number Modular Exponentiation . 0... 457
21.3.2 Large Number Modular Multiplication . 0... ee 458
21.3.8 Large Number Multiplication... 459
21.3.4 Acceleration Options 2... 459
21.4 BaseAddress 2... 461
21.5 Memory Summary .. 6. ee 461
21.6 RegisterSummary 2... ee 461
21.7 Registers 2. ee 462
Espressif Systems 11 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

22 Random Number Generator............................ 466
22.1 Introduction 2. 466
22.2 Features 466
22.3 Functional Description 2... 466
22.4 BaseAddress 2... 467
22.5 Register Summary . 6. 6 ee 467
22.6 Register 2... ee 467
23 External Memory Encryption and Decryption........... 468
23.1 OVEVIEW. 2 468
23.2 Features 468
23.3 Functional Description 2... 468
23.3.1 XTSAlgoritAM. 2 469
23.3.2 Key 2 469
23.3.8 Target Memory Space 2... 470
23.3.4 DataPadding .. 2... 470
23.3.5 Manual Encryption Block... 471
23.3.6 Auto Encryption Block 2... 472
23.3.7 Auto Decryption Block 2... 472
23.4 Base Address 2... 473
23.5 Register Summary 2... ee 473
23.6 Registers 2... 474
24 Permission Control...........0000 00000 cece 478
24.1 OVEVIEW 2 478
24.2 Features 478
24.3 Functional Description 2... 478
24.3.1 Internal Memory Permission Controls . 0... 478
24.3.1.1. Permission Control for the Instruction Bus (IBUS) .. 2... ee 479

24.3.1.2 Permission Control for the Data Bus (DBUSO).. 2... 2. ee 481

24.3.1.3 Permission Control for On-chip DMA 2... 482

24.3.1.4 Permission Control for PeriBust 2... ee 483

24.3.1.5 Permission Control for PeriBus2 2... 485

24.3.1.6 Permission Control forCache 2... 486

24.3.1.7 Permission Control of Other Types of Internal Memory... 2.0.0.0... 002 ee 486

24.3.2 External Memory Permission Control . 2... 487
24.3.2.1 CacheMMU.. 2... 487

24.3.2.2 External Memory Permission Controls . 2... 487

24.3.8 Non-Aligned Access Permission Control 2... 0. 488
24.4 BaseAddress 2. 489
24.5 Register Summary . 6. 1 489
24.6 Registers 2... ee 491
25 Digital Signature ............0...000000 0... 519
25.1 OVEVIEW 2 519
25.2 Features 519
Espressif Systems 12 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

25.3 Functional Description 2... 519
25.3.1 OVEPVIEW 2 ee 519
25.3.2 Private Key Operands 2... 519
25.3.3 Conventions. 2. ee 520
25.3.4 Software Storage of PrivateKeyData.. 2... ee 520
25.3.5 DS Operation at the Hardware Level 2. 0. 521
25.3.6 DS Operation at the Software Level... ee 522

25.4 BaseAddress 2... 623

25.5 Memory Blocks 2... ee 523

25.6 Register Summary . 6. ee 523

25.7 Registers 2. ee 524

26 HMAC Module ................00 000 eee 526

26.1 OVEVIEW. 2 526

26.2 MainFeatures . 2. 526

26.3 Functional Description 2... ee 526
26.3.1 Upstream Mode 2... 526
26.3.2 Downstream JTAG Enable Mode .. 2... ee 527
26.3.8 Downstream Digital Signature Mode... 0. 527
26.3.4 HMAC eFuse Configuration 2... 528
26.3.5 HMAC Process (Detailed) 2.2... 528

26.4. HMAC Algorithm Details .. 0. ee 530
26.4.1 PaddingBits . 2... 530
26.4.2 HMAC Algorithm Structure... 531

26.5 Base Address 2... 531

26.6 Register Summary . 6... 532

26.7 Registers 2. ee 533

2/7 ULP Coprocessor .............0 0000 eee 539

27.1 OVEVIEW. 2 539

27.2 Features 539

27.3 Programming Workflow... 0 ee 541

27.4 ULP Coprocessor Workflow 2... 541

27.5 ULP-FSM 21 ee 544
27.5.1 Features. ee 544
27.5.2 Instruction Set 2. ee 544

27.5.2.1 ALU - Perform Arithmetic and Logic Operations . 2... . 0. 545
27.5.2.2 ST-Store Datain Memory... 0... 548
27.5.2.38 LD-Load Datafrom Memory ... 0. 550
27.5.2.4 JUMP-Jump to anAbsolute Address 2... 551
27.5.2.5 JUMPR - Jump to a Relative Offset (Conditional upon RO)... 551
27.5.2.6 JUMPS — Jump to a Relative Address (Conditional upon Stage Count Register) ..... 552
27.5.2. HALT-—Endthe Program... 2. 553
27.5.2.8 WAKE-Wakeup the Chip... 2. 553
27.5.2.9 WAIT — Wait fora Number of Cycles... 553
27.5.2.10 TSENS - Take Measurement with Temperature Sensor. 2... 554
Espressif Systems 13 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

27.5.2.11 ADC - Take Measurement with ADC... 554
27.5.2.12 REG_RD — Read from Peripheral Register... 555
27.5.2.13 REG_WR - Write to Peripheral Register... 2 556

27.6 ULP-RISC-V ow ee 556
27.6.1 Features. ee 556
27.6.2 Multiplier and Divider 2... 556
27.6.8 ULP-RISC-V Interrupts 2... 557
27.7 RIC PC Controller 2... 558
27.7.1. Connecting RTC °C Signals 2... 558
27.7.2 Configuring RTC PC 2... 558
27.7.3 UsingRTC PG 2. 558
27.7.3.1 Instruction Format... ee 558

27.7.3.2 |2C_RD - l?C Read Workflow... ee 558
27.7.3.8 |2C_WR - l?C Write Workflow... ee 559

27.7.3.4 Detecting Error Conditions . 2... 560

27.7.4 RTC PC Interrupts 2... 560
27.8 Base Address... 561
27.8.1 ULP Coprocessor Base Address 2. 561
27.8.2 RIC PC Base Address... ee 561
27.9 Register Summary . 6... ee 561
27.9.1 ULP (ALWAYS_ON) Register Summary . 2... 561
27.9.2 ULP (RTC_PERI) Register Summary... 0. 562
27.9.8 RTC PC (RTC_PERI) Register Summary. 2... 562
27.9.4 RTC PC (l2C) Register Summary... 562
27.10 Registers 2. ee 563
27.10.1 ULP (ALWAYS_ON) Registers 2... 564
27.10.2 ULP (RTC_PERI) Registers... 0. 567
27.10.38RTC PC (RTC_PERI) Registers... 570
27.10.4RTC PC (I2C) Registers 2. 572
28 Low-power Management..........................0.... 586
28.1 Introduction 2... 586
28.2 Features 586
28.3 Functional Description 2... ee 586
28.3.1 Power Management Unit. 2... 587
28.8.2 Low-Power Clocks 2.0 ee 589
28.3.3 TIMES. ee 590
28.3.4 Regulators 2. 591
28.3.4.1 Digital System Voltage Regulator. 2... 591

28.3.4.2 Low-power Voltage Regulator 2... 592

28.3.4.3 Flash Voltage Regulator... 0. 593

28.3.4.4 Brownout Detector... ee 594

28.4 Power Modes Management .. 1... ee 595
28.4.1 PowerDomain 2... ee 595
28.4.2 RTC States 0. ee 595
28.4.3 Pre-defined PowerModes .. 0... ee 597
Espressif Systems 14 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
CONTENTS

 

28.4.4 Wakeup Source. 6 597
28.5 RIC Boot 2... ee 598
28.6 Base Address... 600
28.7 Register Summary . 6. 6 ee 600
28.8 Registers 2. ee 602
Revision History... 0.0.0.0 eee 639
Espressif Systems 15 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
LIST OF TABLES

 

List of Tables
1 Address Mapping . 6 6. ee 24
2 Internal Memory Address Mapping. 2... 24
3 External Memory Address Mapping . 6... 26
4 Peripherals with DMA Support 2... 28
5 Module / Peripheral Address Mapping... 2... 29
6 Addresses with Restricted Access . 0. 31
7 Reset Source 6 6 383
8 CPU_CLK Source 2 ee 385
i] CPU_CLK Selection. 2. ee 385
10 Peripheral Clock Usage 2... 36
14 APB_CLK Source 2 0. 36
12 REF_TICK Source 2. 37
13 LEDC_PWM_CLK Source 2. 37
14 Default Configuration of Strapping Pins 2... 39
15 Boot Mode... 6 39
16 ROM Code Printing Control. 2. 40
V7 CPU Peripheral Interrupt Configuration/Status Registers and Peripheral Interrupt Sources... . . 42
18 CPU Interrupts. 2. 45
19 Interrupt Matrix Base Address 2... 47
21 Pin Function Register for |O MUX Light-sleep Mode 2... 98
22 GPIO Matrix... ee 99
23 IOMUXPad List... 104
24 RTC IO MUX Pin Summary 2... 105
25 Module Base Addresses 2 0. 106
31 ROM Controlling Bit. 2. 150
82 SRAM Controlling Bit 2... 150
33 Peripheral Clock Gating and Reset Bits . 2... 152
34 System Register Base Address. 6. 154
36 Relationship Between Configuration Register and Destination Address ............... 174
37 Base addresses of UARTO, UART1 and UHCIO. 2 2. ee ee 188
40 LED PWM Base Address... ee 241
42 RMT Base Address . 0. 254
44 Counter Mode. Positive Edge of Input Pulse Signal. Control Signal in Low State... ....... 267
45 Counter Mode. Positive Edge of Input Pulse Signal. Control Signal in High State... ....... 267
46 Counter Mode. Negative Edge of Input Pulse Signal. Control Signal in Low State ......... 267
47 Counter Mode. Negative Edge of Input Pulse Signal. Control Signal in High State... ...... 267
48 PCNT Base Address 2... 270
50 64-bit Timers Base Address 2... ee 282
52 System Timer Base Address 2... 300
54 Parameters in BLOCKO . 0 0. 809
55 Key Purpose ValueS 2 6. 312
56 Parameters in BLOCK1-10 2 0 312
58 Configuration of eFuse-Programming Timing Parameters... 0. 317
59 Configuration of VDDQ Timing Parameters 2... 0. 318
Espressif Systems 16 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
LIST OF TABLES

 

60 Configuration of eFuse-Reading Parameters 2... 318
61 eFuse Controller Base Address... ee 319
63 l?C Controller Base Address 6. 359
65 Data Frames and Remote Frames in SFF and EFF 1... 1 386
66 Error Frame 387
67 Overload Frame «0 ee 388
68 Interframe Space 6. 389
69 Segments of aNominal Bit Time... 2 391
70 Bit Information of TWAL CLOCK_DIVIDER_REG; TWAI Address 0x18... 0.0... eee 395
71 Bit Information of TWALBUS_TIMING_1_REG; TWAI Address Oxtc ... 2. ee ee 396
72 Buffer Layout for Standard Frame Format and Extended Frame Format............... 398
73 TX/RX Frame Information (GFF/EFF) TWAI Address Ox40 2... 399
74 TX/RX Identifier 1 (GFF); TWAI Address 0x44. 2 399
75 TX/RX Identifier 2 (GFF); TWAI Address Ox48 2 0 ee 400
76 TX/RX Identifier 1 (EFF); TWAI Address 0x44. 2 0 400
77 TX/RX Identifier 2 (EFF); TWAI Address 0x48 6 wk 400
78 TX/RX Identifier 3 (EFF); TWAI Address Ox4c 6 400
79 TX/RX Identifier 4 (EFF); TWAI Address OxX50, 6 ww 400
80 Bit Information of TWAL ERR _CODE_CAP_REG; TWAI Address 0x80... 0.0.0... 0. .0004 405
81 Bit Information of Bits SEG.4-SEG.O 1... 405
82 Bit Information of TWALARB LOST CAP_REG; TWAI Address Ox2c. 0... ee 406
84 AES Accelerator Working Mode 2... ee 421
85 Operation Type under Typical AES Working Mode. 2... 422
86 Working Status under Typical AES Working Mode 2... 422
87 Text Endianness Types for Typical AES... 6. 423
88 Key Endianness Types for AES-128 Encryption and Decryption ... 1... 0.0.2.2. .0 00008 425
89 Key Endianness Types for AES-192 Encryption and Decryption .. 2... 2.0.0.0... . 00004 425
90 Key Endianness Types for AES-256 Encryption and Decryption .. 1... 0.0.0.0... . 00004 426
91 Operation Type under DMA-AES Working Mode . 2... 428
92 Working Status under DMA-AES Working mode . 2... 428
938 TEXT-PADDING .. 1... 429
94 Text Endianness for DMA-AES . 0... 429
95 AES Accelerator Base Address. ow. 434
98 SHA Accelerator Working Mode 2... 0 442
99 SHA Hash Algorithm 2... 442
103 The Storage and Length of Message Digests from Different Algorithms ............00. 448
104. BaseAddress 2... 450
106 Acceleration Performace 2... 460
107. RSABase Address 2... 461
110 Random Number Generator Base Address . 2... 467
W122 KEY 469
113. Mapping Between Offsets and Registers 2... 0 471
114 Manual Encryption Block Base Address . 2... ee 473
116 Offset Address Range of Each SRAM Block. 2. 6 478
117 Permission Control for IBUS to Access SRAM. ww. 479
118 Permission Control for IBUS to Access RTC FAST Memory 2... 0.00000 480
Espressif Systems V7 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
LIST OF TABLES

 

119 Permission Control for DBUSO to Access SRAM 2... 481
120 Permission Control for DBUSO to Access RTC FAST Memory... 0.0.00 ee 482
121 Permission Control for On-chip DMA to Access SRAM... 2 483
122 Peripherals and FIFO Address 2... 484
123 Permission Control for PeriBust 2... 484
124 Permission Control for PeriBus2 to Access RTC SLOW Memory... 2... ee 485
125 Configuration of Register PMS_PRO_CACHE_1_REG ............ 0.00000 eee 486
126 MMUEntries.. 2... 487
127 Non-Aligned Access to Peripherals 2.0... 489
128 Permission Control Base Address . 0... 489
180 BaseAddress .. 1. 623
183 HMAC Function and Configuration Value 2... 528
184. HMAC Base Address 2... 532
186 Comparison of the Two Coprocessors .w 6. 540
187 ALU Operations Among Registers . 1... ee 546
188 ALU Operations with Immediate Value... ee 547
189 ALU Operations with Stage Count Register... ee 547
140 Data Storage Type - Automatic Storage Mode .. 1... 549
141 Data Storage - Manual Storage Mode .. 1... ee 550
142 Input Signals Measured Using the ADC Instruction .. 0... ee 554
143 Instruction Efficiency 2... ee 557
144 ULP-RISC-V Interrupt List 2. 557
145 ULPCoprocessor Base Address . 6 0. ee 561
146 RICPCBaseAddress 2... 561
161. Low-Power Clocks 2... 590
152. The Triggering Conditions forthe RTC Timer 2... 590
153  Brown-out Detector Configuration 2... ee 594
164 RTC Statues Transition 2... 596
165 Predefined Power Modes... 1 597
156 Wakeup Source 2... ee 598
157 Low-power Management Base Address... 600
Espressif Systems 18 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
LIST OF FIGURES

 

List of Figures

1-1 System Structure and Address Mapping. . 2... ee 23
1-2. Cache Structure. 27
2-1 System Reset 2... 82
2-2 System Clock 2... 34
4-1 Interrupt Matrix Structure 2. A
5-1 IO MUX, RTC IO MUX and GPIO Matrix Overview... 0 89
5-2 GPIO Input Synchronized on Clock Rising Edge or on Falling Edge .............000, 91
5-3. Filter Timing Diagram of GPIO Input Signals... 91
5-4. Dedicated GPIO Diagram... 95
7-1 Modules with DMA and Supported Data Transfers 2... ee 170
7-2. DMAEngine Architecture... ee 171
7-3 Structure ofaLinkedList. 2. 171
7-4 Relationship among Linked Lists... 2 178
7-5 Copy DMAEngine Architecture. 2. 174
7-6 Data Transferin UDMA Mode... 0. 175
7-7 SPIDMA 2... ee 175
8-1 UART Structure 2. ee 178
8-2 UART Controllers Sharing RAM 1... 179
8-3 UART Controllers Division. 2... 180
8-4 The Timing Diagram of Weak UART Signals Along Falling Edges... ............000,4 181
8-5  StructureofUARTDataFrame.. 1... 181
8-6 AT_CMD Character Structure. 2 2 182
8-7 — Driver Control Diagram in RS485 Mode .. 1... 182
8-8 — The Timing Diagram of Encoding and Decoding inSIR mode ..... 2... 000020000 ae 184
8-9 IrDAEncoding and Decoding Diagram... 6. 184
8-10 Hardware Flow Control Diagram 2... 185
8-11. Connection between Hardware Flow Control Signals . 2... 185
9-1 LED PWMAvchitecture. 2. ee 238
9-2 LED PWM generator Diagram... 2. 239
9-8 LED PWMDivider.. 2. 0 239
9-4. LED _PWM Output Signal Diagram... 240
9-5 Output Signal Diagram of Fading Duty Cycle 2... 241
10-1 RMT Architecture 2. 251
10-2 Format of Pulse Code in RAM .. 1... 252
11-1 PCNT Block Diagram 2... ee 265
11-2 PCNT Unit Architecture... 266
11-3. Channel 0 Up Counting Diagram . 2. ee 268
11-4 Channel 0 Down Counting Diagram 2... ee 269
11-5 Two Channels Up Counting Diagram. 2... ee 269
12-1 Timer Units within Groups 2 6 ee 278
14-1 XTAL82K Watchdog. 2... ee 296
15-1 System Timer Structure... ee 298
16-1 Shift Register Circuit. ©. ee 314
16-2 eFuse-Programming Timing Diagram 2... ee 317
Espressif Systems 19 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
LIST OF FIGURES

 

16-3 Timing Diagram for Reading eFuse. 2... 319
17-1 l?C Master Architecture 2. 346
17-2 |?C Slave Architecture. 6. 346
17-3 Structure of 2C Command Register 2... ee 347
17-4. PC Timing Diagram 2. ee 349
17-5 An |?C Master Writing to an I?C Slave with a 7-bit Address .. 0... 351
17-6 A Master Writing to a Slave with a 10-bit Address. 2.) 352
17-7 An |?C Master Writing Address M in the RAM to an I?C Slave witha 7-bitAddress ........., 353
17-8 An |?C Master Writing to an |?C Slave with a 7-bit Address in Multiple Sequences ........., 353
17-9 An |?C Master Reading an I?C Slave with a 7-bit Address... 354
17-10 An I?C Master Reading an I?C Slave witha 10-bit Address .. 0... ee 355
17-11 An l?C Master Reading N Bytes of Data from addrM of an I?C Slave with a 7-bit Address ..... 356
17-12 An l?C Master Reading an l?C Slave with a 7-bit Address in Segments .............0.. 357
18-1 The bit fields of Data Frames and Remote Frames .. 1... 385
18-2 Various Fields of an Error Frame 2... 387
18-3 The Bit Fields of an Overload Frame 2... 388
18-4 The Fields within an Interframe Space 2... 389
18-5 LayoutofaBit. 2... ee 391
18-6 TWAI Overview Diagram 2... ee 393
18-7 Acceptance Filler... ee 401
18-8 Single Filter Mode... 402
18-9 DualFilterMode... 1. 408
18-10 Error State Transition 2... 404
18-11 Positions of Arbitration Lost Bits 2... 406
19-12 GCM Encryption Process . 6 0. ee 432
22-1 Noise Source 2. ee 466
23-1 Architecture of the External Memory Encryption and Decryption Module .............., 468
25-1 Preparations and DS Operation 2... 520
26-1 HMAC SHA-256 Padding Diagram. 2... 530
26-2 HMAC Structure Schematic Diagram «1. 531
27-1 ULP Coprocessor Overview 2... 539
27-2 ULPCoprocessor Diagram... 541
27-3 Programing Workflow... 542
27-4 Sample of aULP Operation Sequence... 542
27-5 Control of ULP Program Execution. 2... 544
27-6 ULP-FSM Instruction Format... ee 545
27-7 Instruction Type — ALU for Operations Among Registers... 2... 545
27-8 Instruction Type — ALU for Operations with Immediate Value... oe ee 546
27-9 Instruction Type — ALU for Operations with Stage Count Register... ...........000, 547
27-10 Instruction Type -ST 2 548
27-11 Instruction Type - Offset in Automatic Storage Mode (ST-OFFSET)...............004 548
27-12 Instruction Type - Data Storage in Automatic Storage Mode (ST-AUTO-DATA) ........... 548
27-13 Instruction Type - Data Storage in Manual Storage Mode... 2... 549
27-14 Instruction Type-LD 2... 550
27-15 Instruction Type- JUMP... 551
27-16 Instruction Type - JUMPR.. . 551
Espressif Systems 20 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
LIST OF FIGURES

 

27-17 Instruction Type - JUMPS... 552
27-18 Instruction Type- HALT 2... 553
27-19 Instruction Type - WAKE 2... 553
27-20 Instruction Type - WAIT 2. 553
27-21 Instruction Tyope- TSENS 2... 554
27-22 Instruction Type- ADC 2... 554
27-23 Instruction Type - REG_LRD . 1... 555
27-24 Instruction Type - REG_WR.. 1. 556
27-25 |?C Read Operation 2... 559
27-26 |?C Write Operation 2. 560
28-1 Low-power Management Schematics... 0. 587
28-2 Power Management Unit Workflow 2... 0. 588
28-3 Low-Power Clocks for RTC Power Domains . 1... 589
28-4 Low-Power Clocks for RTC Power Domains . 0... 589
28-5 Low-Power Clocks for RTC Fast Memory and Slow Memory... 0... ee 589
28-6 Digital System Regulator 2... 592
28-7 Low-power voltage regulator... 592
28-8 Flash voltage regulator 2... 593
28-9 Brown-out detector... ee 594
28-10 RTC States 2. ee 596
28-11 ESP82-S2 Boot Flow... ee 600
Espressif Systems 21 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
1. System and Memory

 

1. System and Memory

1.1. Overview
The ESP32-S2 is a single-core system with one Harvard Architecture Xtensa® LX7 CPU. All internal memory,
external memory, and peripherals are located on the CPU buses.

1.2 Features
* Address Space

4 GB (82 bits wide) address space in total accessed from the data bus and instruction bus

464 KB internal memory address space accessed from the instruction bus

400 KB internal memory address space accessed from the data bus

1.77 MB peripheral address space

7.5 MB external memory virtual address space accessed from the instruction bus

14.5 MB external memory virtual address space accessed from the data bus

320 KB internal DMA address space

— 10.5 MB external DMA address space
* Internal Memory

-— 128 KB Internal ROM

-— 820 KB Internal SRAM

- 8KBRITC FAST Memory

- 8KB RTC SLOW Memory
° External Memory

— Supports up to 1 GB external SPI flash

— Supports up to 1 GB external SP! RAM
° DMA

— 9 DMA-supported modules / peripherals

Figure 1-1 illustrates the system structure and address mapping.

Espressif Systems 22 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
1. System and Memory

 

 

0x0000_0000
OxEFF_FFFF

0x3F00_0000
OxSFF_FFFF

Ox8F40_0000
OxSF4F_FFFF

0x3F50_0000
OxSFF7_FFFF

Ox3FFB_0000
Ox3FFQ_DFFF

Ox8FF9_E000
Cache OxSFFF_FFFF

0x4000_0000

0x4007_1FFF l
0x4007_2000
Ox4007_FFFF

0x4008_0000
Ox407 F_FFFF

0x4080_0000
Oxd FFF_FFFF

0x5000_0000
Ox5000_1FFF

0x6000_2000
OXSFFF_FFFF

0x6000_0000
DMA Ox6008_FFFF

Ox600C_0000
Ox617F_FFFF

0x6180_0000
0x61 80_3FFF

0x6180_4000
OxFFFR_FEFF

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Internal memory DMA

 

 

 

 

 

 

 

 

 

 

 

 

 

 

External memory MMU

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Peripheral

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 1-1. System Structure and Address Mapping

 

Note:

e The memory space with gray background is not available to users.

e The range of addresses available in the address space may be larger or smaller than the actual available memory
of a particular type.

 

 

 

1.3. Functional Description

1.3.1 Address Mapping
The Harvard Architecture Xtensa® LX7 CPU can address 4 GB (82 bits wide) memory space.

Addresses below 0x4000_0000 are serviced using the data bus. Addresses in the range 0x4000_0000 ~
Ox4FFF_FFFF are serviced using the instruction bus. Addresses over and including 0x5000_0000 are shared by
both data and instruction bus.

Both data bus and instruction bus are little-endian. The CPU can access data via the data bus in a byte-,
half-word-, or word-aligned matter. The CPU can also access data via the instruction bus, but only in a
word-aligned manner; non-word-aligned access will cause a CPU exception.

The CPU can:
* directly access the internal memory via both data bus and instruction bus;

* access the external memory which is mapped into the address space via cache;

Espressif Systems 23 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
1. System and Memory

 

* access modules / peripherals via data bus.

Table 1 lists the address ranges on the data bus and instruction bus and their corresponding target

memory.

Some internal and external memory can be accessed via both data bus and instruction bus. In such cases, the

same memory is available to the CPU at two address ranges.

Table 1: Address Mapping

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Boundary Address .
Bus Type . Size Target
Low Address | High Address
Ox0000_0000 | OxSEFF_FFFF Reserved
Ox8FO0_0000 | Ox3F3F_FFFF 4 MB | External memory
Data bus Ox8F40_0000 | Ox3F4F_FFFF 1 MB Peripherals
Ox8F50_0000 | OxSFF7_FFFF | 10.5 MB | External memory
Ox3FF8_0000 | OxSFF9Q_DFFF Reserved
Data bus Ox3FF9_E000 | OxSFFF_FFFF | 992 KB | Internal memory
Instruction bus Ox4000_0000 | Ox4007_1FFF | 456 KB | Internal memory
0x4007_2000 | 0x4007_FFFF Reserved
Instruction bus O0x4008_0000 | 0Ox407F_FFFF 7.5 MB | External memory
O0x4080_0000 | Ox4FFF_FFFF Reserved
Data / Instruction bus Ox5000_0000 | Ox5000_1FFF 8 KB | Internal memory
0x5000_2000 | OxSFFF_FFFF Reserved
Data / Instruction bus Ox6000_0000 | Ox600B_FFFF | 768 KB Peripherals
Ox600C_O0000 | Ox617F_FFFF Reserved
Data / Instruction bus 0x6180_0000 | 0x6180_SFFF 16 KB Peripherals
0x6180_4000 | OxFFFF_FFFF Reserved

 

1.3.2 Internal Memory

 

The internal memory consists of four segments: Internal ROM (128 KB), Internal SRAM (820 KB), RTC FAST
Memory (8 KB}, and RTC SLOW Memory (8 KB).

The Internal ROM is broken down into two parts: Internal ROM O (64 KB) and Internal ROM 1 (64 KB).

The Internal SRAM is broken down into two parts: Internal SRAM 0 (32 KB) and Internal SRAM 1 (288 KB).

RTC FAST Memory and RTC SLOW Memory are both implemented as SRAM.

Table 2 lists all types of internal memory and their address ranges on the data bus and instruction bus.

Table 2: Internal Memory Address Mapping

 

 

 

 

 

 

 

 

 

 

 

Boundary Address . |

Bus Type ; Size Target Permission Control
Low Address | High Address
Ox3FFQ_EO00 | Ox3FFQ_FFFF 8 KB | RTC FAST Memory YES

Data b Ox3FFA_0000 | Ox3FFA_FFFF 64 KB Internal ROM 1 NO

ata bus

Ox3FFB_O000 | OxSFFB_7FFF | 32 KB Internal SRAM 0 YES
Ox3FFB_8000 | OxSFFF_FFFF | 288 KB Internal SRAM 1 YES

 

Espressif Systems

Submit Documentation Feedback

24

ESP32-S2 TRM (Preliminary V0.4)

 
1. System and Memory

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Boundary Address . |
Bus Type ; Size Target Permission Control
Low Address | High Address
0x4000_0000 | Ox4000_FFFF 64 KB Internal ROM 0 NO
0x4001_0000 | 0x4001_FFFF 64 KB Internal ROM 1 NO
Instruction bus 0x4002_0000 | 0x4002_7FFF 82 KB Internal SRAM O YES
0x4002_8000 | Ox4006_FFFF | 288 KB Internal SRAM 1 YES
0x4007_0000 | 0x4007_1FFF 8 KB | RTC FAST Memory YES
Boundary Address .
Bus Type ; Size Target Permission Control
Low Address | High Address
Data / Instruction bus 0x5000_0000 | Ox5000_1FFF 8 KB | RTC SLOW Memory YES

 

 

Note:

 

"YES” in the "Permission Control” column indicates that a permission is required for memory access. Permission
Control registers can be used to limit Instruction or Data bus access to individual regions of these memory types.

 

 

1.3.2.1

Internal ROM 0

Internal ROM 0 is a 64-KB, read-only memory space, addressed by the CPU on the instruction bus via range(s)

described in Table 2.

1.3.2.2

Internal ROM 1

Internal ROM 1 is a 64-KB, read-only memory space, addressed by the CPU on the data or instruction bus via
range(s) described in Table 2.

The two address ranges access Internal ROM 1 in the same order, so, for example, addresses Ox3FFA_O0000 and
0x4001_0000 access the same word, OxSFFA_0004 and 0x4001_0004 access the same word, Ox8FFA_0008
and 0x4001_0008 access the same word, etc.

1.3.2.3

Internal SRAM 0

Internal SRAM O is a 32-KB, read-and-write memory space, addressed by the CPU on the data or instruction

bus, in the same order, via range(s) described in Table 2.

Hardware can be configured to use 8 KB, 16 KB, 24 KB, or the entire 32 KB space in this memory to cache

external memory. The space used as cache cannot be accessed by the CPU, while the remaining space can still

be accessed by the CPU.

1.3.2.4

Internal SRAM 1

Internal SRAM 1 is a 288-KB, reacd-and-write memory space, addressed by the CPU on the data or instruction

bus, in the same order, via range(s) described in Table 2.

Internal SRAM 1 comprises eighteen 16-KB (sub)memory blocks. One block can be used as Trace Memory, in

which case this block’s address range cannot be accessed by the CPU.

Espressif Systems

Submit Documentation Feedback

25

ESP32-S2 TRM (Preliminary V0.4)

 
1. System and Memory

 

1.3.2.5 RTC FAST Memory

RTC FAST Memory is an 8-KB, read-and-write SRAM, addressed by the CPU on the data or instruction bus, in
the same order, via range(s) described in Table 2.

1.3.2.6 RTC SLOW Memory

RTC SLOW Memory is an 8-KB, read-and-write SRAM, addressed by the CPU via range(s) shared by the data
bus and the instruction bus, as described in Table 2.

RTC SLOW Memory can also be used as a peripheral addressable to the CPU via either Ox3F42_1000 ~
Ox3F42_2FFF or Ox6002_1000 ~ Ox6002_2FFF on the data bus.

1.3.3 External Memory
ESP32-S2 supports multiple QSPI/OSPI flash and RAM chips. It also supports hardware encryption/decryption
based on XTS-AES to protect user programs and data in the flash and external RAM.

1.3.3.1 External Memory Address Mapping

The CPU accesses the external flash and RAM via the cache. According to the MMU settings, the cache maps
the CPU’s address to the external physical memory acidress. Due to this address mapping, the ESP32-S2 can
address up to 1 GB external flash and 1 GB external RAM.

Using the cache, ESP32-S2 can support the following address space mappings at the same time.

* Up to 7.5 MB instruction bus address space can be mapped into the external flash or RAM as individual 64
KB blocks, via the instruction cache (ICache). Byte (8-bit), half-word (16-bit) and word (32-bit) reads are
supported.

e Up to 4 MB read-only data bus address space can be mapped into the external flash or RAM as individual
64 KB blocks, via ICache. Byte (8-bit), half-word (16-bit) and word (32-bit) reads are supported.

e Up to 10.5 MB data bus address space can be mapped into the external RAM as individual 64 KB blocks,
via DCache. Byte (8-bit), half-word (16-bit) or word (32-bit) reads and writes are supported. Blocks from
this 10.5 MB space can also be mapped into the external flash or RAM, for read operations only.

Table 3 lists the mapping between the cache and the corresponding address ranges on the data bus and
instruction bus.

Table 3: External Memory Address Mapping

 

 

 

 

 

 

 

 

 

Boundary Address ; |
Bus Type . Size | Target | Permission Control
Low Address | High Address
Data bus Ox3FOO_0000 | Ox3F3F_FFFF 4MB | ICache YES
Data bus Ox3F50_0000 | OxSFF/_FFFF | 10.5 MB | DCache YES
Instruction bus 0x4008_0000 | 0x407F_FFFF 7.5 MB | |lCache YES

 

 

 

 

Note:
"YES” in the "Permission Control” column indicates that a permission is required for memory access. Permission

 

 

Control registers can be used to limit Instruction or Data bus access to individual regions of these memory types.

 

Espressif Systems 26 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
1. System and Memory

 

1.3.3.2 Cache

As shown in Figure 1-2, the caches on ESP32-S2 are separated and allow prompt response upon simultaneous
requests from the data bus and instruction bus. Some internal memory space can be used as cache (see
Section 1.3.2.3). When a cache miss occurs, the cache controller will initiate a request to the external memory.
When |Cache and DCache simultaneously initiate a request, the arbiter determines which gets the access to the
external memory first. The cache size of ICache and DCache can be configured to 8 KB and 16 KB, respectively,
while their block size can be configured to 16 bytes and 82 bytes, respectively.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

CPU
Instruction/Data bus _] [ Data bus
ICache MMU DCache
Internal Internal
Memory External Memory
Memory

 

 

 

Figure 1-2. Cache Structure

1.3.3.3 Cache Operations

ESP32-S2 caches support the following operations:

1. Invalidate: The cache clears the valid bit of a tag. The CPU needs to access the external memory in order
to read/write the data. There are two types of invalidation operations: manual invalidation and automatic
invalidation. Manual invalidation performs only on data in the specified area in the cache, while automatic
invalidation performs on all data in the cache. Both ICache and DCache have this function.

2. Clean: The cache clears the dirty bit of the tag and retains the valid bit. The CPU can then read/write the
data directly from the cache. Only DCache has this function.

3. Write-back: The cache clears the dirty block flag of the tag and retains the valid bit. It also forces the data
in the corresponding address to be written back to the external memory. The CPU can then read/write the
data directly from the cache. Only DCache has this function.

4. Preload: To preload a cache is to load instructions and data into the cache in advance. The minimum unit
of a preloading is one block. There are two types of preloading: manual preloading and automatic
preloading. Manual preloading means that the hardware prefetches a piece of continuous data according
to the virtual address specified by the software. Automatic preloading means the hardware prefetches a
piece of continuous data according to the current hit / miss address (depending on configuration).

5, Lock / Unlock: There are two types of lock: prelock and manual lock. When prelock is enabled, the cache
locks the data in the specified area when filling the missing data to cache memory. When manual lock is
enabled, the cache checks the cata that has been filled into the cache memory and locks the data that falls
in the specified area. The data in the locked area is always stored in the cache and will not be replaced.
But when all the ways within the cache are locked, the cache will replace data, as if the ways were not
locked. Unlocking is the reverse of locking. The manual invalidation, clean, and write-back operations are
only available after unlocking.

Espressif Systems at ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
1. System and Memory

 

1.3.4 DMA
With DMA, the ESP32-S2 can perform data transfers between:

* modules / peripherals and internal memory;
® different types of internal memory;

* modules / peripherals and external memory;
® internal and external memory.

DMA uses the same addressing as the data bus to read and write Internal SRAM 0 and Internal SRAM 1.
Specifically, DMA uses address range Ox3FFB_0000 ~ OxSFFB_7FFF to access Internal SRAM 0, and
Ox3FFB_8000 ~ OxGFFF_FFFF to access Internal SRAM 1. Note that DMA cannot access the internal memory
occupied by the cache.

In addition, DMA addresses the external RAM from Ox3F50_0000 ~ OxGFF7_FFFF, the same used by the CPU to
access DCache. When DCache and DMA access the external memory simultaneously, data consistency is
required.

Nine modules / peripherals on the ESP382-S2 support DMA, as shown in Table 4. With DMA, some of them can
only access internal memory, some can access both internal and external memory.

Table 4: Peripherals with DMA Support

 

| uaRTO. =| UARTA
| SPI2 | SPI3 |
| 1280 |
| |
| |
| |

 

 

 

 

 

 

ADC Controller
Copy DMA
AES Accelerator | SHA Accelerator

 

 

 

 

 

1.3.5 Modules / Peripherals

The CPU can access modules / peripherals via address range OxSF40_0000 ~ Ox3F4F_FFFF on the cata bus, or
via Ox6000_0000 ~ Ox600B_FFFF and 0x6180_0000 ~ 0x6180_SFFF shared by the data bus and instruction
bus.

1.3.5.1 Naming Conventions for Peripheral Buses

There are two peripheral buses defined as follows:

* PeriBus1: Which refers to the address range Ox3F40_0000 ~ Ox3F4F_FFFF on the bus. Ox8F40_0000 is
the base address.

* PeriBus2: Which refers to the address ranges Ox6000_0000 ~ Ox600B_FFFF and 0x6180_0000 ~
Ox6180_3FFF on the bus. Ox6000_0000 is the base address.

All references to “PeriBus1” and “PeriBus2” in this document indicate the corresponding address range(s).

Espressif Systems 28 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
1. System and Memory

 

1.3.5.2 Differences Between PeriBus1 and PeriBus2

The CPU can access modules / peripherals more efficiently through PeriBus1 than through PeriBus2. However,
PeriBus1 features speculative reads, which means it cannot guarantee that each read is valid. Therefore, the
CPU has to use PeriBus2 to access some special registers, for example, FIFO registers.

In addition, PeriBus1 will upset the order of r/w operations on the bus to improve performance, which may cause
programs that have strict requirements on the r/w order to crash. In such cases, please add volatile before the
program statement, or use PeriBus2 instead.

1.3.5.3 Module / Peripheral Address Mapping

Table 5 lists all the modules / peripherals and their respective address ranges. Note that addresses in column
“Boundary Address” are offsets relative to the base address, instead of absolute addresses. The absolute
addresses are the addition of bus base address and the corresponding offsets.

Table 5: Module / Peripheral Address Mapping

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Boundary Address .

Target . Size | Notes

Low Address | High Address
UARTO Ox0000_0000 | OxO0000_OFFF 4kKB | 1,2,3
Reserved Ox0000_1000 | Ox0000_1FFF
SPI1 Ox0000_2000 | Ox0000_2FFF 4kB | 1,
SPIO Ox0000_3000 | OxO0000_SFFF 4kB | 1,
GPIO Ox0000_4000 | Ox0000_4FFF 4kB | 1,
Reserved Ox0000_5000 | OxO000_6FFF
TIMER Ox0000_7000 | Ox0000_7FFF 4kB | 1,
RTC Ox0000_8000 | OxO0000_8FFF 4kB | 1,
lO MUX Ox0000_9000 | Ox0000_9FFF 4kB | 1,
Reserved OxO000_A000 | Ox0000_EFFF
280 Ox0000_FOOO | Ox0000_FFFF 4kKB | 1,2,3
UART1 0x0001_0000 | Ox0001_OFFF 4kKB | 1,2,3
Reserved 0x0001_1000 | Ox0001_2FFF
12CO 0x0001_3000 | Ox0001_SFFF 4kKB | 1,2,3
UHCIO 0x0001_4000 | Ox0001_4FFF 4kKB | 1,2
Reserved 0x0001_5000 | Ox0001_5FFF
RMT 0x0001_6000 | Ox0001_6FFF 4kKB | 1,2,3
PCNT 0x0001_7000 | Ox0001_7FFF 4kB | 1,2
Reserved 0x0001_8000 | Ox0001_8FFF
LED PWM Controller 0x0001_9000 | 0x0001_9FFF 4kKB } 1,2
eFuse Controller 0x0001_A000 | Ox0001_AFFF 4kKB } 1,2
Reserved 0x0001_B000 | 0x0001_EFFF
Timer Group 0 O0x0001_FOOO | Ox0001_FFFF 4kKB | 1,2
Timer Group 1 O0x0002_0000 | Ox0002_OFFF 4kKB | 1,2
RTC SLOW Memory 0x0002_1000 | Ox0002_2FFF 8kKB | 1,2,3
System Timer O0x0002_3000 | Ox0002_SFFF 4kKB | 1,2
SPl2 O0x0002_4000 | Ox0002_4FFF 4kB | 1,2

 

Espressif Systems

29
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
1. System and Memory

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Boundary Address .

Target . Size | Notes

Low Address | High Address
SPIS 0x0002_5000 | Ox0002_5FFF 4kB | 1,2
APB Controller 0x0002_6000 | Ox0002_6FFF 4kKB } 1,2
I2C1 0x0002_7000 | Ox0002_7FFF 4kKB | 1,2,3
Reserved 0x0002_8000 | Ox0002_AFFF
TWAI Controller 0x0002_B000 | 0x0002_BFFF 4kKB } 1,2
Reserved 0x0002_C000 | Ox0003_8FFF
USB OTG Ox0008_9000 | Ox0003_9FFF 4kKB | 1,2,3,4
AES Accelerator Ox0003_A000 | Ox0003_AFFF 4kB | 1,2
SHA Accelerator Ox00038_BO00 | 0x0003_BFFF 4kB | 1,2
RSA Accelerator Ox0003_CO000 | Ox0003_CFFF 4kB | 1,2
Digital Signature 0x00038_D000 | Ox0003_DFFF 4kB | 1,2
HMAC O0x0003_E000 | Ox0003_EFFF 4kB | 1,2
Crypto DMA Ox0003_FOOO | Ox0003_FFFF 4kB | 1,2
Reserved 0x0004_4000 | OxO000C_DFFF
ADC Controller 0x0004_0000 | Ox0004_OFFF 4kB | 1,2
Reserved 0x0004_1000 | Ox0007_FFFF
USB OTG Ox0008_0000 | OxOOOB_FFFF | 256 KB | 1, 2,3, 4
System Registers Ox000C_O0000 | OxO00C_OFFF 4kB | 1
Sensitive Register Ox000C_1000 | OxO00C_1FFF 4 kB | 1
Interrupt Matrix Ox000C_2000 | OxO00C_2FFF 4 kB | 1
Copy DMA Ox000C_3000 | OxOO0C_SFFF 4 kB | 1
Reserved Ox000C_4000 | OxOO0C_EFFF
Dedicated GPIO Ox000C_FOOO | OxOO0OC_FFFF 4 kB | 1
Reserved Ox000D_1000 | OxOOOF_FFFF
Configure Cache 0x0180_0000 | 0x0180_SFFF 16 KB | 2

 

 

 

 

 

 

 

Note:

1. This module / peripheral can be accessed from PeriBus1.

. This module / peripheral can be accessed from PeriBus2.

2
3. Some special addresses in this module / peripheral are not accessible from PeriBus1
4

(see Section 1.3.5.4).

 

 

. The address space in this module / peripheral is not continuous.

 

1.3.5.4 Addresses with Restricted Access from PeriBus1

As mentioned in Section 1.3.5.2, PeriBus1 features speculative reads, which means it is forbidden to read FIFO
registers. Table 6 below lists the address (range) with restricted access from PeriBus1.

There are four reserved user-defined registers that can be configured as needed to add more addresses with
restricted access.

Espressif Systems 30
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
1. System and Memory

 

Table 6: Addresses with Restricted Access

 

 

 

 

 

 

 

 

 

Peripherals Addresses with Restricted Access
UARTO Ox8F40_0000

UART1 Ox8F41_0000

280 OxSF40_FO04

RMT Ox3F41_6000 ~ Ox3F41_600F

I2CO Ox3F41_3801C

1201 Ox3F42_701C

USB OTG Ox3F48_0020, Ox3F48_1000 ~ Ox3F49_OFFF

 

 

 

Espressif Systems

31 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
2. Reset and Clock

 

2. Reset and Clock

2.1. Reset

2.1.1 Overview
ESP32-S2 provides four types of reset that occur at different levels, namely CPU Reset, Core Reset, System
Reset, and Chip Reset.

All reset types mentioned above (except Chip Reset) maintain the data stored in internal memory. Figure 2-1
shows the scopes of affected subsystems when different types of reset occur.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

ESP32-S2
SYSTEM
CORE RTC
cpu_reset wm} CPU PMU
core_reset |
SENSOR
ANALOG
WIFI
system_reset > PERI
Co-Processor
chip reset,
DIG_GPIO RTC_GPIO

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 2-1. System Reset

* CPU Reset: Only resets CPU core. Once such reset is released, programs will be executed from CPU reset
vector.

* Core Reset: Resets the whole digital system except RTC, including CPU, peripherals, Wi-Fi, and digital
GPIOs.

* System Reset: Resets the whole digital system, including RTC.
* Chip Reset: Resets the whole chip.
2.1.2 Reset Source

CPU will be reset immediately when any of the reset above occurs. Users can get reset source codes by reading
register RTC_CNTL_RESET_CAUSE_PROCPU after the reset is released.

Table 7 lists different reset sources and the types of reset they trigger.

Espressif Systems 82 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
2. Reset and Clock

 

Table 7: Reset Source

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Code | Source Reset Type Comments
Ox01 | Chip reset Chip Reset See the note below
OxOF | Brown-out system reset | System Reset Triggered by brown-out detector
0x10 | RWDT system reset System Reset See Chapter 18 Watchdog Timers
0x13 | GLITCH reset System Reset -
Ox03 | Software system reset Core Reset Triggered by configuring RTC_CNTL_SW_SYS_RST
0x05 | Deep-sleep reset Core Reset See Chapter 28 Low-power Management
0x07 | MWDTO global reset Core Reset See Chapter 18 Watchdog Timers
0x08 | MWDT1 global reset Core Reset See Chapter 18 Watchdog Timers
Ox09 | RWDT core reset Core Reset See Chapter 18 Watchdog Timers
OxOB | MWDTO CPU reset CPU Reset See Chapter 18 Watchdog Timers
OxOC | Software CPU reset CPU Reset Triggered by configuring RTC_CNTL_SW_PROCPU_RST
OxOD | RWDT CPU reset CPU Reset See Chapter 18 Watchdog Timers
0x11 | MWDT1 CPU reset CPU Reset See Chapter 18 Watchdog Timers
Note:

* Chip Reset can be triggered by the following three sources:

— Triggered by chip power-on;

— Triggered by brown-out detector;

— Triggered by Super Watchdog (SWD).

* Once brown-out status is detected, the detector will trigger System Reset or Chip Reset, depending on

register configuration. For more information, please see Chapter 28 Low-power Management.

2.2 Clock

2.2.1

Overview

ESP32-S2 provides multiple clock sources, which allow CPU, peripherals and RTC to work at different

frequencies, thus providing more flexibility in meeting the requirements of various application scenarios. Figure

2-2 shows the system clock structure.

Espressif Systems

33

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
2. Reset and Clock

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

CLK_MANAGEMENT
PLL_CLK >| diva} —
APLL_CLK >| aiva | —» 7
Shs CPU_CLK CPU
RTC8M_CLK +| ava] —+
XTAL_CLK Aor | aoe APB_CLK
> ava —> LOW_POWER_CLK WIFI
5 @—>/REF_GEN REF_TICK 4
2
—9 4,
oy LEDC_SCLK PERI
APLL_CLK
| PLL_160M_CLK
PLL_DIV
Pees!)
RTC_CLK
x
2
XTAL32K_CLK 2 SLOW CLK |
"|B
RTCBM_D256_CLK 19
* RTC
x
aa
= FAST_CLK .
8 "
é

 

 

 

 

 

 

 

Figure 2-2. System Clock

2.2.2 Clock Source

ESP832-S2 uses external crystal, internal PLL, or internal oscillator working as clock sources to generate different
kinds of clocks, which can be classified in three types depending on their clock speed.

* High speed clock for devices working at a higher frequency, such as CPU and digital peripherals
— PLL_CLK (820 MHz or 480 MHz): internal PLL clock
— XTAL_CLK (40 MHz): external crystal clock

® Slow speed clock for low-power devices, such as power management unit and low-power peripherals

XTAL82K_CLK (82 kHz): external crystal clock

— RTC8M_CLK (8 MHz by default): internal oscillator with adjustable frequency

RTC8M_D256_CLK (31.250 kHz by default): internal clock derived from RTC8M_CLK divided by 256
— RTC_CLK (90 kHz by default): internal oscillator with adjustable frequency
* Audio clock for audio-related devices

— APLL_CLK (16 MHz ~ 128 MHz): internal Audio PLL clock

2.2.8 CPU Clock

As Figure 2-2 shows, CPU_CLK is the master clock for CPU and it can be as high as 240 MHz when CPU works
in high performance mode. Alternatively, CPU can run at lower frequencies, such as at 2 MHz, to lower power
consumption.

Espressif Systems 34 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
2. Reset and Clock

 

Users can set PLL_CLK, APLL_CLK, RTC8M_CLK or XTAL_CLK as CPU_CLK clock source by configuring
register SYSTEM_SOC_CLK_SEL, see Table 8 and Table 9.

Table 8: CPU_CLK Source

 

 

 

 

 

 

SYSTEM_SOC_CLK_SEL Value Clock Source
0 XTAL_CLK

1 PLL_CLK

2 RTC8M_CLK
3 APLL_CLK

 

 

 

Table 9: CPU_CLK Selection

 

 

 

 

 

 

 

 

 

 

Clock Source SEL_O* | SEL_1* | SEL_2* | CPU Clock Frequency
CPU_CLK = XTAL_CLK / (SYSTEM_PRE_DIV_CNT + 1)
XTAL_CLK 0 - - .
SYSTEM_PRE_DIV_CNT ranges from 0 ~ 1028. Default is 1
CPU_CLK = PLL_CLK/6
PLL_CLK (480 MHz) 4 4 0 .
CPU_CLK frequency is 80 MHz
CPU_CLK = PLL_CLK/3
PLL_CLK (480 MHz) 4 4 4 .
CPU_CLK frequency is 160 MHz
CPU_CLK = PLL_CLK/2
PLL_CLK (480 MHz) 4 4 2 .
CPU_CLK frequency is 240 MHz
CPU_CLK = PLL_CLK / 4
PLL_CLK (820 MHz) 1 0 0 .
CPU_CLK frequency is 80 MHz
CPU_CLK = PLL_CLK/2
PLL_CLK (820 MHz) 4 0 4 .
CPU_CLK frequency is 160 MHz
CPU_CLK = RTC8M_CLK / (SYSTEM_PRE_DIV_CNT + 1)
RTC8M_CLK 2 - - .
SYSTEM_PRE_DIV_CNT ranges from 0 ~ 1028. Default is 1
APLL_CLK 3 0 0 CPU_CLK = APLL_CLK / 4
APLL_CLK 3 0 4 CPU_CLK = APLL_CLK / 2

 

 

 

 

 

 

 

*SEL_O: The value of register SYSTEM _SOC_CLK_SEL.
*SEL_1: The value of register SYSTEM_PLL_FREQ_SEL.
*SEL_2: The value of register SYSTEM_CPUPERIOD_SEL.
Note:

e When users select XTAL_CLK as CPU clock source and adjust the divider value by configuring register
SYSTEM_PRE_DIV_CNT, the rules below should be followed.

— If current divider value is 2 (SYSTEM_PRE_DIV_CNT = 1) and the target is x (x # 1), users should set
the divider first to 1 (SYSTEM_PRE_DN_CNT = 0) and then to x (GSYSTEM_PRE_DIV_CNT = x - 1).

— If current divider value is x (SYSTEM_PRE_DIV_CNT = x - 1) and the target is 2, users should set the
divider first to 1 (GSYSTEM_PRE_DINV_CNT = 0) and then to 2 (SYSTEM_PRE_DIV_CNT = 1).

— For other target divider value x, users can adjust the register directly (GYSTEM_PRE_DIV_CNT = x - 1).

Espressif Systems 35 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
2. Reset and Clock

 

2.2.4 Peripheral Clock
Peripheral clocks include APB_CLK, REF_TICK, LEDC_PWM_CLK, APLL_CLK and PLL_160M_CLK. Table 10
shows which clock can be used by which peripheral.

Table 10: Peripheral Clock Usage

Peripheral APB_CLK | REF_TICK | LEDC_PWM_CLK | APLL_CLK | PLL_160M_CLK
TIMG Y

2S

UHCI

UART

RMT
LED_PWM

l2C

SPI

PCNT

eFuse Controller
SARADC/DAC
USB
CRYPTO
TWAI Controller

Y Y

~<|~<|~|~«~|~«|~<|<«|<«<|]«|<|<|<I})

 

System Timer

2.2.4.1. APB_CLK Source

APB_CLK is determined by the clock source of CPU_CLK as shown in Table 11.

Table 11: APB_CLK Source

 

 

 

 

 

CPU_CLK Source APB_CLK
PLL_CLK 80 MHz
APLL_CLK CPU_CLK /2
XTAL_CLK CPU_CLK
RTC8M_CLK CPU_CLK

 

 

 

 

2.2.4.2 REF_TICK Source

REF_TICK is derived from XTAL_CLK or RTC8M_CLK via a divider. When PLL_CLK, APLL_CLK or XTAL_CLK is
set as CPU clock source, REF_TICK will be divided from XTAL_CLK. When RTC8M_CLK is set as CPU clock
source, REF_TICK will be divided from RTC8M_CLK. In such way, REF_TICK frequency remains unchanged
when APB_CLK changes its clock source. Table 12 shows the configuration of these clock divider

registers.

Espressif Systems 36 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
2. Reset and Clock

 

Table 12: REF_TICK Source

 

 

 

CPU_CLK Source Clock Divider Register
PLL_CLK | XTAL_CLK | APLL_CLK APB_CTRL_XTAL_TICK_NUM
RTC8M_CLK APB_CTRL_CK8M_TICK_NUM

 

 

 

 

Normally, one REF_TICK cycle lasts for 1 jus, so APB_CTRL_XTAL_TICK_NUM should be configured to 39
(default), and APB_CTRL_CK8M_TICK_NUM to 7 (default).

2.2.4.3  LEDC_PWM_CLK Source

LEDC_PWM_CLK clock source is selected by configuring register LEDC_APB_CLK_SEL, as shown in Table
13.

Table 13: LEDC_PWM_CLK Source

 

 

 

 

 

LEDC_APB_CLK_SEL Value LEDC_PWM_CLK Source
0 (Default) -

1 APB_CLK

2 RTC8M_CLK

3 XTAL_CLK

 

 

 

 

2.2.4.4 APLL_SCLK Source

APLL_CLK is sourced from PLL_CLK, and its output frequency is configured using APLL configuration registers.
See Section 2.2.7 for more information.

2.2.4.5 PLL_160M_CLK Source

PLL_160M_CLK is divided from PLL_CLK according to current PLL frequency.

2.2.4.6 Clock Source Considerations

Peripherals that need to work with other clocks, such as RMT and I?C, generally operate using PLL_CLK
frequency as a reference. When this frequency changes, peripherals should update their clock configuration to
operate at the same frequency after the change. Peripherals accessing REF_TICK can continue operating
normally without changing their clock configuration when switching clock sources. Please see Table 10.

LED module uses RTC8M_CLK as clock source when APB_CLK is disabled. In other words, when the system is
in low-power mode, most peripherals will be halted (APB_CLK is turned off), but LED can work normally via
RTC8M_CLK.

2.2.5 Wi-Fi Clock
Wi-Fi can work only when APB_CLK uses PLL_CLK as its clock source. Suspending PLL_CLK requires that
Wi-Fi has entered low-power mode first.

LOW_POWER_CLK uses XTAL32K_CLK, XTAL_CLK, RTC8M_CLK or SLOW_CLK (the low clock selected by
RTC) as its clock source for Wi-Fi in low-power mode.

Espressif Systems 37 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
2. Reset and Clock

 

2.2.6 RTC Clock
The clock sources for SLOW_CLK and FAST_CLK are low-frequency clocks. RTC module can operate when
most other clocks are stopped.

SLOW_CLK derived from RTC_CLK, XTAL32K_CLK or RTC8M_D256_CLK is used to clock Power Management
module.

FAST_CLK is used to clock On-chip Sensor module. It can be sourced from a divided XTAL_CLK or from
RTC8M_CLK.

2.2.7 Audio PLL Clock

The operation of audio and other time-critical data-transfer applications requires highly-configurable, low-jitter
and accurate clock sources. The clock sources derived from system clocks that serve digital perioherals may
carry jitter and, therefore, are not suitable for a high-precision clock frequency setting.

Providing an integrated precision clock source can minimize system cost. To this end, ESP32-S2 integrates an
audio PLL to clock 2S module.

Audio PLL formula is as follows:

 

 

fon = Ffrtai(Sdm2 + so some +4)
ont Dlodiv + 2)

Parameters are defined below:
® fatal the frequency of crystal oscillator, usually 40 MHz;
® sdm0: the value is 0 ~ 255;
® sdm1: the value is 0 ~ 255;
* sdm2: the value is 0 ~ 63;
® odiv: the value is 0 ~ 31;

° The operating frequency range of the numerator is 850 MHz ~ 500 MHz.

dm1 sd
350M Hz < fgq(sdm2 + Smt, somo

8 “ore + 4) < 500MHz

Audio PLL can be manually enabled or disabled via registers RTC_CNTL_PLLA_FORCE_PU and
RTC_CNTL_PLLA_FORCE_PD, respectively. Disabling it takes priority over enabling it. When
RTC_CNTL_PLLA_FORCE_PU and RTC_CNTL_PLLA_FORCE_PD are 0, PLL follows the state of the system.
When the system enters sleep mode, PLL will be disabled automatically; when the system wakes up, PLL will be
enabled automatically.

Espressif Systems 88 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. Chip Boot Control

 

3. Chip Boot Control

3.1 Overview
ESP32-S2 has three strapping pins:

¢ GPIOO
° GPIO45
° GPIO46

Software can read the values of the three strapping pins from register GPIO_STRAPPING. During chip reset
triggered by power-on, brown-out or by analog super watchdog (see Chapter 2 Reset and Clock), hardware
samples and stores the voltage level of strapping pins as strapping bit of “O” or “1” in latches, and hold these bits
until the chip is powered down or shut down.

By default, GPIOO, GPIO45 and GPIO46 are connected to internal pull-up/pull-down during chip reset.
Consequently, if the three GPIOs are unconnected or their connected external circuits are high-impedance, the
internal weak pull-up/pull-down will determine the default input level of the strapping pins (see Table 14).

Table 14: Default Configuration of Strapping Pins

 

Pin GPIOO
Default

GPIO45
Pull-down

GPIO46
Pull-down

 

Pull-up

 

 

 

 

 

 

To change the default configuration of strapping pins, users can apply external pull-down/pull-up resistors, or use
host MCU GPIOs to control the voltage level of these pins when powering on ESP32-S2. After the reset is
released, the strapping pins work as normal-function pins.

3.2 Boot Mode
GPIOO and GPIO46 control the boot mode after reset.

Table 15: Boot Mode

 

 

 

Pin SPI Boot Download Boot
GPIOO 1 0
GPIO46 x 0

 

 

 

 

 

Table 15 shows the strapping pin values and the associated boot modes. ”x” means that this value is ignored.
Currently only the two boot modes shown are supported. The strapping combination of GPIOO = 0 and GPIO46
= 1 is not supported and will trigger unexpected behavior.

In SPI boot mode, the CPU boots the system by reading the program stored in SPI flash.

In download boot mode, users can download code to SRAM or Flash using UARTO, UART1, QPI or USB
interface. It is also possible to load a program into SRAM and execute it in this mode.

The following eFuses control boot mode behavior:

° EFUSE_DIS_FORCE_DOWNLOAD. If this eFuse is O (default), software can switch the chip from SPI boot
mode to download boot mode by setting register RTC_CNTL_FORCE_DOWNLOAD_ BOOT and triggering

Espressif Systems 39
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
8. Chip Boot Control

a CPU reset. If this eFuse is 1, this register is disabled.
e EFUSE_DIS_DOWNLOAD_MODE. If this eFuse is 1, download boot mode is disabled.

e EFUSE_ENABLE_SECURITY_DOWNLOAD. If this eFuse is 1, download boot mode only allows reading,
writing and erasing plaintext flash and does not support any SRAM or register operations. This eFuse is
ignored if download boot mode is disabled.

3.3. ROM Code Printing to UART

GPIO46 controls ROM code printing of information during the early boot process. This GPIO is used together
with the UART_PRINT_ CONTROL eFuse.

Table 16: ROM Code Printing Control

 

UART_PRINT_CONTROL | GPIO46 | ROM Code Printing
0 - ROM code will always print information to UART during boot.
GPIO46 is not used.

 

 

 

 

 

 

 

1 0 Print is enabled during boot
1 Print is disabled
9 0 Print is disabled
1 Print is enabled during boot
3 - Print is always disabled during boot. GPIO46 is not used.

 

 

 

 

ROM code will print to pin UOTXD (default) or to pin DAC_1, depending on the eFuse bit
UART_PRINT_CHANNEL (0: UARTO; 1: DAC_1).

3.4 VDD_SPI Voltage
GPIO45 is used to select the VDD_SPI power supply voltage at reset:

* GPIO45 = 0, VDD_SPI pin is powered directly from VDD3P3_RTC_IO via resistor Rspr. Typically this
voltage is 3.3 V.

* GPIO45 = 1, VDD_SPI pin is powered from internal 1.8 V LDO.

This functionality can be overridden by setting eFuse bit VDD_SPI_FORCE to 1, in which case the VDD_SPI_TIEH
eFuse value determines the VDD_SPI voltage:

¢ VDD_SPI_FORCE = 1 and VDD_SPI_TIEH = 0, VDD_SPI connects to 1.8 V LDO.

¢ VDD_SPI_FORCE = 1 and VDD_SPI_TIEH = 1, VDD_SPI connects to VDD3P3_RTC_IO.

Espressif Systems 40 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
4. Interrupt Matrix

 

4. Interrupt Matrix

4.1 Overview

The interrupt matrix embedded in ESP32-S2 independently allocates peripheral interrupt sources to the CPU

peripheral interrupts, so as to timely inform the CPU to process the interrupts once the interrupt signals are

generated. This flexible function is applicable to a variety of application scenarios.

4.2 Features

* Accept 95 peripheral interrupt sources as input

* Generate 26 peripheral interrupts to the CPU as output

* Disable CPU non-maskable interrupt (NMI) sources

* Query current interrupt status of peripheral interrupt sources

The structure of the interrupt matrix is shown in Figure 4-1.

 

PRO_CPU Config

Peripheral Interrupt Source

 

Interrupt
Matrix

 

Y

 

 

Interrupt Reg

Config Port

 

 

 

Status Port

 

<i _)

 

 

 

| INTERRUPT_PRO_NMI_MASK_HW ;

 

Interrupt Ctrl

 

 

 

 

 

 

 

 

PRO_CPU Peripheral Interrupt

 

 

Figure 4-1. Interrupt Matrix Structure

4.3 Functional Description

4.3.1 Peripheral Interrupt Sources
ESP32-S2 has 95 peripheral interrupt sources in total, all of which can be allocated to the CPU. For the

peripheral interrupt sources and their configuration/status registers, please refer to Table 17.

Espressif Systems

AY

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
yoeqnse uoeyueUINDOG Wwgns

suwe4shs jiIsseidsy

ov

(r'OA Areulwiieid) NHL ZS-ZEd SS

Table 17: CPU Peripheral Interrupt Configuration/Status Registers and Peripheral Interrupt Sources

 

Status Register

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

No. Source Configuration Register .
Bit Name
0 MAC_INTR INTERRUPT_PRO_MAC_INTR_MAP_REG 0
1 MAC_NMI INTERRUPT_PRO_MAC_NMI_MAP_REG 1
2 PWR_INTR INTERRUPT_PRO_PWR_INTR_MAP_REG 2
3 BB_INT INTERRUPT_PRO_BB_INT_MAP_REG 3
4 BT_MAC_INT INTERRUPT_PRO_BT_MAC_INT_MAP_REG 4
5 BT_BB_INT INTERRUPT_PRO_BT_BB_INT_MAP_REG 5
6 BT_BB_NMI INTERRUPT_PRO_BT_BB_NMI_MAP_REG 6
7 RWBT_IRQ INTERRUPT_PRO_RWBT_IRQ_MAP_REG 7
8 RWBLE_IRQ INTERRUPT_PRO_RWBLE_IRQ_MAP_REG 8
9 RWBT_NMI INTERRUPT_PRO_RWBT_NMI_LMAP_REG 9
10 RWBLE_NMI INTERRUPT_PRO_RWBLE_NMI_MAP_REG 10
11 SLCO_INTR INTERRUPT_PRO_SLCO_INTR_MAP_REG 11
12 SLC1_INTR INTERRUPT_PRO_SLC1_INTR_MAP_REG 12
18 UHCIO_INTR INTERRUPT_PRO_UHCIO_INTR_MAP_REG 18
14 UHCH_INTR INTERRUPT_PRO_UHCI1_INTR_MAP_REG 14
15 TG_TO_LEVEL_INT INTERRUPT_PRO_TG_TO_LEVEL_INT_MAP_REG 15
16 TG_T1_LEVEL_INT INTERRUPT_PRO_TG_T1_LEVEL_INT_MAP_REG 16 INTERRUPT_PRO_INTR_STATUS_REG_O_REG
17 TG_WDT_LEVEL_INT INTERRUPT_PRO_TG_WDT_LEVEL_INT_MAP_REG 17
18 TG_LACT_LEVEL_INT INTERRUPT_PRO_TG_LACT_LEVEL_INT_MAP_REG 18
19 TG1_TO_LEVEL_INT INTERRUPT_PRO_TG1_TO_LEVEL_INT_MAP_REG 19
20 TG1_T1_LEVEL_INT INTERRUPT_PRO_TG1_T1_LEVEL_INT_MAP_REG 20
21 TG1_WDT_LEVEL_INT INTERRUPT_PRO_TG1_WDT_LEVEL_INT_MAP_REG 21
22 TG1_LACT_LEVEL_INT INTERRUPT_PRO_TG1_LACT_LEVEL_INT_MAP_REG 22
23 GPIO_INTERRUPT_PRO INTERRUPT_PRO_GPIO_INTERRUPT_PRO_MAP_REG 23
24 GPIC_INTERRUPT_PRO_NMI | INTERRUPT_PRO_GPIO_INTERRUPT_PRO_NMILMAP_REG | 24
25 GPIO_INTERRUPT_APP. INTERRUPT_PRO_GPIO_INTERRUPT_APP_MAP_REG 25
26 GPIO_INTERRUPT_APP_NMI INTERRUPT_PRO_GPIO_INTERRUPT_APP_NMILMAP_REG | 26
27 DEDICATED_GPIC_IN_INTR INTERRUPT_PRO_DEDICATED_GPIO_IN_INTR_MAP_REG 27
28 CPU_INTR_FROM_CPU_O INTERRUPT_PRO_CPU_INTR_FROM_CPU_O_MAP_REG 28
29 CPU_INTR_FROM_CPU_1 INTERRUPT_PRO_CPU_INTR_FROM_CPU_1_MAP_REG 29
30 CPU_INTR_FROM_CPU_2 INTERRUPT_PRO_CPU_INTR_FROM_CPU_2_MAP_REG 30
31 CPU_INTR_FROM_CPU_3 INTERRUPT_PRO_CPU_INTR_FROM_CPU_3_MAP_REG 31
32 SPI_INTR_1 INTERRUPT_PRO_SPI_INTR_1_MAP_REG 0
33 SPILINTR_2 INTERRUPT_PRO_SPI_INTR_2_MAP_REG 1 INTERRUPT_PRO_INTR_STATUS_REG_1_REG
34 SPILINTR_3 INTERRUPT_PRO_SPI_INTR_3_MAP_REG 2

Xue) Idrueuy “+

 

 

 
yoeqnse uoeyueUINDOG Wwgns

suwe4shs jiIsseidsy

ev

(r'OA Areulwiieid) NHL ZS-ZEd SS

 

Status Register

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

No. Source Configuration Register .
Bit Name

35 12S0_INT INTERRUPT_PRO_I2S0_INT_MAP_REG 3
36 12S1_INT INTERRUPT_PRO_I2S 1_INT_MAP_REG 4
37 UART_INTR INTERRUPT_PRO_UART_INTR_MAP_REG 5
38 UART1_INTR INTERRUPT_PRO_UART1_INTR_MAP_REG 6
39 UART2_INTR INTERRUPT_PRO_UART2_INTR_MAP_REG 7
40 SDIO_HOST_INTERRUPT INTERRUPT_PRO_SDIO_HOST_INTERRUPT_MAP_REG 8
At PWMO_INTR INTERRUPT_PRO_PWMO_INTR_MAP_REG 9
42 PWM1_INTR INTERRUPT_PRO_PWM1_INTR_MAP_REG 10
43 PWM2_INTR INTERRUPT_PRO_PWM2_INTR_MAP_REG 11
44 PWM3_INTR INTERRUPT_PRO_PWM3_INTR_MAP_REG 12
45 LEDC_INT INTERRUPT_PRO_LEDC_INT_MAP_REG 18
46 EFUSE_INT INTERRUPT_PRO_EFUSE_INT_MAP_REG 14
47 CAN_INT INTERRUPT_PRO_CAN_INT_MAP_REG 15
48 USB_INTR INTERRUPT_PRO_USB_INTR_MAP_REG 16
49 RTC_CORE_INTR INTERRUPT_PRO_RTC_CORE_INTR_MAP_REG 17
50 RMT_INTR INTERRUPT_PRO_RMT_INTR_MAP_REG 18
51 PCNT_INTR INTERRUPT_PRO_PCNT_INTR_MAP_REG 19 | INTERRUPT_PRO_INTR_STATUS_REG_1_REG
52 12C_EXTO_INTR INTERRUPT_PRO_I2C_EXTO_INTR_MAP_REG 20
53 12C_EXT1_INTR INTERRUPT_PRO_I2C_EXT1_INTR_MAP_REG 21
54 RSA_INTR INTERRUPT_PRO_RSA_INTR_MAP_REG 22
55 SHA_INTR INTERRUPT_PRO_SHA_INTR_MAP_REG 23
56 AES_INTR INTERRUPT_PRO_AES_INTR_MAP_REG 24
57 SP12_DMA_INT INTERRUPT_PRO_SPI2_DMA_INT_MAP_REG 25
58 SPI3_DMA_INT INTERRUPT_PRO_SPI3_DMA_INT_MAP_REG 26
59 WDG_INT INTERRUPT_PRO_WDG_INT_MAP_REG 27
60 TIMER_INT INTERRUPT_PRO_TIMER_INT1_MAP_REG 28
61 TIMER_INT2 INTERRUPT_PRO_TIMER_INT2_MAP_REG 29
62 TG_TO_EDGE_INT INTERRUPT_PRO_TG_TO_EDGE_INT_MAP_REG 30
63 TG_T1_EDGE_INT INTERRUPT_PRO_TG_T1_EDGE_INT_MAP_REG 31
64 TG_WDT_EDGE_INT INTERRUPT_PRO_TG_WDT_EDGE_INT_MAP_REG 0
65 TG_LACT_EDGE_INT INTERRUPT_PRO_TG_LACT_EDGE_INT_MAP_REG 1
66 TG1_TO_EDGE_INT INTERRUPT_PRO_TG1_TO_EDGE_INT_MAP_REG 2
67 TG1_T1_EDGE_INT INTERRUPT_PRO_TG1_T1_EDGE_INT_MAP_REG 3
68 TG1_WDT_EDGE_INT INTERRUPT_PRO_TG1_WDT_EDGE_INT_MAP_REG 4 INTERRUPT_PRO_INTR_STATUS_REG_2_REG
69 TG1_LACT_EDGE_INT INTERRUPT_PRO_TG1_LACT_EDGE_INT_MAP_REG 5
70 CACHE_IA_INT INTERRUPT_PRO_CACHE_IA_INT_MAP_REG 6
71 SYSTIMER_TARGETO_INT INTERRUPT_PRO_SYSTIMER_TARGETO_INT_MAP_REG 7

 

 

 

 

 

 

 

Xue) Idrueuy “+
yoeqnse uoeyueUINDOG Wwgns

suwe4shs jiIsseidsy

vv

(r'OA Areulwiieid) NHL ZS-ZEd SS

 

Status Register

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

No. Source Configuration Register .
Bit Name
72 SYSTIMER_TARGET 1_INT INTERRUPT_PRO_SYSTIMER_TARGET1_INT_MAP_REG 8
73 SYSTIMER_TARGET2_INT INTERRUPT_PRO_SYSTIMER_TARGET2_INT_MAP_REG 9
74 ASSIST_DEBUG_INTR INTERRUPT_PRO_ASSIST_DEBUG_INTR_MAP_REG 10
75 PMS_PRO_IRAMG_ILG_INTR INTERRUPT_PRO_PMS_PRO_IRAMO_ILG_INTR_MAP_REG 11
78 | PMS_PRO_DRAMO_ILG_INTR | INTERRUPT_PRO_PMS_PRO_DRAMO_ILG_INTR_MAP_REG | 12
77 | PMS_PRO_DPORT_ILG_INTR | INTERRUPT_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_REG | 13
78 PMS_PRO_AHB_ILG_INTR INTERRUPT_PRO_PMS_PRO_AHB_ILG_INTR_MAP_REG 14
79 | PMS_PRO_CACHE_ILG_INTR | INTERRUPT_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_REG | 15
80 PMS_DMA_APB_I_ILG_INTR INTERRUPT_PRO_PMS_DMA_APB_I_ILG_INTR_MAP_REG 16
81 PMS_DMA_RxX_I_ILG_INTR INTERRUPT_PRO_PMS_DMA_RX_I_ILG_INTR_MAP_REG 17
82 PMS_DMA_TX_I_ILG_INTR INTERRUPT_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_REG 18
83 SPILMEM_REJECT_INTR INTERRUPT_PRO_SPILMEM_REJECT_INTR_MAP_REG 19
84 DMA_COPY_INTR INTERRUPT_PRO_DMA_COPY_INTR_MAP_REG 20
85 SPI4_DMA_INT INTERRUPT_PRO_SPI4_DMA_INT_MAP_REG 21
86 DCACHE_PRELOAD_INT INTERRUPT_PRO_DCACHE_PRELCAD_INT_MAP_REG 22
87 DCACHE_PRELOAD_INT INTERRUPT_PRO_DCACHE_PRELOAD_INT_MAP_REG 23 | INTERRUPT_PRO_INTR_STATUS_REG_2_REG
88 ICACHE_PRELCAD_INT INTERRUPT_PRO_ICACHE_PRELOAD_INT_MAP_REG 24
89 APB_ADC_INT INTERRUPT_PRO_APB_ADC_INT_MAP_REG 25
90 CRYPTO_DMA_INT INTERRUPT_PRO_CRYPTO_DMA_INT_MAP_REG 26
91 CPU_PERI_LERROR_INT INTERRUPT_PRO_CPU_PERI_ERROR_INT_MAP_REG 27
92 APB_PERI_ERROR_INT INTERRUPT_PRO_APB_PERILERROR_INT_MAP_REG 28
93 DCACHE_SYNC_INT INTERRUPT_PRO_DCACHE_SYNC_INT_MAP_REG 29
94 ICACHE_SYNC_INT INTERRUPT_PRO_ICACHE_SYNC_INT_MAP_REG 30

 

 

 

 

 

 

 

Xue) Idrueuy “+
4. Interrupt Matrix

 

4.3.2 CPU Interrupts
The CPU has 32 interrupts, including 26 peripheral interrupts and six internal interrupts. Table 18 lists all the
interrupts.

* Peripheral Interrupts:

— Level-triggered interrupts: triggered by high level signal. The interrupt sources should hold the level till
the CPU handles the interrupts.

— Edge-triggered interrupts: triggered on rising edge. The CPU responds to this kind of interrupts
immediately.

— NMI interrupt: once triggered, the NMI interrupt can not be masked by software using the CPU
registers.

® Internal Interrupts:
— Timer interrupts: triggered by internal timers and are used to generate periodic interrupts.
— Software interrupts: triggered when software writes to special registers.
— Profiling interrupt: triggered for performance monitoring and analysis.

ESP32-S2 supports the above-mentioned 32 interrupts at six levels as shown in the table below. A higher level
corresponds to a higher priority. NMI has the highest interrupt priority and once triggered, the CPU must handle
such interrupt.

Table 18: CPU Interrupts

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

No, Category Type Priority Level
0 Peripheral Level-triggered 1

1 Peripheral Level-triggered 1

2 Peripheral Level-triggered 1

3 Peripheral Level-triggered 1

4 Peripheral Level-triggered 1

5 Peripheral Level-triggered 1

6 Internal Timer. 1

7 Internal Software 1

8 Peripheral Level-triggered 1

9 Peripheral Level-triggered 1
10 Peripheral Edge-triggered 1

11 Internal Profiling 3
12 Peripheral Level-triggered 1

13 Peripheral Level-triggered 1

14 Peripheral NMI NMI
15 Internal Timer.1 3
16 Internal Timer.2 5
17 Peripheral Level-triggered 1

18 Peripheral Level-triggered 1

19 Peripheral Level-triggered 2
20 Peripheral Level-triggered 2

Espressif Systems 45 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

No, Category Type Priority Level
21 Peripheral Level-triggered 2
22 Peripheral Edge-triggered 3
23 Peripheral Level-triggered 3
24 Peripheral Level-triggered 4
25 Peripheral Level-triggered 4
26 Peripheral Level-triggered 5
27 Peripheral Level-triggered 3
28 Peripheral Edge-triggered 4
29 Internal Software 3
30 Peripheral Edge-triggered 4
31 Peripheral Level-triggered 5

 

 

 

 

 

4.3.3 Allocate Peripheral Interrupt Source to CPU Interrupt
In this section, the following terms are used to describe the operation of the interrupt matrix.

® Source_X: stands for a particular peripheral interrupt source, wherein, X means the number of this interrupt
source in Table 17.

° INTERRUPT_PRO_X MAP_REG: stands for a peripheral interrupt configuration register, corresponding to
the peripheral interrupt source Source_X. In Table 17, the registers listed in column ”Configuration Register”
correspond to the peripheral interrupt sources listed in column “Source”. For example, the configuration
register for source MAC_INTR is INTERRUPT_PRO_MAC_INTR_MAP_REG.

® Interrupt_P: stands for the CPU peripheral interrupt numbered as Num_P. The value of Num_P can be 0 ~
5,8~ 10, 12~ 14, 17 ~ 28 and 30 ~ 31 (see Table 18).

® Interrupt_l: stands for the CPU internal interrupt numbered as Num_lI. The value of Num_lI can be 6, 7, 11,
15, 16 and 29 (see Table 18).

4.3.3.1 Allocate one peripheral interrupt source Source_X to CPU

Setting the corresponding configuration register INTERRUPT_PRO_X_ MAP_REG of Source_X to Num_P will
allocate this interrupt source to Interrupt_P. Num_P here can be any value from 0 ~ 5,8 + 10,12 + 14, 17 + 28
and 30 ~ 31. Note that one CPU interrupt can be shared by multiple peripherals.

4.3.3.2 Allocate multiple peripheral interrupt sources Source_Xn to CPU

Setting the corresponding configuration register INTERRUPT _PRO_X7_MAP_REG of each interrupt source to the
same Num_P will allocate all the sources to the same Interrupt_P. Any of these sources will trigger CPU
Interrupt_P. When an interrupt signal is generated, software should check the interrupt status registers to figure
out which peripheral the signal comes from.

4.3.3.3 Disable CPU peripheral interrupt source Source_X

Setting the corresponding configuration register INTERRUPT _PRO_X_MAP_REG of the source to any Num_! will
disable this interrupt Source_X. The choice of Num_| does not matter, as none of Num_| is connected to the
CPU. Therefore this functionality can be used to disable peripheral interrupt sources.

Espressif Systems 46 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
4. Interrupt Matrix

 

4.3.4 Disable CPU NMI Interrupt Sources

The interrupt matrix is able to mask all peripheral interrupt sources allocated to CPU No.14 NMI interrupt using
hardware, depending on the internal signal INTERRUPT_PRO_NMI_MASK_HW. The signal comes from
"Interrupt Reg” register configuration submodule inside interrupt matrix, see Figure 4-1. If the signal is set to high
level, CPU will not respond to NMI interrupt.

4.3.5 Query Current Interrupt Status of Peripheral Interrupt Source

Current interrupt status of a peripheral interrupt source can be read via the bit value in
INTERRUPT_PRO_INTR_STATUS_REG_»n. For the mapping between INTERRUPT_PRO_INTR_STATUS_REG_»
and peripheral interrupt sources, please refer to Table 17.

4.4 Base Address

Users can access interrupt matrix with the base address as shown in Table 19. For more information, see
Chapter 1 System and Memory.

Table 19: Interrupt Matrix Base Address

 

Bus to Access Peripheral Base Address
PeriBUS1 Ox3F4C2000

 

 

 

 

 

4.5 Register Summary

The address in the following table represents the address offset (relative address) with the respect to the
peripheral base address, not the absolute address. For detailed information about the interrupt matrix base
address, please refer to Section 4.4.

Espressif Systems 47 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
yoeqnse uoeyueUINDOG Wwgns

suwe4shs jiIsseidsy

8V

(r'OA Areulwiieid) NHL ZS-ZEd SS

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
Configuration registers

INTERRUPT_PRO_MAC_INTR_MAP_REG MAC_INTR interrupt configuration register Ox0000 | R/AV
INTERRUPT_PRO_MAC_NMI_MAP_REG MAC_NMI interrupt configuration register O0x0004 | R/AV
INTERRUPT_PRO_PWR_INTR_MAP_REG PWER_INTR interrupt configuration register O0x0008 | R/AV
INTERRUPT_PRO_BB_INT_MAP_REG BB_INT interrupt configuration register Ox000C | R/AV
INTERRUPT_PRO_BT_MAC_INT_MAP_REG BT_MAC_INT interrupt configuration register O0x0010 | RAV
INTERRUPT_PRO_BT_BB_INT_MAP_REG BT_BB_INT interrupt configuration register 0x0014 | RAV
INTERRUPT_PRO_BT_BB_NMI_MAP_REG BT_BB_NM1| interrupt configuration register 0x0018 | RAV
INTERRUPT_PRO_RWBT_IRQ_MAP_REG RWBT_IRQ interrupt configuration register Ox001C | RAV
INTERRUPT_PRO_RWBLE_IRQ_MAP_REG RWBLE_IRQ interrupt configuration register 0x0020 | RAV
INTERRUPT_PRO_RWBT_NMI_MAP_REG RWBT_NMI interrupt configuration register 0x0024 | RAV
INTERRUPT_PRO_RWBLE_NMI_MAP_REG RWBLE_NM1I interrupt configuration register 0x0028 | RAV
INTERRUPT_PRO_SLCO_INTR_MAP_REG SLCO_INTR interrupt configuration register Ox002C | RAV
INTERRUPT_PRO_SLC1_INTR_MAP_REG SLC1_INTR interrupt configuration register O0x0030 | RAV
INTERRUPT_PRO_UHCIO_INTR_MAP_REG UHCIO_INTR interrupt configuration register 0x0034 | R/AV
INTERRUPT_PRO_UHCI1_INTR_MAP_REG UHCI1_INTR interrupt configuration register 0x0038 | R/AV
INTERRUPT_PRO_TG_TO_LEVEL_INT_MAP_REG TG_TO_LEVEL_INT interrupt configuration register Ox0038C | RAV
INTERRUPT_PRO_TG_T1_LEVEL_INT_MAP_REG TG_T1_LEVEL_INT interrupt configuration register 0x0040 | RAV
INTERRUPT_PRO_TG_WDT_LEVEL_INT_MAP_REG TG_WDT_LEVEL_INT interrupt configuration register 0x0044 | RAV
INTERRUPT_PRO_TG_LACT_LEVEL_INT_MAP_REG TG_LACT_LEVEL_INT interrupt configuration register 0x0048 =| RAV
INTERRUPT_PRO_TG1_TO_LEVEL_INT_MAP_REG TG1_TO_LEVEL_INT interrupt configuration register Ox004C | RAV
INTERRUPT _PRO_TG1_T1_LEVEL_INT_MAP_REG TG1_T1_LEVEL_INT interrupt configuration register Ox0050 | RAV
INTERRUPT_PRO_TG1_WDT_LEVEL_INT_MAP_REG TG1_WDT_LEVEL_INT interrupt configuration register 0x0054 | RAV
INTERRUPT_PRO_TG1_LACT_LEVEL_INT_MAP_REG TG1_LACT_LEVEL_INT interrupt configuration register O0x0058 | R/AV
INTERRUPT_PRO_GPIO_INTERRUPT_PRO_MAP_REG GPIO_INTERRUPT_PRO interrupt configuration register Ox005C | RAV
INTERRUPT_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_REG | GPIO_INTERRUPT_PRO_NMI interrupt configuration register | OxOO060 | R/AW
INTERRUPT_PRO_GPIO_INTERRUPT_APP_MAP_REG GPIO_INTERRUPT_APP interrupt configuration register Ox0064 | R/AV
INTERRUPT_PRO_GPIO_INTERRUPT_APP_NMI_MAP_REG_ | GPIO_INTERRUPT_APP_NMI interrupt configuration register | OxO0068 | R/AW
INTERRUPT _PRO_DEDICATED_GPIO_IN_INTR_MAP_REG DEDICATED_GPIO_IN_INTR interrupt configuration register Ox006C_ | R/AV

 

 

 

Xue) Idrueuy “+
yoeqnse uoeyueUINDOG Wwgns

suwe4shs jiIsseidsy

6Vv

(r'OA Areulwiieid) NHL ZS-ZEd SS

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
INTERRUPT_PRO_CPU_INTR_FROM_CPU_O_MAP_REG CPU_INTR_FROM_CPU_0 interrupt configuration register O0x0070 | RAV
INTERRUPT_PRO_CPU_INTR_FROM_CPU_1_MAP_REG CPU_INTR_FROM_CPU_1 interrupt configuration register 0x0074 | RAV
INTERRUPT_PRO_CPU_INTR_FROM_CPU_2_MAP_REG CPU_INTR_FROM_CPU_2 interrupt configuration register 0x0078 | RAV
INTERRUPT_PRO_CPU_INTR_FROM_CPU_3_MAP_REG CPU_INTR_FROM_CPU_3 interrupt configuration register Ox007C | RAV
INTERRUPT_PRO_SPI_INTR_1_MAP_REG SPIINTR_1 interrupt configuration register Ox0080 | RAV
INTERRUPT_PRO_SPI_INTR_2_MAP_REG SPIINTR_2 interrupt configuration register 0x0084 | R/AV
INTERRUPT _PRO_SPI_INTR_3_. MAP_REG SPIINTR_3 interrupt configuration register Ox0088 | RAV
INTERRUPT _PRO_1I2S0_INT_MAP_REG 1280_INT interrupt configuration register Ox008C_ | R/AV
INTERRUPT_PRO_|I281_INT_MAP_REG 1281_INT interrupt configuration register Ox0090 | R/AV
INTERRUPT_PRO_UART_INTR_MAP_REG UART_INT interrupt configuration register 0x0094 | R/AV
INTERRUPT_PRO_UART1_INTR_MAP_REG UART1_INT interrupt configuration register O0x0098 | R/AV
INTERRUPT_PRO_UART2_INTR_MAP_REG UART2_INT interrupt configuration register Ox009C | RAV
INTERRUPT_PRO_SDIO_HOST_INTERRUPT_MAP_REG SDIO_HOST_INTERRUPT configuration register OxOO0AO | RAV
INTERRUPT_PRO_PWMO_INTR_MAP_REG PWMO_INTR interrupt configuration register OxO0A4 | R/AV
INTERRUPT_PRO_PWM1_INTR_MAP_REG PWM1_INTR interrupt configuration register OxO0A8 | R/AV
INTERRUPT_PRO_PWM2_INTR_MAP_REG PWM2_INTR interrupt configuration register OxOOAC | RAV
INTERRUPT_PRO_PWM3_INTR_MAP_REG PWM3_INTR interrupt configuration register OxOOBO | R/AV
INTERRUPT_PRO_LEDC_INT_MAP_REG LEDC_INTR interrupt configuration register Ox00B4 | RAV
INTERRUPT_PRO_EFUSE_INT_MAP_REG EFUSE_INT interrupt configuration register OxO00B8 | R/V
INTERRUPT_PRO_CAN_INT_MAP_REG CAN_INT interrupt configuration register OxOOBC | R/AV
INTERRUPT_PRO_USB_INTR_MAP_REG USB_INT interrupt configuration register Ox00CO | R/AV
INTERRUPT_PRO_RTC_CORE_INTR_MAP_REG RTC_CORE_INTR interrupt configuration register Ox00C4 | RAV
INTERRUPT_PRO_RMT_INTR_MAP_REG RMT_INTR interrupt configuration register Ox00C8 | R/AV
INTERRUPT_PRO_PCNT_INTR_MAP_REG PCNT_INTR interrupt configuration register Ox00CC | R/AV
INTERRUPT _PRO_|I2C_EXTO_INTR_MAP_REG 12C_EXTO_INTR interrupt configuration register OxOO0DO | R/AV
INTERRUPT_PRO_|I2C_EXT1_INTR_MAP_REG 12C_EXT1_INTR interrupt configuration register Ox00D4 | RAV
INTERRUPT_PRO_RSA_INTR_MAP_REG RSA_INTR interrupt configuration register Ox00D8 | RAV
INTERRUPT_PRO_SHA_INTR_MAP_REG SHA_INTR interrupt configuration register OxOODC | R/AV
INTERRUPT_PRO_AES_INTR_MAP_REG AES_INTR interrupt configuration register OxOOEO | R/AV

 

 

 

 

 

 

Xue) Idrueuy “+
yoeqnse uoeyueUINDOG Wwgns

suwe4shs jiIsseidsy

og

(r'OA Areulwiieid) NHL ZS-ZEd SS

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
INTERRUPT_PRO_SPI2_DMA_INT_MAP_REG SPI2_DMA_INT interrupt configuration register OxOOE4 | R/AV
INTERRUPT_PRO_SPI3_DMA_INT_MAP_REG SPI3_DMA_INT interrupt configuration register OxO0E8 | R/AV
INTERRUPT_PRO_WDG_INT_MAP_REG WDG_INT interrupt configuration register OxOOEC | R/AV
INTERRUPT_PRO_TIMER_INT1_MAP_REG TIMER_INT1 interrupt configuration register OxOOFO | R/AV
INTERRUPT_PRO_TIMER_INT2_MAP_REG TIMER_INT2 interrupt configuration register OxOOF4 | RAV
INTERRUPT_PRO_TG_TO_EDGE_INT_MAP_REG TG_TO_EDGE_INT interrupt configuration register OxOOF8 | R/AV
INTERRUPT_PRO_TG_T1_EDGE_INT_MAP_REG TG_T1_EDGE_INT interrupt configuration register OxOOFC | R/AV
INTERRUPT_PRO_TG_WDT_EDGE_INT_MAP_REG TG_WDT_EDGE_INT interrupt configuration register Ox0100 | RAV
INTERRUPT_PRO_TG_LACT_EDGE_INT_MAP_REG TG_LACT_EDGE_INT interrupt configuration register O0x0104 | RAV
INTERRUPT_PRO_TG1_TO_EDGE_INT_MAP_REG TG1_TO_EDGE_INT interrupt configuration register O0x0108 | RAV
INTERRUPT_PRO_TG1_T1_EDGE_INT_MAP_REG TG1_T1_EDGE_INT interrupt configuration register Ox010C | RAV
INTERRUPT_PRO_TG1_WDT_EDGE_INT_MAP_REG TG1_WDT_EDGE_INT interrupt configuration register O0x0110 | RAV
INTERRUPT_PRO_TG1_LACT_EDGE_INT_MAP_REG TG1_LACT_EDGE_INT interrupt configuration register 0x0114 | RAV
INTERRUPT_PRO_CACHE_IA_INT_MAP_REG CACHE_IA_INT interrupt configuration register 0x0118 | RAV
INTERRUPT_PRO_SYSTIMER_TARGETO_INT_MAP_REG SYSTIMER_TARGETO_INT interrupt configuration register Ox011C | RAV
INTERRUPT_PRO_SYSTIMER_TARGET1_INT_MAP_REG SYSTIMER_TARGET1_INT interrupt configuration register 0x0120 | RAV
INTERRUPT _PRO_SYSTIMER_TARGET2_INT_MAP_REG SYSTIMER_TARGET2 interrupt configuration register 0x0124 | RAV
INTERRUPT_PRO_ASSIST_DEBUG_INTR_MAP_REG ASSIST_DEBUG_INTR interrupt configuration register 0x0128 | RAV
INTERRUPT _PRO_PMS_PRO_IRAMO_ILG_INTR_MAP_REG_ | PMS_PRO_IRAMO_ILG interrupt configuration register O0x012C | RAV
INTERRUPT_PRO_PMS_PRO_DRAMO_ILG_INTR_MAP_REG | PMS_PRO_DRAMO_ILG interrupt configuration register 0x0130 | RAV
INTERRUPT_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_REG | PMS_PRO_DPORT_ILG interrupt configuration register 0x0134 | RAV
INTERRUPT_PRO_PMS_PRO_AHB_ILG_INTR_MAP_REG PMS_PRO_AHB_ILG interrupt configuration register 0x0138 | RAV
INTERRUPT_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_REG | PMS_PRO_CACHE_ILG interrupt configuration register Ox013C | RAV
INTERRUPT_PRO_PMS_DMA_APB_|_ILG_INTR_MAP_REG PMS_DMA_APB._|_ILG interrupt configuration register 0x0140 | RAV
INTERRUPT_PRO_PMS_DMA_RX_|_ILG_INTR_MAP_REG PMS_DMA_RX_|_ILG interrupt configuration register 0x0144 | RAV
INTERRUPT_PRO_PMS_DMA_TX_|_ILG_INTR_MAP_REG PMS_DMA_TX_|_ILG interrupt configuration register 0x0148 | RAV
INTERRUPT_PRO_SPI_MEM_REJECT_INTR_MAP_REG SPILMEM_REJECT_INTR interrupt configuration register Ox014C | RAV
INTERRUPT_PRO_DMA_COPY_INTR_MAP_REG DMA_COPY_INTR interrupt configuration register O0x0150 | RAV
INTERRUPT_PRO_SPI4_DMA_INT_MAP_REG SPl4_DMA_INT interrupt configuration register 0x0154 | RAV

 

 

 

Xue) Idrueuy “+
yoeqnse uoeyueUINDOG Wwgns

suwe4shs jiIsseidsy

LS

(r'OA Areulwiieid) NHL ZS-ZEd SS

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
INTERRUPT_PRO_SPI_INTR_4_MAP_REG SPIINTR_4 interrupt configuration register 0x0158 | RAV
INTERRUPT_PRO_DCACHE_PRELOAD_INT_MAP_REG DCACHE_PRELOAD_INT interrupt configuration register Ox015C | RAV
INTERRUPT _PRO_ICACHE_PRELOAD_INT_MAP_REG ICACHE_PRELOAD_INT interrupt configuration register Ox0160 | RAV
INTERRUPT_PRO_APB_ADC_INT_MAP_REG APB_ADC_INT interrupt configuration register 0x0164 | RAV
INTERRUPT_PRO_CRYPTO_DMA_INT_MAP_REG CRYPTO_DMA_ INT interrupt configuration register O0x0168 | RAV
INTERRUPT_PRO_CPU_PERI_ERROR_INT_MAP_REG CPU_PERI_ERROR_INT interrupt configuration register Ox016C | RAV
INTERRUPT_PRO_APB_PERI_LERROR_INT_MAP_REG APB_PERI_ERROF_INT interrupt configuration register 0x0170 | RAV
INTERRUPT_PRO_DCACHE_SYNC_INT_MAP_REG DCACHE_SYNC_INT interrupt configuration register 0x0174 | RAV
INTERRUPT_PRO_ICACHE_SYNC_INT_MAP_REG ICACHE_SYNC_INT interrupt configuration register 0x0178 | RAV
INTERRUPT_CLOCK_GATE_REG NMI interrupt signals mask register 0x0188 | RAV
Interrupt status registers

INTERRUPT_PRO_INTR_STATUS_REG_O_REG Interrupt status register O 0x017C | RO
INTERRUPT_PRO_INTR_STATUS_REG_1_REG Interrupt status register 1 0x0180 | RO
INTERRUPT_PRO_INTR_STATUS_REG_2 REG Interrupt status register 2 0x0184 | RO
Version register

INTERRUPT_REG_DATE_REG Version control register OxOFFC | RAV

 

 

 

Xue) Idrueuy “+
4. Interrupt Matrix

 

4.6 Registers

The address in the following part represents the address offset (relative address) with respect to the peripheral
base acidress, not the absolute address. For detailed information about the interrupt matrix base address, please
refer to Section 4.4.

Register 4.1: INTERRUPT_PRO_MAC_INTR_MAP_REG (0x0000)

 

 

 

 

 

 

 

 

x
&
we
ee
S Se
gs &
& <
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_MAC_INTR_MAP This register is used to map MAC_INTR interrupt signal to one
of the CPU interrupts. (RAV)
Register 4.2: INTERRUPT_PRO_MAC_NMI_MAP_REG (0x0004)
Wy
SS
O7
we
°
x?
S S
sf &
& s
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_MAC_ NMI MAP This register is used to map MAC_NMI interrupt signal to one
of the CPU interrupts. (RAV)
Espressif Systems 52 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.3: INTERRUPT_PRO_PWR_INTR_MAP_REG (0x0008)

 

 

 

 

 

 

 

 

 

 

 

 

rr
Qa’
oe
oe
€
S S
sf &
& <
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_PWR_INTR_MAP This register is used to map PWR_INTR interrupt signal to one
of the CPU interrupts. (RAV)
Register 4.4: INTERRUPT_PRO_BB_INT_MAP_REG (0x000C)
SX
S
&
x?
S S$
sf &
& s
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_BB_INT_MAP This register is used to map BB_INT interrupt signal to one of the
CPU interrupts. (RAM)
Register 4.5: INTERRUPT_PRO_BT_MAC_INT_MAP_REG (0x0010)
&
ss
Ww
e
&
x?
se &
& Ss
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_BT_MAC_INT_MAP This register is used to map BT_MAC_INT interrupt signal
to one of the CPU interrupts. (R/V)
Espressif Systems 53 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.6: INTERRUPT_PRO_BT_BB_INT_MAP_REG (0x0014)
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_BT_BB_INT_MAP This register is used to map BT_BB_INT interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.7: INTERRUPT_PRO_BT_BB_NMI_MAP_REG (0x0018)
&
gy
©
x?
S S
gs &
& <
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_BT_BB_NMI_MAP This register is used to map BT_BB_NMI interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.8: INTERRUPT_PRO_RWBT_IRQ_ MAP_REG (0x001C)
€
Ss
a
s
©
x?
S S$
sf &
€ &
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_RWBT_IRQ_ MAP This register is used to map RWBT_IRQ interrupt signal to one
of the CPU interrupts. (RAV)
Espressif Systems 54 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.9: INTERRUPT_PRO_RWBLE_IRQ_MAP_REG (0x0020)

 

 

 

 

 

 

 

 

 

 

 

 

ee
ow
s
&
gz?
g
se &
oS A
€ RS
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_RWBLE_IRQ MAP This register is used to map RWBLE_IRQ interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.10: INTERRUPT_PRO_RWBT_NMI_MAP_REG (0x0024)
8
Ww
S
SY
s
&
x?
S S$
sf &
€ s
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_RWBT_NMI MAP This register is Used to map RWBT_NMI interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.11: INTERRUPT_PRO_RWBLE_NMI_MAP_REG (0x0028)
WY
SS
ow
s
&
x?
S S$
sf &
€ s
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_RWBLE_NMI_MAP This register is used to map RWBLE_NMI interrupt signal to
one of the CPU interrupts. (RAV)
Espressif Systems 55 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.12: INTERRUPT_PRO_SLCO_INTR_MAP_REG (0x002C)

 

 

 

 

 

 

 

 

 

 

w
QO’
”
e°
x?
g
& ge
& <
NS s
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_SLCO_INTR_MAP This register is used to map SLCO_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.13: INTERRUPT_PRO_SLC1_INTR_MAP_REG (0x0030)

00000000000 0000000000000 00 0 16 |Reset
INTERRUPT_PRO_SLC1_INTR_MAP This register is used to map SLC1_INTR interrupt signal to
one of the CPU interrupts. (RAV)




Register 4.14: INTERRUPT_PRO_UHCIO_INTR_MAP_REG (0x0034)
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_UHCIO_INTR_MAP This register is used to map UHCIO_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Espressif Systems 56 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.15: INTERRUPT_PRO_UHCI1_INTR_MAP_REG (0x0038)

 

 

 

[oo 0000000000090 00000900000000 0 16 |Reset

 

INTERRUPT_PRO_UHCI1_INTR_MAP. This register is used to map UHCI1_INTR interrupt signal to
one of the CPU interrupts. (RAV)

Register 4.16: INTERRUPT_PRO_TG_TO_LEVEL_INT_MAP_REG (0x003C)

 

 

 

[oo 0000000000090 00000900000000 0 16 |Reset

 

INTERRUPT_PRO_TG_TO LEVEL _INT_MAP This register is used to map TG_TO_LEVEL_INT inter-
rupt signal to one of the CPU interrupts. (RAM)

Register 4.17: INTERRUPT_PRO_TG_T1_LEVEL_INT_MAP_REG (0x0040)

 

 

 

INTERRUPT_PRO_TG_T1_LEVEL_INT_MAP This register is used to map TG_T1_LEVEL_INT inter-
rupt signal to one of the CPU interrupts. (RAM)

Espressif Systems 57 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.18: INTERRUPT_PRO_TG_WDT_LEVEL_INT_MAP_REG (0x0044)

 

 

 

Sy
ev
or
ee
&
> ©
Ss Ss
@ S
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset

 

INTERRUPT_PRO_TG_WDT_LEVEL_INT_MAP This register is used to map TG_WDT_LEVEL_INT
interrupt signal to one of the CPU interrupts. (RAV)

Register 4.19: INTERRUPT_PRO_TG_LACT_LEVEL_INT_MAP_REG (0x0048)
 

 

 

A
Oo
¥
nor
&*
gz?
S &
.~ Bs
Sf x
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset

 

INTERRUPT_PRO_TG_LACT_LEVEL_INT_MAP This register is used to map TG_LACT_LEVEL_INT
interrupt signal to one of the CPU interrupts. (RAV)

Espressif Systems

58

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
4. Interrupt Matrix

 

Register 4.20: INTERRUPT_PRO_TG1_TO_LEVEL_INT_MAP_REG (0x004C)

 

 

 

 

 

 

 

RS
<Y
x2
xa’
or
ee
S SS
ss &
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_TG1_TO_LEVEL_INT_MAP This register is used to map TG1_TO_LEVEL_INT in-
terrupt signal to one of the CPU interrupts. (RAM)
Register 4.21: INTERRUPT_PRO_TG1_T1_LEVEL_INT_MAP_REG (0x0050)


[oo 0000000000000 0900000900000 00 9 16 |Reset

 

INTERRUPT_PRO_TG1_T1_LEVEL_INT_MAP This register is used to map TG1_T1_LEVEL_INT in-
terrupt signal to one of the CPU interrupts. (RAM)

Espressif Systems

59

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
4. Interrupt Matrix

 

Register 4.22: INTERRUPT_PRO_TG1_WDT_LEVEL_INT_MAP_REG (0x0054)

 

 

 

 

 

 

 

 

 

Qe’
SV
&
A?
wW
or"
Oz
ss
5) Se
ge gs
Ss QS
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_TG1_WDT_LEVEL_INT_MAP This register is used to map
TG1_WDT_LEVEL_INT interrupt signal to one of the CPU interrupts. (RAV)
Register 4.23: INTERRUPT_PRO_TG1_LACT LEVEL_INT_MAP_REG (0x0058)
g
RG
V7
e
Kor
°
gz?
S S$
sf &
€ s
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_TG1_LACT_LEVEL_INT_MAP This register is used to map
TG1_LACT_LEVEL_INT interrupt signal to one of the CPU interrupts. (RAV)
Espressif Systems 60 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

Register 4.24: INTERRUPT_PRO_GPIO_INTERRUPT_PRO_MAP_REG (0x005C)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

OZ
ss
&
©
Ss
oS
&
o’
x?
g
& ge
& x
« S
31 5,4 o
000000000060 00600606060 0600600000000 06 0 0 16 Reset
INTERRUPT_PRO_GPIO_INTERRUPT_PRO_MAP. This register is used to map
GPIO_INTERRUPT_PRO interrupt signal to one of the CPU interrupts. (RAW)
Register 4.25: INTERRUPT_PRO_GPIO_INTERRUPT_PRO_NMI_MAP_REG (0x0060)
wf
wv
&
“ &
Ss
ce
S &
s &
s XS
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_GPIO_INTERRUPT_PRO_NMIMAP This register is used to map
GPIO_INTERRUPT_PRO_NM1I interrupt signal to one of the CPU interrupts. (R/V)
Register 4.26: INTERRUPT_PRO_GPIO_INTERRUPT_APP_MAP_REG (0x0064)



[a1 s|a o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_GPIO_INTERRUPT_APP_MAP This register is used to map
(RW)

GPIO_INTERRUPT_APP interrupt signal to one of the CPU interrupts.

61

Espressif Systems
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
4. Interrupt Matrix

 

Register 4.27: INTERRUPT_PRO_GPIO_INTERRUPT_APP_NMI_MAP_REG (0x0068)




 

 

 

 

 

 

 

 

 

 

 

xs
x
£
ge
ce
5 e
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_GPIO_INTERRUPT_APP_NMI_MAP This” register is used to map
GPIO_INTERRUPT_APP_NMI interrupt signal to one of the CPU interrupts. (RAM)
Register 4.28: INTERRUPT_PRO_DEDICATED_GPIO_IN_INTR_MAP_REG (0x006C)
g
e
Qe
Se
S
S
S &
er &
& &
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_DEDICATED_GPIO_IN_INTR_MAP This register is used to map DEDI-
CATED_GPIO_IN_INTR interrupt signal to one of the CPU interrupts. (RAW)
Register 4.29: INTERRUPT_PRO_CPU_INTR_FROM_CPU_0O_MAP_REG (0x0070)
xs
S
sv
&
sy
S
x ge
& &<
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_CPU_INTR_FROM_CPU_O_MAP This register is used to map
CPU_INTR_FROM_CPU_0 interrupt signal to one of the CPU interrupts. (RAW)
Espressif Systems 62 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.30: INTERRUPT_PRO_CPU_INTR_FROM_CPU_1_MAP_REG (0x0074)

 

 

 

 

 

 

 

 

 

 

 

 

w
Noe
&
&
S
S e
x ge
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_CPU_INTR_FROM_CPU_1_MAP This register is used to map
CPU_INTR_FROM_CPU_1 interrupt signal to one of the CPU interrupts. (R/W)
Register 4.31: INTERRUPT_PRO_CPU_INTR_FROM_CPU_2_MAP_REG (0x0078)

foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_CPU_INTR_FROM_CPU_2 MAP This register is used to map
CPU_INTR_FROM_CPU_2 interrupt signal to one of the CPU interrupts. (R/W)
Register 4.32: INTERRUPT_PRO_CPU_INTR_FROM_CPU_3_MAP_REG (0x007C)
&
er
oY
<
of
S ¥
er x?
& &
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_CPU_INTR_FROM_CPU_3 MAP This register is used to map
CPU_INTR_FROM_CPU_3 interrupt signal to one of the CPU interrupts. (R/W)
Espressif Systems 63 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.33: INTERRUPT_PRO_SPI_INTR_1_MAP_REG (0x0080)


 

 

 

 

 

 

 

 

 

 

 

 

 

er
&
o>
e°
x?
S S$
sf _
Ss QS
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_SPI_INTR_1_MAP. This register is used to map SPI_INTR_1 interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.34: INTERRUPT_PRO_SPI_INTR_2 MAP_REG (0x0084)
“
ae
S
$
ro
gz?
S S$
ss g
§ xe
€ RS
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_SPI_LINTR_2_MAP This register is used to map SPI_INTR_2 interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.35: INTERRUPT_PRO_SPI_INTR_3_MAP_REG (0x0088)
e:
er
$
©
gz?
S S$
sf &
LP «
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_SPI_LINTR_3_ MAP This register is used to map SPI_INTR_3 interrupt signal to
one of the CPU interrupts. (RAV)
Espressif Systems 64 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.36: INTERRUPT_PRO_I2S0_INT_MAP_REG (0x008C)


 

 

 

 

 

 

 

 

 

 

 

 

 

€
£
&
S Se
gs S
& S
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_I2S0_INT_MAP This register is used to map |2S0_INT interrupt signal to one of
the CPU interrupts. (RAV)
Register 4.37: INTERRUPT_PRO_I2S1_INT_MAP_REG (0x0090)
€
£
©
x?
S S$
gs S
& <
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_1I2S1_INT_MAP This register is used to map |2S1_INT interrupt signal to one of
the CPU interrupts. (RAV)
Register 4.38: INTERRUPT_PRO_UART_INTR_MAP_REG (0x0094)
gy
<>
>
©
x?
g
aa &
Ss QS
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_UART_INTR_MAP This register is used to map UART_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Espressif Systems 65 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.39: INTERRUPT_PRO_UART1_INTR_MAP_REG (0x0098)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Qa’
Ss
x 4
a
oe”
x?
g
& &
& x
€ s
31 5)4 0
0000 0000000000606 0600000600600 0000 0 16 Reset
INTERRUPT_PRO_UART1_INTR_MAP. This register is used to map UART1_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.40: INTERRUPT_PRO_UART2_INTR_MAP_REG (0x009C)


“
Qa’
s
x L
Ss
°
gz?
g
& &
& &
s Ss
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_UART2_INTR_MAP. This register is used to map UART2_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.41: INTERRUPT_PRO_SDIO_HOST_INTERRUPT_MAP_REG (0x00A0)
31 5)4 0
0000 0000000000606 0600000600600 0000 0 16 Reset
INTERRUPT_PRO_SDIO_HOST_INTERRUPT_MAP This register is used to map
SDIO_HOST_INTERRUPT interrupt signal to one of the CPU interrupts. (RAW)
Espressif Systems 66 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.42: INTERRUPT_PRO_PWM0_INTR_MAP_REG (0x00A4)


 

 

 

 

 

 

 

 

 

 

 

rr
Qa’
s
we’
&
&
S\ Se
ie Ss
& <
NS s
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_PWM0O_INTR_MAP This register is used to map PWMO0_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.43: INTERRUPT_PRO_PWM1_INTR_MAP_REG (0x00A8)

rr
Qa’
Ss
we’
s
&
gz?
g
& ©
& &
NS s
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_PWM1_INTR_MAP This register is used to map PWM1_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.44: INTERRUPT_PRO_PWM2_INTR_MAP_REG (0x00AC)
rr
Qa’
s
Ww’
oe
g
& ©
& SS
€ s
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_PWM2_INTR_MAP This register is used to map PWM2_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Espressif Systems 67 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.45: INTERRUPT_PRO_PWM3_INTR_MAP_REG (0x00B0)

 

 

 

 

 

 

 

 

 

 

 

 

rr
Qa’
s
we”
&
&
S Se
sf &
& <
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_PWM3_INTR_MAP This register is used to map PWMG_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.46: INTERRUPT_PRO_LEDC_INT_MAP_REG (0x00B4)
g
¥
ro
gz?
S S
g® &
& <
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_LEDC_INT_MAP This register is used to map LEDC_INT interrupt signal to one
of the CPU interrupts. (RAV)
Register 4.47: INTERRUPT_PRO_EFUSE_INT_MAP_REG (0x00B8)
&
Qe’
Roe
&
°
gz?
& &
€ &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_EFUSE_INT_MAP This register is used to mao EFUSE_INT interrupt signal to
one of the CPU interrupts. (RAV)
Espressif Systems 68 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.48: INTERRUPT_PRO_CAN_INT_MAP_REG (0x00BC)

 

 

 

 

 

 

 

 

 

 

 

 

Kg}?
s
e
&
gz?
S S
sf &
€ s
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_CAN_INT_MAP This register is used to map CAN_INT interrupt signal to one of
the CPU interrupts. (RAV)
Register 4.49: INTERRUPT_PRO_USB_INTR_MAP_REG (0x00C0)
e:
&
>
S
oe”
x?
g
e &
Ss QS
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_USB_INTR_MAP This register is used to map USB_INTR interrupt signal to one
of the CPU interrupts. (RAV)
Register 4.50: INTERRUPT_PRO_RTC_CORE_INTR_MAP_REG (0x00C4)
w
QO’
s
we
oF
$
&
x?
S S$
Ss &
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_RTC_CORE_INTR_MAP This registeris used to map RTC_CORE_INTR interrupt
signal to one of the CPU interrupts. (RAW)
Espressif Systems 69 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.51: INTERRUPT_PRO_RMT_INTR_MAP_REG (0x00C8)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

rr
gy
«>
s
©
x?
S S$
sf &
LP «
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_RMT_INTR_MAP This register is used to map RMT_INTR interrupt signal to one
of the CPU interrupts. (RAV)
Register 4.52: INTERRUPT_PRO_PCNT_INTR_MAP_REG (0x00CC)
gy
«>
Se
ee"
x?
S S
sf _
Ss QS
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_PCNT_INTR_MAP This register is used to map PCNT_INTR interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.53: INTERRUPT_PRO_I2C_EXT0O_INTR_MAP_REG (0x00D0)

RX
&
$
e
©
x?
S S
sf _
Ss QS
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_I2C EXTO_INTR_MAP This register is used to map l2C_EXTO_INTR interrupt
signal to one of the CPU interrupts. (RAW)
Espressif Systems 10 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.54: INTERRUPT_PRO_I2C_EXT1_INTR_MAP_REG (0x00D4)

 

 

 

 

 

 

 

 

 

 

 

 

x
Ss
§
e
&
S Se
x &
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_I2C_ EXT1_INTR_MAP This register is used to map l2C_EXT1_INTR interrupt
signal to one of the CPU interrupts. (RAW)
Register 4.55: INTERRUPT_PRO_RSA_INTR_MAP_REG (0x00D8)
e:
s
ee
Oo
x?
S S$
sf &
LP «
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_RSA_INTR_MAP. This register is used to map RSA_INTR interrupt signal to one
of the CPU interrupts. (RAV)
Register 4.56: INTERRUPT_PRO_SHA_INTR_MAP_REG (0x00DC)
w
&
wv
oe”
x?
S S$
sf &
LP «
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_SHA_INTR_MAP This register is used to map SHA_INTR interrupt signal to one
of the CPU interrupts. (RAV)
Espressif Systems 7 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.57: INTERRUPT_PRO_AES_INTR_MAP_REG (0x00E0)


 

 

¥
Qa’
3S
f
SS
x?
S &
Ss &
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset

 

INTERRUPT_PRO_AES_INTR_MAP. This register is used to map AES_INTR interrupt signal to one
of the CPU interrupts. (RAV)

Register 4.58: INTERRUPT_PRO_SPI2_DMA_INT_MAP_REG (0x00E4)


 

 

 

 

 

 

 

 

 

 

»
ge
e°
x?
g
& <
& <
NS s
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_SPI2_DMA_INT_MAP. This register is used to map SPI2_DMA_INT interrupt sig-
nal to one of the CPU interrupts. (RAM)
Register 4.59: INTERRUPT_PRO_SPI3_DMA_INT_MAP_REG (0x00E8)
SS
ger
ae
x?
g
& &
& x
€ s
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_SPI3_DMA_INT_MAP. This register is used to map SPIS_DMA_INT interrupt sig-
nal to one of the CPU interrupts. (RAM)
Espressif Systems 12 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.60: INTERRUPT_PRO_WDG_INT_MAP_REG (Ox00EC)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

sv
&
ee
S Se
s &
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_WDG_INT_MAP This register is used to map WDG_INT interrupt signal to one of
the CPU interrupts. (RAV)
Register 4.61: INTERRUPT_PRO_TIMER_INT1_MAP_REG (0x00F0)
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_TIMER_INT1_MAP This register is used to map TIMER_INT1 interrupt signal to

one of the CPU interrupts. (RAV)
Register 4.62: INTERRUPT_PRO_TIMER_INT2_MAP_REG (0x00F4)
rr
Y7
s
we
ee
S Se
sf &
& s
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_TIMER_INT2_MAP This register is used to map TIMER_INT2 interrupt signal to
one of the CPU interrupts. (RAV)
Espressif Systems 13 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.63: INTERRUPT_PRO_TG_TO_EDGE_INT_MAP_REG (0x00F8)

 

 

 

 

 

 

 

 

 

 

€
Qe’
“ey
¥
“~
nor
Or
ss
S Se
ss g
§ e
€ s
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_TG_TO EDGE_INT_MAP This register is used to map TG_TO_EDGE_INT inter-
rupt signal to one of the CPU interrupts. (RAM)
Register 4.64: INTERRUPT_PRO_TG_T1_EDGE_INT_MAP_REG (0x00FC)
€
Qe’
w
Y
aw
Kor
Oz
ss
S Se
s &
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_TG_T1_EDGE_INT_MAP This register is used to map TG_T1_EDGE_INT inter-
rupt signal to one of the CPU interrupts. (RAM)
Espressif Systems 14 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.65: INTERRUPT_PRO_TG_WDT_EDGE_INT_MAP_REG (0x0100)

 

 

 

 

 

 

 

 

 

 

g
RG
“ey
¥
a?
wW
“or
Or
<
ey
& &
& &
© S
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_TG_WDT_EDGE_INT_MAP This register is used to mao TG_WDT_EDGE_INT
interrupt signal to one of the CPU interrupts. (RAV)
Register 4.66: INTERRUPT_PRO_TG_LACT EDGE_INT_MAP_REG (0x0104)
&
So
Ro
OY
Kor
oe”
x?
g
& ge
& x
€ s
31 5)4 0
0000 0000000000606 0600000600600 0000 0 16 Reset
INTERRUPT_PRO_TG_LACT_EDGE_INT_MAP This register is used to map TG_LACT_EDGE_INT
interrupt signal to one of the CPU interrupts. (RAV)
Espressif Systems 15 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.67: INTERRUPT_PRO_TG1_TO_EDGE_INT_MAP_REG (0x0108)

 

 

 

 

 

 

 

 

 

 

€
Qe’
“ey
¥
x“
or"
Oz
ss
S\ Se
e s
Ss QS
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_TG1_TO EDGE_INT_MAP This register is used to map TG1_TO_EDGE_INT in-
terrupt signal to one of the CPU interrupts. (RAM)
Register 4.68: INTERRUPT_PRO_TG1_T1_EDGE_INT_MAP_REG (0x010C)
€
Qe’
we
Y
av
or
Oz
ss
S SY
x &
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_TG1_T1_EDGE_INT_MAP This register is used to map TG1_T1_EDGE_INT in-
terrupt signal to one of the CPU interrupts. (RAM)
Espressif Systems 16 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.69: INTERRUPT_PRO_TG1_WDT_EDGE_INT_MAP_REG (0x0110)

 

 

 

 

 

 

 

 

e
Qe’
“ey
Y
a?
wW
or"
Or
<
S Se
& <
Ss Ss
e RS
[1 | o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_TG1_WDT_EDGE_INT_MAP This register is used to map TG1_WDT_EDGE_INT
interrupt signal to one of the CPU interrupts. (RAV)
Register 4.70: INTERRUPT_PRO_TG1_LACT_EDGE_INT_MAP_REG (0x0114)

e
Qe’
“ey
gy
or
Oz
ss
S SY
x &
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_TG1_LACT_EDGE_INT_MAP This register is used to map
TG1_LACT_EDGE_INT interrupt signal to one of the CPU interrupts. (RAM)
Espressif Systems rad ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.71: INTERRUPT_PRO_CACHE_IA_INT_MAP_REG (0x0118)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Qe’
eo
S
oF
ge
S »
s &
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_CACHE_IA_INT_MAP This register is used to map CACHE_IA_INT interrupt sig-
nal to one of the CPU interrupts. (RAM)
Register 4.72: INTERRUPT_PRO_SYSTIMER_TARGETO_INT_MAP_REG (0x011C)
-
&
<
&
S e
f ee
« s
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_SYSTIMER_TARGETO_INT_MAP This register is used to map SYS-
TIMER_TARGETO_INT interrupt signal to one of the CPU interrupts. (RAM)
Register 4.73: INTERRUPT_PRO_SYSTIMER_TARGET1_INT_MAP_REG (0x0120)
<
£
<
&
S e
g® ee
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_SYSTIMER_TARGET1_INT_MAP This register is used to map SYS-

TIMER_TARGET1_INT interrupt signal to one of the CPU interrupts. (RAM)

18
Submit Documentation Feedback

Espressif Systems

ESP32-S2 TRM (Preliminary V0.4)
4. Interrupt Matrix

 

Register 4.74: INTERRUPT_PRO_SYSTIMER_TARGET2_INT_MAP_REG (0x0124)


 

 

 

 

 

 

 

 

 

 

 

w
<
re
S
S\ go"
rs &
€ &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_SYSTIMER_TARGET2_INT_MAP This register is used to map SYS-
TIMER_TARGET2_INT interrupt signal to one of the CPU interrupts. (RAM)
Register 4.75: INTERRUPT_PRO_ASSIST_DEBUG_INTR_MAP_REG (0x0128)
es:
Qa’
oS
&
Q
Oo
&
er
x?
5 S
ss S&S
€ &
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT _PRO_ ASSIST _DEBUG_INTR_MAP This register is used to map AS-
SIST_DEBUG_INTR interrupt signal to one of the CPU interrupts. (RAV)
Register 4.76: INTERRUPT_PRO_PMS_PRO_IRAMO_ILG_INTR_MAP_REG (0x012C)
&
£
©
&
ee
o
S\ §
s ee
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_PMS_PRO_IRAMO_ILG_INTR_MAP This’ register is used to map
PMS_PRO_IRAMO_ILG_INTR interrupt signal to one of the CPU interrupts. (RAV)
Espressif Systems 19 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.77: INTERRUPT_PRO_PMS_PRO_DRAMO_ILG_INTR_MAP_REG (0x0130)

 

 

 

 

 

 

 

 

 

 

 

 

w
<
yw
<
ee
we"
S <
gf &
& <
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_PMS_PRO_DRAMO_ILG_INTR_MAP This_ register is used to map
PMS_PRO_DRAMO_ILG_INTR interrupt signal to one of the CPU interrupts. (R/V)
Register 4.78: INTERRUPT_PRO_PMS_PRO_DPORT_ILG_INTR_MAP_REG (0x0134)
&
&
Ne
ge
ee
se"
S <
sf &
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_PMS_PRO_DPORT_ILG_INTR_MAP This register is used to map
PMS_PRO_DPORT_ILG_INTR interrupt signal to one of the CPU interrupts. (RAV)
Register 4.79: INTERRUPT_PRO_PMS_PRO_AHB_ILG_INTR_MAP_REG (0x01 38)
g
<
S
>
@
ee
S <
s &
x Ss
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_PMS_PRO_AHB_ILG_INTR_MAP This register is used to map
PMS_PRO_AHB_ILG_INTR interrupt signal to one of the CPU interrupts. (RW)
Espressif Systems 80 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.80: INTERRUPT_PRO_PMS_PRO_CACHE_ILG_INTR_MAP_REG (0x01 3C)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

2
ye"
na
e
co
S <
eo &
Ef &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_PMS_ PRO CACHE ILG_INTR_MAP This register is used to map
PMS_PRO_CACHE_ILG_INTR interrupt signal to one of the CPU interrupts. (RAM)
Register 4.81: INTERRUPT_PRO_PMS_DMA APB _|_ILG_INTR_MAP_REG (0x0140)
e
&
yr"
roa
a
S Se
eo f
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_PMS_DMA_APB_|_ILG_INTR_MAP This_ register is used to map
PMS_DMA_APB_|_ILG_INTR interrupt signal to one of the CPU interrupts. (R/V)
Register 4.82: INTERRUPT_PRO_PMS_DMA_RX_|_ILG_INTR_MAP_REG (0x0144)
&
<
S
ee
co
S ee
ra &
e €
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_PMS_DMA_RX_LILG_INTR_MAP This register is used to map
PMS_DMA_RX_|_ILG_INTR interrupt signal to one of the CPU interrupts. (R/V)
Espressif Systems 81 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.83: INTERRUPT_PRO_PMS_DMA_TX_I_ILG_INTR_MAP_REG (0x01 48)

 

 

 

 

 

 

 

 

 

 

 

 

©
wy”
a
x
So
S af
& &
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_PMS_DMA_TX_LILG_INTR_MAP This" register is used to map
PMS_DMA_TX_|_ILG_INTR interrupt signal to one of the CPU interrupts. (RAV)
Register 4.84: INTERRUPT_PRO_SPI_MEM REJECT_INTR_MAP_REG (0x014C)
w
gv
s
OY
¥
S
s
&
Ov
o’
x?
5 NS
sf ss
P «
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_SPI_MEM_REJECT_INTR_MAP This register is used to map
SPILMEM_REJECT_INTR interrupt signal to one of the CPU interrupts. (RAM)
Register 4.85: INTERRUPT_PRO_DMA_COPY_INTR_MAP_REG (0x0150)


se &
oS A
€ RS
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_DMA_COPY_INTR_MAP. This register is used to map DMA_COPY_INTR inter-
rupt signal to one of the CPU interrupts. (RAM)
Espressif Systems 82 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.86: INTERRUPT_PRO_SPI4_DMA_INT_MAP_REG (0x0154)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

SS
ge
ae
x?
S S$
sf _
Ss QS
e &
31 5)4 0
00000000000 0000000000000 00 0 16 Reset
INTERRUPT_PRO_SPI4_DMA_INT_MAP. This register is used to map SPI4_ DMA_INT interrupt sig-
nal to one of the CPU interrupts. (RAM)
Register 4.87: INTERRUPT_PRO_SPI_INTR_4 MAP_REG (0x0158)
€
a
& SL
os
o’
x?
5 NS
sf _
Ss QS
& &
[a1 s|a o|
foo 0000000000000000000000 00 9 16 |Reset
INTERRUPT_PRO_SPI_LINTR_4 MAP This register is used to map SPI_INTR_4 interrupt signal to
one of the CPU interrupts. (RAV)
Register 4.88: INTERRUPT_PRO_DCACHE PRELOAD_INT_MAP_REG (0x015C)
8
o
&
se
xs
ge
oe’
x?
S S$
s _
oS QS
e &
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_DCACHE_PRELOAD_INT_MAP This register is used to map
DCACHE_PRELOAD_INT interrupt signal to one of the CPU interrupts. (RAV)
Espressif Systems 83 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.89: INTERRUPT_PRO_ICACHE_PRELOAD_INT_MAP_REG (0x0160)

 

 

16 |Reset

 

INTERRUPT_PRO_ICACHE_PRELOAD_INT_MAP This

register

is used

ICACHE_PRELOAD_INT interrupt signal to one of the CPU interrupts. (RAV)

Register 4.90: INTERRUPT_PRO_APB_ADC_INT_MAP_REG (0x0164)

 

 

16 |Reset

 

INTERRUPT_PRO_APB_ADC_INT_MAP This register is used to map APB_ADC_INT interrupt signal
to one of the CPU interrupts. (R/V)

Espressif Systems

84

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
4. Interrupt Matrix

 

Register 4.91: INTERRUPT_PRO_CRYPTO_DMA_INT_MAP_REG (0x0168)

 

 

 

 

 

 

 

 

rr
sv
of
i
&
Ss
&
gz?
S S
sé g
§ xe
€ RS
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_CRYPTO_DMA_INT_MAP This register is used to map CRYPTO_DMA_INT in-
terrupt signal to one of the CPU interrupts. (RAM)
Register 4.92: INTERRUPT _PRO_CPU_PERIERROR_INT_MAP_REG (0x016C)
€
O
&
gy
“
7
$
&
x?
S S$
s _
QS
e &
[a1 s[ o|
foo 0000000000000 0000000000 0 0 16 |Reset
INTERRUPT_PRO_CPU_PERI_ERROR_INT_MAP. This register is used to map
CPU_PERI_ERROR_INT interrupt signal to one of the CPU interrupts. (R/V)
Espressif Systems 85 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.93: INTERRUPT_PRO_APB_PERI_ERROR_INT_MAP_REG (0x0170)


 

 

€
O
&
Qe
“
&
eS
ae
x?
S S$
sf &
€ &
[1 | o|
[oo 0000000000000 0900000900000 00 9 16 |Reset
INTERRUPT_PRO_APB_PERILERROR_INT_MAP This register is used to map
APB_PERI_ERROF_INT interrupt signal to one of the CPU interrupts. (RAV)
Register 4.94: INTERRUPT_PRO_DCACHE SYNC_INT_MAP_REG (0x0174)
&
sv
&
x’
rs)
oF
Xs
gz?
g
& ©
S S
& &
[1 sa o|
[oo 0000000000090 00000900000000 0 16 |Reset
INTERRUPT_PRO_DCACHE SYNC_INT_MAP This register is used to map DCACHE_SYNC_INT
interrupt signal to one of the CPU interrupts. (RAV)
Espressif Systems 86 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.95: INTERRUPT_PRO_ICACHE_SYNC_INT_MAP_REG (0x0178)

 

 

 

[oo 0000000000090 00000900000000 0 16 |Reset

 

INTERRUPT_PRO_ICACHE SYNC_INT_MAP This register is used to map ICACHE_SYNC_INT in-
terrupt signal to one of the CPU interrupts. (RAM)

Register 4.96: INTERRUPT_CLOCK_GATE_REG (0x01 88)

 

 

0 | 1 |Reset

 

INTERRUPT_CLK_EN This bit is used to enable or disable the clock of interrupt matrix. 1: enable
the clock; 0: disable the clock. (RAV)

INTERRUPT_PRO_NMIMASK_HW This bit is used to disable all NMI interrupt signals to CPU. (RAM)

Register 4.97: INTERRUPT_PRO_INTR_STATUS_REG_0 REG (0x017C)

 

[ “|

| 0x000000 | Reset

 

 

INTERRUPT_PRO_INTR_STATUS_0 This register stores the status of the first 32 input interrupt
sources. (RO)

Espressif Systems 87 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
4. Interrupt Matrix

 

Register 4.98: INTERRUPT_PRO_INTR_STATUS_REG_1_REG (0x0180)
 

[ 7]

| 0x000000 | Reset

 

 

INTERRUPT_PRO_INTR_STATUS 1. This register stores the status of the second 82 input interrupt
sources. (RO)

Register 4.99: INTERRUPT_PRO_INTR_STATUS_REG_2_ REG (0x0184)

 

 

 

&
eS
of
s
&
ff’
©
S
Ss
[1 0]
| 0x000000 | Reset

 

INTERRUPT_PRO_INTR_STATUS 2 This register stores the status of the last 31 input interrupt
sources. (RO)

Register 4.100: INTERRUPT_REG_DATE_REG (0x0FFC)

 

 

 

 

 

 

&
& aL
Pa
ws
<
SF
Ss
S Sv
sf Ss
& «
e ©
31 28 | 27 o
0 0 0 0 0x1904180 Reset
INTERRUPT_DATE Version control register. (R/V)
Espressif Systems 88 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

5. IOMUX and GPIO Matrix

5.1 Overview

The ESP82-S2 chip features 43 physical GPIO pads. Each pad can be used as a general-purpose I/O, or be
connected to an internal peripheral signal. The IO MUX, RTC IO MUX and the GPIO matrix are responsible for
routing signals from the peripherals to GPIO pads. Together these modules provide highly configurable I/O.

Note that the GPIO pads are numbered from 0 ~ 21 and 26 ~ 46, while GPIO46 is input-only.

This chapter describes the selection and connection of the internal signals for the 43 digital pads and control
signals: FUN_SEL, IE, OE, WPU, WPD, etc. These internal signals include:

* 116 digital peripheral input signals, control signals: SIG_IN_SEL, SIG_OUT_SEL, IE, OE, etc.
* 182 digital peripheral output signals, control signals: SIG_IN_SEL, SIG_OUT_SEL, IE, OE, etc.
* fast peripheral input and output signals, control signals: IE, OE, etc.

* 22 RTC GPIO signals

    

     
   
  

Constant 0 Input
fg Constant 2 Input
GPIOO_in
GPIOL In

jt SPIO} In _

« —_SPIO2 in

wan
a3

{O(FUNC)|
Peripheral Signal ¥

  
    
   
  
   
  
  
     

 

Pad X supplied
by VDDSP3_CPU

l¢@Pt0) sig_in_funcly]]

@

GPIO_SiGy_IN_SEL

 

 

«nNHO

 

E
|_| sPto |_| Gro ® 2
7) SYNC [4 Fitter we

 

 

 

.
x [sq__SPIOX_In
| oe

 

 

 

 

 

GPIO_FUNCy_IN_INV_SEL GPIOS3 in

53 m) but wo

z

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

116 peripheral inputs ‘GPIOQ_FUNCy_IN_SEL
Es
GPIO_FUNCx_OUT_SEL
182 peripheral outputs pw
signalo_out ——] 0 GPIO_FUNCX GUT. INT SEL Ne oeE
signall_out ——t} 1 weeee ee ef eee -
signal2_out ——] 2 i
Peripheral Signal Y" aa 0 O(FUNC) :
cd 2 i
Peripheral Signal ¥ eT 610) |
1 ! Pad X supplied by
signal251_out——) 251 2(FUNC) : yoD3P3-RTC.10
GPIOx_out i
'
GPIO_OUT_DATA_bit_ xp] 256 ! @| £ Z
i 1 + he wu
!
i 0 Bs buf PD
z
i
i
'

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

CD Not every peripheral Input has the MUX, only peripheral Input signals (¥: 0~3, 7~11, 14~15, 17~18, 108~117, 127~130, 167~171) have thls MUX.
‘The other peripheral inputs only get the input from GPIO Matrix.

@There are 43 GPIO pads(Xx: 0~21, 26~46)}, therefore only 43 Inputs from GPIO SYNC to GPIO Matrix.
(@DThere are few control signals, IE, OE, WPU, WPD, connected to Pad supplied by VDD_3P3_CPU.

@ only few peripheral outputs have this path, please refer to 10 MUX Pad Table In this chapter.

@® There are only 42 outputs (GPIO pad X: 0~21, 26~45) from GPIO matrix to 1O MUX.

@ There are few control signals, IE, OE, WPU, WPD, connected to Pad supplied by VDD3P3_RTC_IO.

Figure 5-1. 1O MUX, RTC 1O MUX and GPIO Matrix Overview

Figure 5-1 shows the overview of IO MUX, RTC lO MUX and GPIO matrix.

Espressif Systems 89 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

1. IO MUX provides one configuration register |O_MUX_n_REG for each GPIO pad. The pad can be
configured to

* perform GPIO function routed by GPIO matrix;
* or perform direct connection bypassing GPIO matrix.

Some high-speed digital signals (SPI, JTAG, UART) can bypass GPIO matrix for better high-frequency
digital performance. |n this case, |O MUX is used to connect these pads directly to the peripheral.

See Section 5.11 for the IO MUX functions for each I/O pad.
2. GPIO matrix is a full-switching matrix between the peripheral input/output signals and the pads.

® For input to the chip: each of the 116 internal peripheral inputs can select any GPIO pad as their input
SOUICce.

* For output from the chip: each GPIO pad can select any of the 182 peripheral output signals for its
output.

See Section 5.10 for the list of peripheral signals via GPIO matrix.

3. RTC IO MUX is used to connect GPIO pads to their low-power and analog functions. Only a subset of
GPIO pads have these optional RTC functions.

See Section 5.12 for the list of RTC 1O MUX functions.

5.2 Peripheral Input via GPIO Matrix

5.2.1 Overview

To receive a peripheral input signal via GPIO matrix, the matrix is configured to source the peripheral input signal
from one of the 43 GPIOs (0 ~ 21, 26 ~ 46), see Table 22. Meanwhile, register corresponding to the peripheral
should be set to receive input signal via GPIO matrix.

5.2.2 Synchronization

When signals are directed using the GPIO matrix, the signal will be synchronized to the APB bus clock by the
GPIO SYNC hardware. This synchronization applies to all GPIO matrix signals but does not apply when using the
IO MUX, see Figure 5-1.

Figure 5-2 shows the functionality of GPIO SYNC. In the figure, negative sync and positive sync mean GPIO input
is synchronized on APB clock falling edge and on APB clock rising edge, respectively.

Espressif Systems 90 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

 

GPIO input sync

gpio_pinX_sync1_bypass[0]

   

gpio_pinX_syncl_bypass[1]

  
 
 
 
 
   

gpio input
gpio_pinX_sync2_bypass[0]

gpio_pinX_sync2_bypass[1]

 

postive
syne

  

 

First-stage synchronizer

 

Second-stage synchronizer

 

 

 

Figure 5-2. GPIO Input Synchronized on Clock Rising Edge or on Falling Edge

5.2.3 Functional Description
To read GPIO pad * into peripheral signal Y, follow the steps below:

1. Configure register GPIO_FUNCy_IN_SEL_CFG_REG corresponding to peripheral signal Y in GPIO matrix:
* Set GPIO_SIGy_IN_SEL to enable peripheral signal input via GPIO matrix.
* Set GPIO_FUNCy_IN_SEL to the value corresponding to GPIO pad x.

Note that some peripheral signals have no valid GPIO_SIlGy_IN_SEL bit, namely, there is no MUX module
in Figure 5-1 for these signals (see note 1 below Figure 5-1). These peripherals can only receive input
signals via GPIO matrix.

2. Enable the filter for pad input signals by setting the register |O_MUX_FILTER_EN. Only the signals with a
valid width of more than two clock cycles can be sampled, see Figure 5-3.

 

1 clock

gpioin > 2 clock a ll
filter_out

Figure 5-3. Filter Timing Diagram of GPIO Input Signals

 

 

 

 

 

8. Synchronize GPIO input. To do so, please set GPIO_PIN«_REG corresponding to GPIO pad % as follows:

* Set GPIO_PINx_SYNC1_BYPASS to enable input signal synchronized on rising edge or on falling edge
in the first clock, see Figure 5-2.

* Set GPIO_PINx_SYNC2_BYPASS to enable input signal synchronized on rising edge or on falling edge
in the second clock, see Figure 5-2.

4. Configure |O MUX register to enable pad input. For this end, please set |O_MUX_x_REG corresponding to
GPIO pad X as follows:

* Set IO_MUX_FUN_IE to enable input.

Espressif Systems 91 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

® Set or clear IO_MUX_FUN_WPU and IO_MUX_FUN_WPD, as desired, to enable or disable pull-up
and pull-down resistors.

For example, to connect RMT channel 0 input signal (rmt_sig_inO, signal index 83) to GPIO40, please follow the
steps below. Note that GPIO40 is also named as MTDO pin.

1. Set GPIO_SIG83_IN_SEL in register GPIO_FUNC83_IN_SEL_CFG_REG to enable peripheral signal input
via GPIO matrix.

2. Set GPIO_FUNC83_IN_SEL in register GPIO_FUNC83_IN_SEL_CFG_REG to 40.
3. Set |O_MUX_FUN_IE in register IO_MUX_GPIO40_REG to enable pad input.
Note:
* One input pad can be connected to multiple peripheral input signals.
® The input signal can be inverted by configuring GPIO_FUNCy_IN_INV_SEL.

* It is possible to have a peripheral read a constantly low or constantly high input value without connecting
this input to a pad. This can be cone by selecting a special GPIO_FUNCy_IN_SEL input, instead of a GPIO
number:

— When GPIO_FUNCy_IN_SEL is OxSC, input signal X is always 0.
— When GPIO_FUNCy_IN_SEL is 0x88, input signal X is always 1.

5.2.4 Simple GPIO Input

GPIO_IN_REG/GPIO_IN1_REG holds the input values of each GPIO pad. The input value of any GPIO pad can
be read at any time without configuring GPIO matrix for a particular peripheral signal. However, it is necessary to
enable the input in IO MUX by setting IO_MUX_FUN_IE bit in register IO_MUX_n_REG corresponding to pad x, as
mentioned in Section 5.2.2.

5.3 Peripheral Output via GPIO Matrix

5.3.1 Overview
To output a signal from a peripheral via GPIO matrix, the matrix is configured to route peripheral output signals (O
~ 11, 14~ 18, and etc.) to one of the 42 GPlOs (0 ~ 21, 26 ~ 45). See Table 22.

The output signal is routed from the peripheral into GPIO matrix and then into |O MUX. IO MUX must be
configured to set the chosen pad to GPIO function. This causes the output GPIO signal to be connected to the
pad.

 

Note:
There is a range of peripheral output signals (223 ~ 227) which are not connected to any peripheral. These can be used

 

 

to input a signal from one GPIO pad and output directly to another GPIO pad.

 

5.3.2 Functional Description
Some of the 182 output signals can be set to go through GPIO matrix into |O MUX and then to a pad. Figure 5-1
illustrates the configuration.

To output peripheral signal Y to a particular GPIO pad , follow these steps:

Espressif Systems 92 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

1. Configure register GPIO_FUNCx_OUT_SEL_CFG_REG and GPIO_ENABLE_REG|x] corresponding to GPIO
pad x in GPIO matrix. Recommended operation: use corresponding W1TS (write 1 to set} and W1TC (write
1 to clear) registers to set or clear GPIO_ENABLE_REG.

® Set the GPIO_FUNCx_OUT_SEL field in register GRPIO_FUNCx_OUT_SEL_CFG_REG to the index of
the desired peripheral output signal Y.

® If the signal should always be enabled as an output, set the GPIO_FUNCx_OEN_SEL bit in register
GPIO_FUNCx_OUT_SEL_CFG_REG and the bit in register GPIO_ENABLE_W1TS_REG or in register
GPIO_ENABLE1_W1TS_REG, corresponding to GPIO pad x. To have the output enable signal
decided by internal logic (see the column ”Output enable of output signals” in Table 22), clear
GPIO_FUNCx_OEN_SEL bit instead.

* Clear the corresponding bit in register GPIO_LENABLE_W1TC_REG or in register
GPIO_ENABLE1_W1TC_REG to disable the output from the GPIO pad.

2. For an open drain output, set the GPIO_PINx_PAD_DRIVER bit in register GPIO_PINx_REG corresponding
to GPIO pad x.

3. Configure |O MUX register to enable output via GPIO matrix. Set the |O_MUX_x_REG corresponding to
GPIO pad X as follows:

® Set the field IO_MUX_MCU_SEL to IO_MUX function corresponding to GPIO pad *. This is Function
1, numeric value 1, for all pins.

® Set the IO _MUX_FUN_DRYV field to the desired value for output strength (0 ~ 3). The higher the driver
strength, the more current can be sourced/sunk from the pin.

- 0:°.5mA

-— 1:°10mA

— 2: 20 mA (Default value)
- 3: 40 mA

* If using open drain mode, set/clear the |O_MUX_FUN_WPU and IO_MUX_FUN_WPD bits to
enable/disable the internal pull-up/down resistors.

Note:
° The output signal from a single peripheral can be sent to multiple pads simultaneously.
* GPIO46 can not be used as an output.

* The output signal can be inverted by setting GPIO_FUNCn_OUT_INV_SEL bit.

5.3.3 Simple GPIO Output

GPIO matrix can also be used for simple GPIO output. This can be done as below:
* Set GPIO matrix GPIO_FUNCn_OUT_SEL with a special peripheral index 256 (0x100);

® Set the corresponding bit in GPIO_OUT_REG[81:0] or GPIO_OUT1_REG[21:0] register to the desired GPIO
output value.

Note:

Espressif Systems 93 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

® GPIO_OUT_REG[0] ~ GPIO_OUT_REG[31] correspond to GPIOO ~ GPIO381, and GPIO_OUT1_REG[25:22]
are invalid.

¢ GPIO_OUT1_REG[0] ~ GPIO_OUT1_REG/13] correspond to GPIOS2 ~ GPIO45, and
GPIO_OUT1_REG[21:14] are invalid.

* Recommended operation: use corresponding W1TS and W1TC registers, such as
GPIO_OUT_W1TS/GPIO_OUT_W1TC to set or clear the registers GPIO_OUT_REG/GPIO_OUT1_REG.

5.3.4 Sigma Delta Modulated Output
5.3.4.1. Functional Description

ESP32-S2 provides a second-order sigma delta modulation module and eight independent modulation channels.
The channels are capable to output 1-bit signals (output index: 100 ~ 107) with sigma delta modulation, and by
default output is enabled for these channels. This module can also output PDM (pulse density modulation) signal
with configurable duty cycle. The transfer function is:

H(z) =X@z7 + E@(t-z7-1"
E(z) is quantization error and X{(z) is the input.
Sigma Delta modulator supports scaling down of APB_CLK by divider 1 ~ 256:
* Set GPIOSD_FUNCTION_CLK_EN to enable the modulator clock.
* Configure register GPIOSD_SDn_PRESCALE (7 is 0 ~ 7 for eight channels).
After scaling, the clock cycle is equal to one pulse output cycle from the modulator.

GPIOSD_SDv_IN is a signed number with a range of [-128, 127] and is used to control the duty cycle + of PDM
output signal.

* GPIOSD_SDn_IN = -128, the duty cycle of the output signal is 0%.

* GPIOSD_SDn_IN = 0, the duty cycle of the output signal is near 50%.

* GPIOSD_SDn_IN = 127, the duty cycle of the output signal is close to 100%.
The formula for calculating PDM signal duty cycle is shown as below:

GPIOSD_SDn_IN + 128

Dut le=
uty Cycle a6

 

Note:
For PDM signals, duty cycle refers to the percentage of high level cycles to the whole statistical period (several pulse

 

 

cycles, for example 256 pulse cycles).

 

5.3.4.2. SDM Configuration
The configuration of SDM is shown below:
* Route one of SDM outputs to a pad via GPIO matrix, see Section 5.3.2.
* Enable the modulator clock by setting the register GPIOSD_FUNCTION_CLK_EN.

Espressif Systems 94 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

* Configure the divider value by setting the register GPIOSD_SDn_PRESCALE.

* Configure the duty cycle of SDM output signal by setting the register GPIOSD_SDn_IN.

5.4 Dedicated GPIO

5.4.1. Overview

The dedicated GPIO module, consisting of eight input/output channels, is specially designed for CPU interaction
with GPIO matrix and IO MUX. Peripheral input/output signals for input/output channels both are indexed from
235 to 242. By default, the output is enabled for output channels.

 

 

Dedicated GPIO
gpio_out_cpu[7:0]
gpio_out_drt

pio_out_msk
gpio_out_idv

    

gpio_out_status

   
 

gpio_out
8

 

gpio_out from CPU

 

\ Ff

 

- GPIO Matrix
ePu gpio_in_dly[15:0] and lO MUX

 

in_id

 

 

gpio_in to CPU gpio_in_status

}

Intr Gen

 

 

in_2d Input gpio_in
Delay 8

 

 

 

 

in_3d

 

Intr

 

ms

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 5-4. Dedicated GPIO Diagram

Figure 5-4 shows the structure of dedicated GPIO module. Users can enable the clock of this module by setting
the bit SYSTEM_CLK_EN_DEDICATED_GPIO in register SYSTEM_CPU_PERI_CLK_EN_REG, and reset this
module by setting the bit SYSTEM_RST_EN_DEDICATED_GPIO in register SYSTEM_CPU_PERI_RST_EN_ REG
first, and then clearing this bit. For more information, please refer to Table 33 Peripheral Clock Gating and Reset
Bits in Chapter 6 System Registers.

5.4.2 Features
Dedicated GPIO module has the following features:

® Eight output and eight inout channels
* Each channel accessible with registers or directly by CPU instructions
* Configurable delay on input channels

® Interrupts on input channels

Espressif Systems 95 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

5.4.3 Functional Description
Dedicated GPIOs may be accessed using registers or directly by calling specific CPU instructions.

When accessing output channels, select between registers and CPU by configuring
DEDIC_GPIO_OUT_CPU_REG:

* DEDIC_GPIO_OUT_CPU_SEL» = 0, drive GPIO output via registers.

* DEDIC_GPIO_OUT_CPU_SEL” = 1, drive GPIO output via CPU instructions.
The dedicated GPIO module also provides two ways to read input channels:

* Query GPIO input value via registers.

* Read GPIO input value via CPU instructions.

5.4.3.1 Accessing GPIO via Registers

Users can control GPIO output via registers in the following ways:
e Write GPIO output value directly by configuring the register DEDIC_GPIO_OUT_DRT_REG.
* Write GPIO output value via masked access by configuring the register DEDIC_GPIO_OUT_MSK_REG.
° Write GPIO output value via individual bits by configuring the register DEDIC_GPIO_OUT_IDV_REG.

User can read the register DEDIC_GPIO_OUT_SCAN_REG to check GPIO status, i.e. gpio_out_status in Figure
5-4, via software.

Users can get a dedicated GPIO input value by reading the register DEDIC_GPIO_IN_SCAN_REG, i.e. the
gpio_in_status in Figure 5-4, via software.

The dedicated GPIO module supports for a delay of 1/2/3 clock cycle(s) for inout signals, or with no delay, which
can be controlled by configuring the register DEDIC_GPIO_IN_DLY_REG for each individual channel. GPIO input
status is indicated by interrupts. Users can configure the register DEDIC_GPIO_INTR_RCGN_REG to set trigger
modes:

© 0/1: no interrupt
© 2: low level trigger

® 3: high level trigger

4: falling edge trigger
® 5: rising edge trigger

° 6/7: edges trigger

5.4.3.2 Accessing GPIO with CPU

CPU can also read/write a dedicated GPIO via instructions.

® Set bits in output channel.
Assembly syntax: SET_BIT_GPIO_OUT mask
Function: write 1 to set the corresponding bits in user register GPIO_OUT, i.e. the gpio_out in Figure 5-4.
The “mask” is 8 bits wide. The bits in GPIO_OUT, corresponding to the bits in “mask” with the value of 1,
will be set to 1, while the other bits in GPIO_OUT remain unaffected.

Espressif Systems 96 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

* Clear bits in outout channel.
Assembly syntax: CLR_BIT_GPIO_OUT mask
Function: write 1 to clear the corresponding bits in user register GPIO_OUT. The “mask” is 8 bits wide. The
bits in GPIO_OUT, corresponding to the bits in “mask” with the value of 1, will be cleared, while the other
bits in GPIO_OUT remain unaffected.

Set or clear bits in output channel with masked access

Assembly syntax: WR_MASK_GPIO_OUT value, mask

Function: write value to user register GPIO_OUT via masked access. The “value” is 8 bits wide, which
represents the value to write. The “mask” is 8 bits wide, which represents the bits in GPIO_OUT to be
manipulated. For example, mask 0x03 (0000 0011) indicates that the write value is only valid for
GPIO_OUT[O] and GPIO_OUT[1]. Only the bits in GPIO_OUT, corresponding to the bits with the value of 1
in the “mask”, are updated, that is, updated to the value stored in “value”.

° Write “art” register to the output channel.
Assembly syntax: WUR.GPIO_OUT art
Function: write the value of the address register “art” to the user register GPIO_OUT. Register “art” is 32
bits wide, and only low 8 bits are valid when using this instruction.

* Read the output channel to “arr” register.
Assembly syntax: RUR.GPIO_OUT arr
Function: read the value of the user register GPIO_OUT to the address register “arr”. Register “arr” is 32
bits wide, and only low 8 bits are valid when using this instruction.

Read the input channel to “I” register.
Assembly syntax: GET_GPIO_IN |
Function: read the value of the user register GPIO_IN, i.e. the gpio_in in Figure 5-4, to the address register

“py “ye

Register “l” is 32 bits wide, the high 24 bits of which are O, and low 8 bits of which corresponds to the

value of the user register GPIO_IN.

5.5 Direct I/O via |O MUX

5.5.1 Overview
Some high-speed signals (SPI and JTAG) can bypass GPIO matrix for better high-frequency digital performance.
In this case, |O MUX is used to connect these pads directly to the peripheral.

This option is less flexible than routing signals via GPIO matrix, as the IO MUX register for each GPIO pad can
only select from a limited number of functions, but high-frequency digital performance can be improved.

5.5.2 Functional Description
Two registers must be configured in order to bypass GPIO matrix for peripheral input signals:

1. IO_MUX_MCU_SEL for the GPIO pad must be set to the required pad function. For the list of pad
functions, please refer to Section 5.11.

2. Set GPIO_SIGn_IN_SEL to low level to route the input directly to the peripheral.

To bypass GPIO matrix for peripheral output signals, |O_MUX_MCU_SEL for the GPIO pad must be set to the
required pad function. For the list of pad functions, please refer to Section 5.11.

Note:

Espressif Systems 97 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

For peripheral I/O signals, not all signals can be connected to peripheral via IO MUX. Some specific input signals
and some specific output signals can only be connected to peripheral via GPIO matrix.

5.6 RTC 1O MUX for Low Power and Analog I/O

5.6.1 Overview

22 GPIO pads have low power capabilities (RTC domain) and analog functions which are handled by the RTC
subsystem of ESP32-S2. |O MUX and GPIO matrix are not used for these functions, rather, RTC IO MUX is used
to redirect input/output signals to the RTC subsystem.

When configured as RTC GP|Os, the output pads can still retain the output level value when the chip is in
Deep-sleep mode, and the input pads can wake up the chip from Deep-sleep.

Section 5.12 lists the RTC_MUX pins and their functions.

5.6.2 Functional Description

Each pad with analog and RTC functions is controlled by RTCIO_TOUCH_PADn_MUX_SEL bit in register
RTCIO_TOUCH_PADn_REG. By default all bits in these registers are set to 0, routing all input/output signals via
|O MUX.

lf RTCIO_TOUCH_PADn_MUX_SEL is set to 1, then input/output signals to and from that pad is routed to the
RTC subsystem. In this mode, RTCIO_TOUCH_PADn_REG is used for digital inout/output and the analog
features of the pad are also available.

Please refer to Section 5.12 for the list of RTC pin functions and the mapping table of GPIO pads to their analog
functions. Note that RTCIO_TOUCH_PADn_REG applies the RTC GPIO pin numbering, not the GPIO pad
numbering.

5.7 Pin Functions in Light-sleep

Pins may provide different functions when ESP82-S2 is in Light-sleep mode. If |O_MUX_SLP_SEL in register
|O_MUX_n_REG for a GPIO pad is set to 1, a different set of bits will be used to control the pad when the chip is
in Light-sleep mode.

Table 21: Pin Function Register for |O MUX Light-sleep Mode

 

Normal Execution Light-sleep Mode

lO MUX Function

OR IO_MUX_SLP_SEL = 0

AND |OQ_MUX_SLP_SEL = 1

 

Output Drive Strength

|O_MUX_FUN_DRV

|O_MUX_FUN_DRV

 

Pullup Resistor

|O_MUX_FUN_WPU

|O_MUX_MCU_WPU

 

Pulldown Resistor

|O_MUX_FUN_WPD

IO_MUX_MCU_WPD

 

 

Output Enable

 

(From GPIO Matrix _OEN fielc)+

 

IO_MUX_MCU_OE

 

lf 1O_MUX_SLP_SEL is set to 0, pin functions remain the same in both normal execution and Light-sleep

mode.

 

Note:

 

Please refer to Section 5.3.2 for how to enable output in normal execution (when IO_MUX_SLP_SEL = 0).

 

Espressif Systems

98

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 

 
5. 1O MUX and GPIO Matrix

 

5.8 Pad Hold Feature
Each IO pad (including the RTC pads) has an individual hold function controlled by a RTC register. When the pad

is set to hold, the state is latched at that moment and will not change no matter how the internal signals change
or how the |O MUX/GPIO configuration is modified. Users can use the hold function for the pads to retain the
pad state through a core reset and system reset triggered by watchdog time-out or Deep-sleep events.

 

 

Note:

e For digital pads, to maintain pad input/output status in Deep-sleep mode, users can set RTC_CNTL_DG_PAD_
FORCE_UNHOLD to 0 before powering down. For RTC pads, the input and output values are controlled by the
corresponding bits of register RTC_CNTL_PAD_HOLD_REG, and users can set it to 1 to hold the value or set it to
0 to unhold the value.

¢ For digital pads, to disable the hold function after the chip is woken up, users can set RTC_CNTL_DG_PAD_FORCE_
UNHOLD to 1. To maintain the hold function of the pad, users can change the corresponding bit in register

RTC_CNTL_PAD_HOLD_REG to 1.

 

 

5.9

I/O Pad Power Supplies

For more information on the power supply for IO pads, please refer to Pin Definition in ESP32-S2

Datasheet.

5.9.1

Each ESP82-S2 digital pin is connected to one of the four different power domains.

Power Supply Management

VDDS8P3_RTC_IO: the input power supply for both RTC and CPU

VDDS8P83_CPU: the input power supply for CPU

VDDS8P3_RTC: the input power supply for RTC analog part

VDD_SPI: configurable power supply

VDD_SPI can be configured to use an internal LDO. The LDO input is VDDGP3_RTC_IO and the output is 1.8 V. If
the LDO is not enabled, VDD_SPI is connected directly to the same power supply as VDDSP3_RTC_IO.

The VDD_SPI configuration is determined by the value of strapping pin GPIO45, or can be overriden by eFuse
and/or register settings. See ESP32-S2 Datasheet sections Power Scheme and Strapping Pins for more

details.

5.10 Peripheral Signal List

Table 22 shows the peripheral input/output signals via GPIO matrix.

Table 22: GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

; Default Same input
Signal . . . . Output enable of output
Input signals value if signal from | Output signals ;
No. } signals
unassigned * | 1O MUX core
0 SPIQ_in 0 yes SPIQ_out SPIQ_oe
1 SPID_in 0 yes SPID_out SPID_oe
2 SPIHD_in 0 yes SPIHD_out SPIHD_oe
3 SPIWP_in 0 yes SPIWP_out SPIWP_oe
Espressif Systems 99 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

; Default Same input
Signal . . . . Output enable of output
No, Input signals value if signal from | Output signals signals
unassigned * | 1O MUX core

4 - - - SPICLK_out_mux SPICLK_oe
5 - - - SPICSO_out SPICSO_oe
6 - - - SPICS1_out SPICS1_oe
a SPID4_in 0 yes SPID4_out SPID4_oe
8 SPID5_in 0 yes SPID5_out SPID5_oe
9 SPID6_in 0 yes SPID6_out SPID6_oe
10 SPID7_in 0 yes SPID7_out SPID7_oe
11 SPIDQS_in 0 yes SPIDQS_out SPIDQS_oe
14 UORXD_in 0 yes UOTXD_out 1d

15 UOCTS_in 0 yes UORTS_out 1d

16 UODSR_in 0 no UODTR_out 1d

V7 U1RXD_in 0 yes U1TXD_out 1d

18 U1CTS _in 0 yes U1RTS_out 1d

21 U1DSR_in 0 no U1DTR_out 1d

23 12800_BCkK_in 0 no 12800_BCK_out 1d

25 I2800_WS_in 0 no I2800_WS_out 1d

27 2801 BCK_in 0 no l280|_BCK_out 1d

28 I2S0|WS_in 0 no 2801 WS_out 1d

29 I2CEXTO_SCL_in 4 no l2CEXTO_SCL_out I2CEXTO_SCL_oe
380 I2CEXTO_SDA in 4 no l2CEXTO_SDA_out I2CEXTO_SDA_oe
39 pcnt_sig_chO_inO 0 no gpio_wlan_prio 1d

40 pcnt_sig_ch1_inO 0 no gpio_wlan_active 1d

A pent_ctrl_chO_inO 0 no - 1d

42 pcnt_ctrl_ch1_inO 0 no - 1d

43 pent_sig_chO_in1 0 no - 1d

44 pcnt_sig_ch1_in4 0 no - 1d

45 pcnt_ctrl_chO_in4 0 no - 1d

46 pcnt_ctrl_ch1_in4 0 no - 1d

47 pcnt_sig_chO_in2 0 no - 1d

48 pcnt_sig_ch1_in2 0 no - 1d

49 pent_ctrl_chO_in2 0 no - 1d

50 pent_ctrl_ch1_in2 0 no - 1d

51 pent_sig_chO_in3 0 no - 1d

52 pcnt_sig_ch1_in3 0 no - 1d

53 pent_ctrl_chO_ins 0 no - 1d

54 pent_ctrl_ch1_ins 0 no - 1d

64 usb_otg_iddig_in 0 no - 1d

65 usb_otg_avalic_in 0 no - 1d

66 usb_srp_bvalic_in 0 no usb_otg_idpullup 1d

67 usb_otg_vbusvalid_in 0 no usb_otg_dppulldown 1d

68 usb_srp_sessend_in 0 no usb_otg_dmpulldown 1d

Espressif Systems 100 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

; Default Same input
Signal . . . . Output enable of output
No, Input signals value if signal from | Output signals signals
unassigned * | 1O MUX core

69 - - - usb_otg_drvvbus 1d
10 - - - usb_srp_chrgvbus 1d
71 - - - usb_srp_dcischrgvbus 1d
12 SPIS_CLK_in 0 no SPI3_CLK_out_mux SPI3_CLK_oe
13 SPI3_Q_ in 0 no SPI3_Q_out SPIS_Q_oe
14 SPIS_D_in 0 no SPI3_D_out SPIS_D_oe
15 SPIS_HD_in 0 no SPI3_HD_out SPI3_HD_oe
16 SPIS_CSO_in 0 no SPI3_CSO_out SPI3_CSO_oe
Ut - - - SPI3_CS1_out SPI3_CS1_oe
18 - - - SPI3_CS2_out SPI3_CS2_oe
19 - - - ledc_Is_sig_outO 1d
80 - - - ledc_Is_sig_outt 1d
81 - - - ledc_Is_sig_out2 1d
82 - - - ledc_Is_sig_outs 1d
83 rmt_sig_inO 0 no ledc_Is_sig_out4 1d
84 rmt_sig_in1 0 no ledc_Is_sig_outS 1d
85 rmt_sig_in2 0 no ledc_Is_sig_outé 1d
86 rmt_sig_ins 0 no ledc_Is_sig_out7 1d
87 - - - rmt_sig_outO 1d
88 - - - rmt_sig_out1 1d
89 - - - rmt_sig_out2 1d
90 - - - rmt_sig_out3 1d
95 I2CEXT1_SCL_in 4 no l2CEXT1_SCL_out I2CEXT1_SCL_oe
96 I2CEXT1_SDA in 4 no l2CEXT1_SDA_ out I2CEXT1_SDA_oe
100 | - - - gpio_sdO_out 1d
101 - - - gpio_sd1_out 1d
102 - - - gpio_sd2_out 1d
103 | - - - gpio_sd3_out 1d
104 | - - - gpio_sd4_out 1d
105 | - - - gpio_sd5_out 1d
106 | - - - gpio_sd6_out 1d
107 - - - gpio_sd7_out 1d
108 | FSPICLK_in 0 yes FSPICLK_out_mux FSPICLK_oe
109 | FSPIQ_in 0 yes FSPIQ_out FSPIQ_oe
110 | FSPID_in 0 yes FSPID_out FSPID_oe
111 FSPIHD_in 0 yes FSPIHD_out FSPIHD_oe
112 | FSPIWP_in 0 yes FSPIWP_out FSPIWP_oe
113 | FSPIO4_in 0 yes FSPIIO4_out FSPIIO4_oe
114 | FSPIIO5_in 0 yes FSPIIO5_out FSPIIO5_oe
115 | FSPIO6_in 0 yes FSPIIO6_out FSPIIO6_oe
116 | FSPIIO7_in 0 yes FSPIIO7_out FSPIIO7_oe

Espressif Systems 101 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

; Default Same input
Signal . . . . Output enable of output
No, Input signals value if signal from | Output signals signals
unassigned * | 1O MUX core

117 | FSPICSO_in 0 yes FSPICSO_out FSPICSO_oe

118 | - - - FSPICS1_out FSPICS1_oe

119 | - - - FSPICS2_out FSPICS2_o0e

120 | - - - FSPICS3_out FSPICS3_o0e

121 - - - FSPICS4_out FSPICS4_oe

122 | - - - FSPICS5_out FSPICS5_oe

123 | can_rx 1 no can_tx 1d

124 | - - - can_bus_off_on 1d

125 | - - - can_clkout 1d

126 | - - - SUBSPICLK_out_mux SUBSPICLK_oe

127 | SUBSPIQ_in 0 yes SUBSPIQ_out SUBSPIQ_oe

128 | SUBSPID_in 0 yes SUBSPID_out SUBSPID_oe

129 | SUBSPIHD_in 0 yes SUBSPIHD_out SUBSPIHD_oe

180 | SUBSPIWP_in 0 yes SUBSPIWP_out SUBSPIWP_oe

131 - - - SUBSPICSO_out SUBSPICSO_oe

182 | - - - SUBSPICS1_out SUBSPICS1_oe

183 | - - - FSPIDQS_out FSPIDQS_oe

1384 | - - - FSPILHSYNC_out FSPIHSYNC_oe

1385 | - - - FSPI_VSYNC_out FSPILVSYNC_oe

136 | - - - FSPI_DE_out FSP|_DE_oe

187 | - - - FSPICD_out FSPICD_oe

139 | - - - SPI3_CD_out SPI38_CD_oe

140 | - - - SPI3_DQS_out SPI3_DQS_oe

143 | I2S0|_DATA_inO 0 no 12800_DATA_out0O 1d

144 | I2S0I_DATA_in1 0 no 12800_DATA_out1 1d

145) | |2S0I_DATA_in2 0 no 12800_DATA_out2 1d

146 | I2S0|_DATA_ins 0 no 12800_DATA_out3 1d

147 | I280|_DATA_in4 0 no I2800_DATA_out4 1d

148 | I2S0|_DATA_ind 0 no 12800_DATA_outS 1d

149 | I2S0|_DATA_in6 0 no 12800_DATA_outé6 1d

150 | I2S0I_DATA_in7 0 no 12800_DATA_out7 1d

151 2801 DATA_in8 0 no 12800_DATA_out8 1d

152 | I2S0|_DATA_in9 0 no 12800_DATA_out9 1d

153 | I2S0I_DATA_in10 0 no 12800_DATA_out10 1d

154 | I2SOI_DATA_in11 0 no 12800_DATA_out11 1d

155 | I2S0I_DATA_in12 0 no 12800_DATA_outt2 1d

156 | I2S0I_DATA_in13 0 no 12800_DATA_out13 1d

157 | I2S0I_DATA_in14 0 no 12800_DATA_out14 1d

158 | I2S0I_DATA_in15 0 no 12800_DATA_out15 1d

159 | - - - 12800_DATA_out16 1d

160 | - - - 12800_DATA_out17 1d
Espressif Systems 102 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

; Default Same input
Signal . . . . Output enable of output
No, Input signals value if signal from | Output signals signals
unassigned * | 1O MUX core
161 - - - 12800_DATA_out18 1d
162 | - - - 12800_DATA_out19 1d
163 | - - - 12800_DATA_out20 1d
164 | - - - 12800_DATA_out21 1d
165 | - - - 12800_DATA_out22 1d
166 | - - - 12800_DATA_out23 1d
167 | SUBSPID4 in 0 yes SUBSPID4_out SUBSPID4_oe
168 | SUBSPID5 in 0 yes SUBSPID5_out SUBSPID5_oe
169 | SUBSPID6 in 0 yes SUBSPID6_out SUBSPID6_oe
170 | SUBSPID7_in 0 yes SUBSPID7_out SUBSPID7_oe
171 SUBSPIDQS_in 0 yes SUBSPIDQS_out SUBSPIDQS_oe
193 | I2SO0I_.H_SYNC 0 no - 1d
194 | I2S0I_V_SYNC 0 no - 1d
195 | l2S0l_H_ENABLE 0 no - 1d
215 | - - - ant_selO 1d
216 | - - - ant_sel1 1d
217 | - - - ant_sel2 1d
218 | - - - ant_sel3 1d
219 | - - - ant_sel4 1d
220 | - - - ant_sel5 1d
221 - - - ant_sel6 1d
222 | - - - ant_sel7 1d
223 | sig_in_func_223 0 no sig_in_func223 1d
224 | sig_in_func_224 0 no sig_in_func224 1d
225 | sig_in_func_225 0 no sig_in_func225 1d
226 | sig_in_func_226 0 no sig_in_func226 1d
227 | sig_in_func_227 0 no sig_in_func227 1d
235 | pro_alonegpio_inO 0 no pro_alonegpio_outO 1d
236 | pro_alonegpio_in4 0 no pro_alonegpio_out1 1d
237 | pro_alonegpio_in2 0 no pro_alonegpio_out2 1d
238 | pro_alonegpio_in3 0 no pro_alonegpio_out3 1d
239 | pro_alonegpio_in4 0 no pro_alonegpio_out4 1d
240 | pro_alonegpio_ind5 0 no pro_alonegpio_out5 1d
241 pro_alonegpio_iné6 0 no pro_alonegpio_out6 1d
242 | pro_alonegpio_in7 0 no pro_alonegpio_out7 1d
251 - - - clk_i2s_mux 1d
5.11 IO MUX Pad List

Table 23 shows the IO MUX functions of each I/O pad:

Espressif Systems

108

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

Table 23: |O MUX Pad List

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

GPIO| Pad Name Function 0 Function 1 | Function 2 | Function 3 Function 4 | Reset| Notes
0 GPIOO GPIOO GPIOO - - - 3 R
1 GPIO1 GPIO1 GPIO1 - - - 1 R
2 GPIO2 GPIO2 GPIO2 - - - 1 R
3 GPIOS GPIOS GPIOS - - - 0 R
4 GPIO4 GPIO4 GPIO4 - - - 0 R
5 GPIO5 GPIO5 GPIO5 - - - 0 R
6 GPIO6 GPIO6 GPIO6 - - - 0 R
7 GPIO7 GPIO7 GPIO7 - - - 0 R
8 GPIO8 GPIO8 GPIO8 - SUBSPICS1 } - 0 R
9 GPIO9 GPIO9 GPIO9 - SUBSPIHD | FSPIHD 1 R
10 GPIO10 GPIO10 GPIO10 FSPIlO4 SUBSPICSO | FSPICSO 1 R
11 GPIO11 GPIO11 GPIO11 FSPIIO5 SUBSPID FSPID 1 R
12 GPIO12 GPIO12 GPIO12 FSPIIO6 SUBSPICLK | FSPICLK 1 R
18 GPIO13 GPIO13 GPIO13 FSPIIO7 SUBSPIQ FSPIQ 1 R
14 GPIO14 GPIO14 GPIO14 FSPIDQS | SUBSPIWP | FSPIWP 1 R
15 XTAL_32K_P | XTAL_32K_P | GPIO15 UORTS - - 0 R
16 XTAL_32K_N | XTAL_32K_N | GPIO16 UoCcTs - - 0 R
17 DAC_1 DAC_1 GPIO17 U1TXD - - 1 R
18 DAC_2 DAC_2 GPIO18 U1RXD CLK_OUTS | - 1 R
19 GPIO19 GPIO19 GPIO19 U1RTS CLK_OUT2 | - 0 R
20 GPIO20 GPIO20 GPIO20 U1CTS CLK_OUT1 | - 0 R
21 GPIO21 GPIO021 GP1021 - - - 0 R
26 SPICS1 SPICS1 GPIO26 - - - 3 -
27 SPIHD SPIHD GPIO27 - - - 3 -
28 SPIWP SPIWP GPIO28 - - - 3 -
29 SPICSO SPICSO GPIO29 - - - 3 -
30 SPICLK SPICLK GPIO30 - - - 3 -
31 SPIQ SPIQ GPIO31 - - - 3 -
82 SPID SPID GPIO32 - - 3 -
383 GPIO33 GPIO33 GPIO33 FSPIHD SUBSPIHD | SPIIO4 1 -
34 GPIO34 GPIO34 GPIO34 FSPICSO SUBSPICS0O | SPIIO5 1 -
35 GPIO35 GPIO35 GPIO35 FSPID SUBSPID SPIIO6 1 -
36 GPIOS6 GPIO36 GPIO36 FSPICLK SUBSPICLK | SPIIO7 1 -
37 GPIO37 GPIO37 GPIO37 FSPIQ SUBSPIQ SPIDQS 1 -
38 GPIO38 GPIO38 GPIO38 FSPIWP SUBSPIWP | - 1 -
39 MTCK MTCK GPIO39 CLK_OUTS3} SUBSPICS1 |} - 1 -
40 MTDO MTDO GPIO40 CLK_OUT2} - - 1 -
4 MTDI MTDI GPIO41 CLK_OUT1] - - 1 -
42 MTMS MTMS GPIO42 - - - 1 -
43 UOTXD UOTXD GPIO43 CLK_OUT1} - - 3 -
44 UORXD UORXD GPIO044 CLK_OUT2} - - 3 -
45 GPIO45 GPIO45 GPIO45 - - - 2 -
Espressif Systems 104 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

GPIO|} Pad Name Function 0 Function 1 | Function 2 | Function 3 Function 4 | Reset} Notes
46 GPIO46 GPIO46 GPIO46 - - - 2 |
Reset Configurations
“Reset” column shows the default configuration of each pad after reset:
* 0 - IE=0 (input disabled)
° 1 - IE=1 (input enabled)
© 2 - IE=1, WPD=1 (input enabled, pull-down resistor enabled)
© 3 - IE=1, WPU=1 (input enabled, pull-up resistor enabled)
Note:
° R - Pad has RTC/analog functions via RTC IO MUX.
e | - Pad can only be configured as input GPIO.
Please refer to Appendix A — ESP32-S2 Pin Lists in ESP32-S2 Datasheet for more details.
5.12 RTC 1O MUX Pin List
Table 24 shows the RTC pins and how they correspond to GPIO pads.
Table 24: RTC 1O MUX Pin Summary
Analog Function
RTC GPIO Num) GPIO Num| Pad Name
1 2 6} 4
0 0 TOUCH_PADO* | RTC_GPIOO - - sar_i2c_scl_0
1 1 TOUCH_PAD1 | RTC_GPIO1 - - sar_i2c_sda_0
2 2 TOUCH_PAD2 | RTC_GPIO2 - - sar_i2c_scl_1
3 3 TOUCH_PAD3 | RTC_GPIOS - - sar_i2c_sda_1
4 4 TOUCH_PAD4 | RTC_GPIO4 - - -
5 5 TOUCH_PAD5S | RTC_GPIO5 - - -
6 6 TOUCH_PAD6 | RTC_GPIO6 - - -
7 7 TOUCH_PAD7 | RTC_GPIO7 - - -
8 8 TOUCH_PAD8 | RTC_GPIO8 - - -
9 9 TOUCH_PAD9 | RTC_GPIO9 - - -
10 10 TOUCH_PAD10| RTC_GPIO10 - -
11 11 TOUCH_PAD11] RTC_GPIO11 - -
12 12 TOUCH_PAD12] RTC_GPIO12 - -
13 13 TOUCH_PAD13] RTC_GPIO13 - -
14 14 TOUCH_PAD14] RTC_GPIO14 - -
15 15 X82P RTC_GPIO15 - -
16 16 X82N RTC_GPIO16 - -
17 17 PDAC1 RTC_GP1IO017 - -
18 18 PDAC2 RTC_GPIO18 - -
19 19 RTC_PAD19 RTC_GP1IO19 - -
Espressif Systems 105 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

 

Analog Function

 

 

 

 

 

 

 

 

RTC GPIO Num| GPIO Num} Pad Name

1 2 3 4
20 20 RTC_PAD20 RTC_GP1I020 -
21 21 RTC_PAD21 RTC_GP1021 -

 

 

 

Note: TOUCH_PADO is an internal channel and its analog functions are not lead to a corresponding external
GPIO.

5.13 Base Address

Users can access the modules described in this chapter via the base addresses shown in the following table. For
more information about accessing peripherals trom different buses, please see Chapter 1 System and

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Memory.
Table 25: Module Base Addresses
Module Name Access to Access Peripheral Base Address
PeriBUS1 Ox3F404000
GPIO -
PeriBUS2 0x60004000
PeriBUS1 Ox3F409000
IO MUX -
PeriBUS2 Ox60009000
GPIOSD PeriBUS2 Ox60004F00
Deicated GPIO PeriBUS1 Ox3F4CFOO00
PeriBUS1 Ox3F408400
RTCIO -
PeriBUS2 O0x60008400
5.14 Register Summary

The address in the following part represents the address offset (relative address) with respect to the peripheral
base address, not the absolute address. For detailed information about the base address, please refer to Section
5.18.

 

 

 

 

 

 

 

 

 

 

 

 

 

5.14.1. GPIO Matrix Register Summary

Name | Description Address | Access
GPIO Configuration Registers

GPIO_BT_SELECT_REG GPIO bit selection register Ox0000 | RAV
GPIO_OUT_REG GPIOO ~ 31 output register O0x0004 | RAV
GPIO_OUT_W1TS_REG GPIOO ~ 31 output bit set register 0x0008 | WO
GPIO_OUT_W1TC_REG GPIOO ~ 31 output bit clear register Ox000C | WO
GPIO_OUT1_REG GPIO32 ~ 58 output register O0x0010 | RAV
GPIO_OUT1_W1TS_REG GPIO32 ~ 53 output bit set register 0x0014 | WO
GPIO_OUT1_W1TC_REG GPIO32 ~ 58 output bit clear register 0x0018 | WO
GPIO_SDIO_SELECT_REG GPIO SDIO selection register Ox001C | RAV
GPIO_ENABLE_REG GPIOO ~ 31 output enable register 0x0020 | RAV
GPIO_ENABLE_W1TS_REG GPIOO ~ 31 output enable bit set register 0x0024 | WO
GPIO_ENABLE_W1TC_REG GPIOO ~ 31 output enable bit clear register 0x0028 | WO

 

 

 

 

 

 

Espressif Systems 106
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
GPIO_ENABLE1_REG GPIO32 ~ 53 output enable register Ox002C | RAV
GPIO_ENABLE1_W1TS_REG GPIO32 ~ 58 output enable bit set register O0x0030 | WO
GPIO_ENABLE1_W1TC_REG GPIO32 ~ 58 output enable bit clear register 0x0034 | WO
GPIO_STRAP_REG Bootstrap pin value register 0x0038 | RO
GPIO_IN_REG GPIOO ~ 31 input register Ox0038C | RO
GPIO_IN1_REG GPIO32 ~ 53 input register 0x0040 | RO
GPIO_PINO_REG Configuration for GPIO pin O 0x0074 | RAV
GPIO_PIN1_REG Configuration for GPIO pin 1 0x0078 | RAV
GPIO_PIN2_REG Configuration for GPIO pin 2 Ox007C | RAV
GPIO_PIN51_REG Configuration for GPIO pin 51 0x0140 | RAV
GPIO_PIN52_REG Configuration for GPIO pin 52 0x0144 | RAV
GPIO_PIN53_REG Configuration for GPIO pin 53 0x0148 | RAV
GPIO_FUNCO_IN_SEL_CFG_REG Peripheral function O input selection register 0x0154 | RAV
GPIO_FUNC1_IN_SEL_CFG_REG Peripheral function 1 input selection register 0x0158 | RAV
GPIO_FUNC2_IN_SEL_CFG_REG Peripheral function 2 input selection register Ox015C | RAV
GPIO_FUNC253_IN_SEL_CFG_REG Peripheral function 253 input selection register 0x0548 | RAV
GPIO_FUNC254_IN_SEL_CFG_REG Peripheral function 254 input selection register Ox054C | RAV
GPIO_FUNC255_IN_SEL_CFG_REG Peripheral function 255 input selection register Ox0550 | RAV
GPIO_FUNCO_OUT_SEL_CFG_REG Peripheral output selection for GPIOO O0x0554 | RAV
GPIO_FUNC1_OUT_SEL_CFG_REG Peripheral output selection for GPIO1 Ox0558 | RAV
GPIO_FUNC2_OUT_SEL_CFG_REG Peripheral output selection for GPIO2 Ox055C | RAV
GPIO_FUNC51_OUT_SEL_CFG_REG Peripheral output selection for GPIOS1 O0x0620 | RAV
GPIO_FUNC52_OUT_SEL_CFG_REG Peripheral output selection for GPIO52 0x0624 | RAV
GPIO_FUNC53_OUT_SEL_CFG_REG Peripheral output selection for GPIO53 0x0628 | RAV
GPIO_CLOCK_GATE_REG GPIO clock gating register Ox062C | RAV
Interrupt Configuration Registers
GPIO_STATUS_W1TS_REG GPIOO ~ 31 interrupt status bit set register 0x0048 | WO
GPIO_STATUS_W1TC_REG GPIOO ~ 31 interrupt status bit clear register O0x004C | WO
GPIO_STATUS1_W1TS_REG GPIO32 ~ 58 interrupt status bit set register 0x0054 | WO
GPIO_STATUS1_W1TC_REG GPIO32 ~ 58 interrupt status bit clear register 0x0058 | WO
GPIO Interrupt Source Registers
GPIO_STATUS_NEXT_REG GPIOO ~ 31 interrupt source register 0x014C | RO
GPIO_STATUS_NEXT1_REG GPIO32 ~ 58 interrupt source register 0x0150 | RO
Interrupt Status Registers
GPIO_STATUS_REG GPIOO ~ 31 interrupt status register 0x0044 | RAV
GPIO_STATUS1_REG GPIO32 ~ 58 interrupt status register Ox0050 =| RAV
GPIO_PCPU_INT_REG GPIOO ~ 31 PRO_CPU interrupt status register | OxO05C | RO
GPIO_PCPU_NMI_INT_REG GPIOO ~ 31 PRO_CPU non-maskable interrupt | OxO060 | RO
status register
GPIO_PCPU_INT1_REG GPIO32 ~ 58 PRO_CPU interrupt status register | OxO068 | RO
Espressif Systems 107 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
GPIO_PCPU_NMI_INT1_REG GPIO32 ~ 53 PRO_CPU non-maskable interrupt | OxOO6C | RO
status register
5.14.2 lO MUX Register Summary

Name Description Address ACCess
|O_MUX_PIN_CTRL Clock output configuration register O0x0000 RAW
|O_MUX_GPIOO_REG Configuration register for pad GPIOO 0x0004 RAW
|IO_MUX_GPIO1_REG Configuration register for pad GPIO1 0x0008 RAW
IO_MUX_GPIO2_REG Configuration register for pad GPIO2 Ox000C RAW
|IO_MUX_GPIO3S_REG Configuration register for pad GPIOS 0x0010 RAW
IO_MUX_GPIO4_REG Configuration register for pad GPIO4 O0x001 4 RAW
IO_MUX_GPIO5_REG Configuration register for pad GPIOS 0x0018 RAW
IO_MUX_GPIO6_REG Configuration register for pad GPIO6 0x001C RAW
|IO_MUX_GPIO7_REG Configuration register for pad GPIO7 0x0020 RAW
|IO_MUX_GPIO8_REG Configuration register for pad GPIO8 0x0024 RAW
|IO_MUX_GPIO9_REG Configuration register for pad GPIO9 0x0028 RAW
|O_MUX_GPIO010_REG Configuration register for pad GPIO10 0x002C RAW
|IO_MUX_GPIO11_REG Configuration register for pad GPIO11 0x0030 RAW
IO_MUX_GPIO12_REG Configuration register for pad GPIO12 0x0034 RAW
IO_MUX_GPIO13_REG Configuration register for pad GPIO13 0x0038 RAW
IO_MUX_GPIO14_REG Configuration register for pad GPIO14 O0x003C RAW
|O_MUX_XTAL_82K_P_REG Configuration register for pad XTAL_S2K_P 0x0040 RAW
|O_MUX_XTAL_82K_N_REG Configuration register for pad XTAL_S2K_N 0x0044 RAW
IO_MUX_DAC_1_REG Configuration register for pad DAC_1 0x0048 RAW
IO_MUX_DAC_2_REG Configuration register for pad DAC_2 0x004C RAW
IO_MUX_GPIO_19_REG Configuration register for pad GPIO19 O0x0050 RAW
|IO_MUX_GPIO_20_REG Configuration register for pad GPIO20 O0x0054 RAW
IO_MUX_GPIO_21_REG Configuration register for pad GPIO21 O0x0058 RAW
IO_MUX_SPICS1_REG Configuration register for pad SPICS1 Ox006C RAW
|O_MUX_SPIHD_REG Configuration register for pad SPIHD 0x0070 RAW
IO_MUX_SPIWP_REG Configuration register for pad SPIWP O0x0074 RAW
|O_MUX_SPICSO_REG Configuration register for pad SPICSO 0x0078 RAW
IO_MUX_SPICLK_REG Configuration register for pad SPICLK 0x007C RAW
IO_MUX_SPIQ_REG Configuration register for pad SPIQ O0x0080 RAW
|O_MUX_SPID_REG Configuration register for pad SPID 0x0084 RAW
|IO_MUX_GPIO_33_REG Configuration register for pad GPIO33 0x0088 RAW
|IO_MUX_GPIO_34_REG Configuration register for pad GPIO34 Ox008C RAW
|IO_MUX_GPIO_35 REG Configuration register for pad GPIO35 Ox0090 RAW
|IO_MUX_GPIO_36_REG Configuration register for pad GPIO36 0x0094 RAW
|O_MUX_GPIO_387_REG Configuration register for pad GPIO37 0x0098 RAW
|IO_MUX_GPIO_38_REG Configuration register for pad GPIO38 Ox009C RAW
|O_MUX_MTCK_REG Configuration register for pad MTCK Ox00A0 RAW
IO_MUX_MTDO_REG Configuration register for pad MTDO Ox00A4 RAW

 

 

 

 

 

Espressif Systems

108
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 

 
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address ACCess
|O_MUX_MTDI_LREG Configuration register for pad MTDI Ox00A8 RAW
IO_MUX_MTMS_REG Configuration register for pad MTMS OxO0AC RAW
|O_MUX_UOTXD_REG Configuration register for pad UOTXD Ox00BO RAW
|O_MUX_UORXD_REG Configuration register for pad UORXD Ox00B4 RAW
IO_MUX_GPIO_45_ REG Configuration register for pad GPIO45 Ox00B8 RAW
|O_MUX_GPIO_46_ REG Configuration register for pad GPIO46 OxO0BC RAW
5.14.3 Sigma Delta Modulated Output Register Summary
Name | Description Address | Access
Configuration Registers
GPIOSD_SIGMADELTAO_REG Duty Cycle Configure Register of SDMO Ox0000 | RAV
GPIOSD_SIGMADELTA1_REG Duty Cycle Configure Register of SDM1 O0x0004 | RAV
GPIOSD_SIGMADELTA2_REG Duty Cycle Configure Register of SDM2 Ox0008 | RAV
GPIOSD_SIGMADELTA3_REG Duty Cycle Configure Register of SDM3 Ox000C | RAV
GPIOSD_SIGMADELTA4_ REG Duty Cycle Configure Register of SDM4 O0x0010 | RAV
GPIOSD_SIGMADELTA5_REG Duty Cycle Configure Register of SDM5 0x0014 | RAV
GPIOSD_SIGMADELTA6_REG Duty Cycle Configure Register of SDM6 0x0018 | RAV
GPIOSD_SIGMADELTA7_REG Duty Cycle Configure Register of SDM7 Ox001C | RAV
GPIOSD_SIGMADELTA_CG_REG Clock Gating Configure Register 0x0020 | RAV
GPIOSD_SIGMADELTA_MISC_REG MISC Register 0x0024 | RAV
GPIOSD_SIGMADELTA_VERSION_REG | Version Control Register 0x0028 | RAV
5.14.4 Dedicated GPIO Register Summary
Name | Description Address | Access
Configuration registers
DEDIC_GPIO_OUT_DRT_REG Dedicated GPIO direct output register Ox0000 | WO
DEDIC_GPIO_OUT_MSK_REG Dedicated GPIO mask output register 0x0004 | WO
DEDIC_GPIO_OUT_IDV_REG Dedicated GPIO individual output register 0x0008 | WO
DEDIC_GPIO_OUT_CPU_REG Dedicated GPIO output mode selection register O0x0010 | RAV
DEDIC_GPIO_IN_DLY_REG Dedicated GPIO input delay configuration register 0x0014 | RAV
DEDIC_GPIO_INTR_RCGN_REG | Dedicated GPIO interrupts generation mode register Ox001C | RAV
Status registers
DEDIC_GPIO_OUT_SCAN_REG | Dedicated GPIO output status register Ox000C | RO
DEDIC_GPIO_IN_-SCAN_REG Dedicated GPIO input status register 0x0018 | RO
Interrupt registers
DEDIC_GPIO_INTR_RAW_REG Raw interrupt status 0x0020 | RO
DEDIC_GPIO_INTR_RLS_REG Interrupt enable bits 0x0024 | RAV
DEDIC_GPIO_INTR_ST_REG Masked interrupt status 0x0028 | RO
DEDIC_GPIO_INTR_CLR_REG Interrupt clear bits Ox002C | WO
5.14.5 RTC 1O MUX Register Summary
Espressif Systems 109 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 

 

 
5. 1O MUX and GPIO Matrix

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
GPIO Configuration and Data Registers

RTCIO_RTC_GPIO_OUT_REG RTC GPIO output register Ox0000 | RAV
RTCIO_RTC_GPIO_OUT_W1TS_REG RTC GPIO output bit set register 0x0004 | WO
RTCIO_RTC_GPIO_OUT_W1TC_REG RTC GPIO output bit clear register 0x0008 | WO
RTCIO_RTC_GPIO_ENABLE_REG RTC GPIO output enable register Ox000C | RAV
RTCIO_RTC_GPIO_ENABLE_ W1TS_REG]} RTC GPIO output enable bit set register 0x0010 | WO
RTCIO_RTC_GPIO_ENABLE_ W1TC_REG} RTC GPIO output enable bit clear register 0x0014 | WO
RTCIO_RTC_GPIO_STATUS_REG RTC GPIO interrupt status register 0x0018 | RAV
RTCIO_RTC_GPIO_STATUS_W1TS_REG | RTC GPIO interrupt status bit set register 0x001C | WO
RTCIO_RTC_GPIO_STATUS_W1TC_REG} RTC GPIO interrupt status bit clear register 0x0020 | WO
RTCIO_RTC_GPIO_IN_REG RTC GPIO input register 0x0024 | RO
RTCIO_RTC_GPIO_PINO_REG RTC configuration for pin O 0x0028 | RAV
RTCIO_RTC_GPIO_PIN1_REG RTC configuration for pin 4 Ox002C | RAV
RTCIO_RTC_GPIO_PIN2_REG RTC configuration for pin 2 Ox0030 | RAV
RTCIO_RTC_GPIO_PINS_REG RTC configuration for pin 3 0x0034 | RAV
RTCIO_RTC_GPIO_PIN19_ REG RTC configuration for pin 19 0x0074 | RAV
RTCIO_RTC_GPIO_PIN20_REG RTC configuration for pin 20 0x0078 | RAV
RTCIO_RTC_GPIO_PIN21_REG RTC configuration for pin 21 Ox007C | RAV
GPIO RTC Function Configuration Registers

RTCIO_TOUCH_PADO_REG Touch pad 0 configuration register 0x0084 | RAV
RTCIO_TOUCH_PAD1_REG Touch pad 1 configuration register O0x0088 | RAV
RTCIO_TOUCH_PAD2_REG Touch pad 2 configuration register Ox008C | RAV
RTCIO_TOUCH_PAD13_REG Touch pad 13 configuration register Ox00B8 | RAV
RTCIO_TOUCH_PAD14_ REG Touch pad 14 configuration register OxOOBC | RAV
RTCIO_XTAL_32P_PAD_REG 82KHz crystal P-pad configuration register Ox00CO | RAV
RTCIO_XTAL_32N_PAD_REG 82KHz crystal N-pad configuration register Ox00C4 | RAV
RTCIO_PAD_DAC1_REG DAC1 configuration register Ox00C8 | RAV
RTCIO_PAD_DAC2_REG DAC2 configuration register Ox00CC | RAV
RTCIO_RTC_PAD19_REG Touch pad 19 configuration register OxOO0DO | RAV
RTCIO_RTC_PAD20_REG Touch pad 20 configuration register Ox00D4 | RAV
RTCIO_RTC_PAD21_REG Touch pad 21 configuration register Ox00D8 | RAV
RTCIO_XTL_EXT_CTR_REG Crystal power down enable GPIO source OxOOEO | RAV
RTCIO_SAR_|2C_lO_REG RTC |2C pad selection OxO0E4 | RAV

 

5.15 Registers

The address in the following part represents the address offset (relative address) with respect to the peripheral

base address, not the absolute address. For detailed information about the base address, please refer to Section

5.13.

Espressif Systems

110 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback

 
5. 1O MUX and GPIO Matrix

 

5.15.1 GPIO Matrix Registers

Register 5.1: GPIO_BT_SELECT_REG (0x0000)

 

 

| 0x000000 | Reset

 

GPIO_BT_SEL Reserved (R/W)

Register 5.2: GPIO_OUT_REG (0x0004)

 

[ “|

| 0x000000 | Reset

 

 

GPIO_OUT_DATA_ORIG GPIOO ~ 31 output value in simple GPIO output mode. The values of bitO
~ bit31 correspond to the output value of GPIOO ~ GPIOS1 respectively. Bit22 ~ bit25 are invalid.

(RW)

Register 5.3: GPIO_OUT_W1TS_REG (0x0008)

| 0x000000 | Reset

 

 

GPIO_OUT_W1TS GPIOO ~ 31 output set register. If the value 1 is written to a bit here, the corre-
sponding bit in GPIO_OUT_REG will be set to 1. Recommended operation: use this register to set
GPIO_OUT_REG. (WO)

Espressif Systems 111 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.4: GPIO_OUT_W1TC_REG (0x000C)
| 0x000000 | Reset

 

GPIO_OUT_W1TC GPIOO ~ 31 output clear register. If the value 1 is written to a bit here, the cor-
responding bit in GPIO_OUT_REG will be cleared. Recommended operation: use this register to
clear GPIO_OUT_REG. (WO)

Register 5.5: GPIO_OUT1_REG (0x0010)

ss 7
&

[a1 afar o|

 

 

 

[0 0000000 0 o| 0x0000 |Reset

 

GPIO_OUT1_ DATA ORIG GPIO32 ~ 58 output value in simple GPIO outout mode. The values of
bitO ~ bit13 correspond to GPIOS32 ~ GPIO45. Bit14 ~ bit21 are invalid. (RAV)

Register 5.6: GPIO_OUT1_W1TS_REG (0x001 4)

 

 

 

&
\Z
& SS
& Se
[a1 afar o|
[0 0000000 0 o| 0x0000 |Reset

 

GPIO_OUT1_W1TS GPIO32 ~ 53 output value set register. If the value 1 is written to a bit here, the
corresponding bit in GPIO_OUT1_REG will be set to 1. Recommended operation: use this register
to set GPIO_OUT1_REG. (WO)

Espressif Systems 112 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.7: GPIO_OUT1_W1TC_REG (0x0018)

 

 

 

xO
XN
S ov
é Se
[1 22 | at o|
[o 0000000 0 | 0x0000 |Reset

 

GPIO_OUT1_W1TC GPIO32 ~ 53 output value clear register. If the value 1 is written to a bit here, the
corresponding bit in GPIO_OUT1_REG will be cleared. Recommended operation: use this register
to clear GPIO_OUT1_REG. (WO)

Register 5.8: GPIO_SDIO_SELECT_REG (0x001C)

 

 

 

 

 

 

 

 

SY
& ge”
& ee
[1 al7 o|
[oo 0000000000000 000000 00 9 x0 |Reset
GPIO_SDIO_SEL Reserved (RW)
Register 5.9: GPIO_ENABLE_REG (0x0020)
&
“yy?
SY
Ro
O7%
&
[1 o|
| 0x000000 | Reset
GPIO_ ENABLE DATA GPIOO ~ 31 output enable register. (RAV)
Espressif Systems 113 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.10: GPIO_ENABLE_W1TS_REG (0x0024)

 

 

KO
AN
Ss
o
oO 4
~~
&
31 o
0x000000 Reset

 

 

 

GPIO_ENABLE W1TS GPIOO ~ 31 output enable set register. If the value 1 is written to a bit here,
the corresponding bit in GPIO_ENABLE_REG will be set to 1. Recommended operation: use this
register to set GPIO_ENABLE_REG. (WO)

Register 5.11: GPIO_ENABLE_W1TC_REG (0x0028)

©
<

yy
yy
o

30”
Ne
©

[ |

| Ox000000 | Reset

 

 

 

GPIO_ENABLE W1TC GPIOO ~ 31 output enable clear register. If the value 1 is written to a bit here,
the corresponding bit in GPIOLENABLE_REG will be cleared. Recommended operation: use this
register to clear GPIO_ENABLE REG. (WO)

Register 5.12: GPIO_ENABLE1_REG (0x002C)
| 31 22 | 21 0 |
[o 0000 000 0 o| 0x0000 |Reset
GPIO_ENABLE1_ DATA GPIO32 ~ 53 output enable register. (RAV)
Espressif Systems 114 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.13: GPIO_ENABLE1_W1TS_REG (0x0030)

 

 

 

KO
SS
NZ
QO
& ¥
& SO
[a1 afar o|
[0 0000000 0 o| 0x0000 |Reset

 

GPIO_ENABLE1_W1TS GPIO32 ~ 58 output enable set register. If the value 1 is written to a bit here,
the corresponding bit in GPIO_ENABLE1_REG will be set to 1. Recommended operation: use this
register to set GPIO_ENABLE1_REG. (WO)

Register 5.14: GPIOLENABLE1_W1TC_REG (0x0034)

 

 

 

xO
SS
NZ
QO
& ¥
& SO
[a1 afar o|
[0 0000000 0 o| 0x0000 |Reset

 

GPIO_ENABLE1_W1TC GPIOS2 ~ 53 output enable clear register. If the value 1 is written to a bit
here, the corresponding bit in GPIO_LENABLE1_REG will be cleared. Recommended operation:
use this register to clear GPIO_ENABLE1_REG. (WO)

Register 5.15: GPIO_STRAP_REG (0x0038)

 

 

 

&
&
S aCe
se 0”
& s
[a1 16 [is o|
fo0 9 00009000000 0 0 9 0 |Reset

 

GPIO_STRAPPING GPIO strapping values: bit4 ~ bit2 correspond to stripping pins GPIO45, GPIOO,
and GPIO46 respectively. (RO)

Espressif Systems 115 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.16: GPIO_IN_REG (0x003C)


GPIO_IN_DATA_NEXT GPIO0~ 31 input value. Each bit represents a pad input value, 1 for high level
and 0 for low level. (RO)

Register 5.17: GPIO_IN1_REG (0x0040)

GPIO_IN_DATA1_NEXT GPIO32 ~ 53 input value. Each bit represents a pad input value. (RO)

Espressif Systems 116 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.18: GPIO_PIN7_REG (7: 0-53) (0x0074+4*/)

 

 

 

| ox0 | oo [0] OxO [o a] oxo [o] x0 Reset

 

GPIO_PIN7r_SYNC2_ BYPASS For the second stage synchronization, GPIO input data can be syn-
chronized on either edge of the APB clock. 0: no synchronization; 1: synchronized on falling edge;
2 and 3: synchronized on rising edge. (R/W)

GPIO_PIN7_PAD_DRIVER Pad driver selection. 0: normal output; 1: open drain output. (RAW)

GPIO_PIN7_SYNC1_BYPASS For the first stage synchronization, GPIO input data can be synchro-
nized on either edge of the APB clock. 0: no synchronization; 1: synchronized on falling edge; 2
and 8: synchronized on rising edge. (RAN)

GPIO_PIN7_INT_TYPE Interrupt type selection. 0: GPIO interrupt disabled; 1: rising edge trigger; 2:
falling edge trigger; 3: any edge trigger; 4: low level trigger; 5: high level trigger. (RAM)

GPIO_PIN7_WAKEUP_ENABLE GPIO wake-up enable bit, only wakes up the CPU from Light-sleep
(RAV)

GPIO_PINn_CONFIG Reserved (RAV)

GPIO_PIN7_INT_ENA Interrupt enable bits. bit13: CPU interrupt enabled; bit14: CPU non-maskable
interrupt enabled. (RAW)

Register 5.19: GPIO_FUNCn_IN_SEL_CFG_REG (”: 0-255) (0x0154+4*n)

 

 

 

 

GPIO_FUNCr_IN_SEL Selection control for peripheral input signal , selects a pad from the 54 GPIO
matrix pads to connect this input signal. Or selects 0x38 for a constantly high input or OxSC for a
constantly low input. (RAW)

GPIO_FUNC”_IN_INV_SEL Invert the input value. 1: invert enabled; 0: invert disabled. (RAV)

GPIO_SIGro_IN SEL Bypass GPIO matrix. 1: route signals via GPIO matrix, 0: connect signals di-
rectly to peripheral configured in IO_MUX. (RAV)

Espressif Systems 117 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.20: GPIO_FUNCn_OUT_SEL_CFG_REG (7: 0-53) (0x0554+4*)

 

 

 

yy yy
XY 8
Mo Y
SS gz?
SLO S
OOO ov
& SSS
J 0%,0407 sO”
& SES &
[1 [a w]e |e o|
jo 9 0 00 000000000 00 0 0 0 ofofofo| 0x100 |Reset

 

GPIO_FUNCn_OUT_SEL Selection control for GPIO cutout 7. If a value s (O<=s<256) is
written to this field, the peripheral output signal s will be connected to GPIO output
n. lf a value 256 is written to this field, bit o of GPIO_LOUT_REG/GPIO_OUT1_REG and
GPIO_ENABLE_REG/GPIO_ENABLE1_REG will be selected as the output value and output en-
able. (RAW)

GPIO_FUNCn_OUT_INV_SEL 0: Do not invert the output value; 1: Invert the output value. (R/W)

GPIO_FUNCn_OEN_SEL 0: Use output enable signal from peripheral; 1: Force the output enable
signal to be sourced from bit n of GPIO_ENABLE_REG. (RAW)

GPIO_FUNCn_OEN_INV_SEL 0: Do not invert the output enable signal; 1: Invert the outout enable
signal. (RAV)

Register 5.21: GPIO_CLOCK_GATE_REG (0x062C)

 

[ Te]

joo 0 0 0000090000000 9 00900000 00 0 0 0 0 0 0[1 IReset

 

 

GPIO_CLK_EN Clock gating enable bit. If set to 1, the clock is free running. (RAW)

Register 5.22: GPIO_STATUS_W1TS_REG (0x0048)
[ 7]
| 0x000000 | Reset

 

 

GPIO_STATUS_W1TS GPIOO ~ 31 interrupt status set register. If the value 1 is written to a bit here,
the corresponding bit in GPIO_STATUS_INTERRUPT will be set to 1. Recommended operation:
use this register to set GPIO_STATUS_INTERRUPT. (WO)

Espressif Systems 118 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.23: GPIO_STATUS_W1TC_REG (0x004C)

 

31 °

 

 

 

0x000000 Reset

 

GPIO_STATUS_W1TC GPIOO~ 31 interrupt status clear register. If the value 1 is written to a bit here,
the corresponding bit in GPIO_STATUS_INTERRUPT will be cleared. Recommended operation:
use this register to clear GPIO_STATUS_INTERRUPT. (WO)

Register 5.24: GPIO_STATUS1_W1TS_REG (0x0054)

 

 

 

KO
we
er
& .
@ sO%
& S
[1 22 | at o|
[o 0000000 0 | 0x0000 |Reset

 

GPIO_STATUS1_W1TS GPIOS2 ~ 59 interrupt status set register. If the value 1 is written to a bit here,
the corresponding bit in GPIO_STATUS1_REG will be set to 1. Recommended operation: use this
register to set GPIO_STATUS1_REG. (WO)

Register 5.25: GPIO_STATUS1_W1TC_REG (0x0058)

 

[a1 afar o|

 

 

[0 0000000 0 o| 0x0000 |Reset

 

GPIO_STATUS1_W1TC GPIO32 ~ 53 interrupt status clear register. If the value 1 is written to a bit
here, the corresponding bit in GPIO_STATUS1_REG will be cleared. Recommended operation:
use this register to clear GPIO_STATUS1_REG. (WO)

Espressif Systems 119 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.26: GPIO_STATUS_NEXT_REG (0x014C)

 

[ “|

| 0x000000 | Reset

 

 

GPIO_STATUS_INTERRUPT_NEXT Interrupt source signal of GPIOO ~ 31, could be rising edge in-
terrupt, falling edge interrupt, level sensitive interrupt and any edge interrupt. (RO)

Register 5.27: GPIO_STATUS_NEXT1_REG (0x0150)

 

 

 

SY
&
Ss
f
a?
& Ae
g 307%
& S
[1 2221 o|
[o 0000000 0 o| 0x0000 |Reset

 

GPIO_STATUS1_INTERRUPT_NEXT Interrupt source signal of GPIO32 ~ 53. (RO)

Register 5.28: GPIO_STATUS_REG (0x0044)

| ©x000000 | Reset

 

 

 

GPIO_STATUS_INTERRUPT GPIOO ~ 31 interrupt status register. (RW)

Espressif Systems 120 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.29: GPIO_STATUS1_REG (0x0050)

31 22 | 21 0
0000000 0 0 0 0x0000 Reset
GPIO_STATUS1_INTERRUPT GPIOS&2 ~ 53 interrupt status register. (RAV)
Register 5.30: GPIO_PCPU_INT_REG (0x005C)
s
oe
Oo
©
O7%
&
[1 o|
| 0x000000 | Reset

 

GPIO_PROCPU_INT GPIOO ~ 31 PRO_CPU interrupt status. This interrupt status is corresponding
to the bit in GPIO_STATUS_REG when assert (high) enable signal (bit13 of GPIO_PINn_REG). (RO)

Register 5.31: GPIO_PCPU_NMI_INT_REG (0x0060)

 

 

s
Y
Ss
7
S
O
SS
oO 7
\
S
31 0
ox000000 Reset

 

 

 

GPIO_PROCPU_NML INT GPIOO ~ 31 PRO_CPU non-maskable interrupt status. This interrupt sta-
tus is corresponding to the bit in GPIO_STATUS_REG when assert (high) enable signal (bit 14 of
GPIO_PIN?_REG). (RO)

Espressif Systems 121 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.32: GPIO_PCPU_INT1_REG (0x0068)

 

[1 2221 o|

 

 

[o 0000000 0 o| 0x0000 |Reset

 

GPIO_PROCPU1_INT GPIOS2 ~ 53 PRO_CPU interrupt status. This interrupt status is correspond-
ing to the bit in GPIO_STATUS1_REG when assert (high) enable signal (bit 13 of GRPIO_PINn_REG).

 

 

 

(RO)
Register 5.33: GPIO_PCPU_NMI_INT1_REG (0x006C)
Ss
SN 7
a)
Ce
O
O
& &
& ge
[1 2221 o|
[o 0000000 0 o| 0x0000 |Reset

 

GPIO_PROCPU_NMI1_INT GPIO32 ~ 53 PRO_CPU non-maskable interrupt status. This interrupt
status is corresponding to bit in GPIO_STATUS1_REG when assert (high) enable signal (bit 14 of
GPIO_PIN?_REG). (RO)

Espressif Systems 122 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

5.15.2 10 MUX Registers
Register 5.34: 1O_MUX_PIN_CTRL (0x0000)

 

 

 

we % Y N
CS FF
S YY aY ev
S &< Oo Oo
S eS & we <
$ we we we we we
& oe oe? oe oe
[1 [15 | wu al [3 o|
| Ox [oxo] Ox2 | x0 | x0 | x0 |Reset

 

IO _MUX_PIN_CTRL_CLK« If you want to output clock for I2S0 to:
CLK_OUT1 then set IO_MUX_PIN_CTRLJ[S:0] = Ox0
CLK_OUT2 then set |O_MUX_PIN_CTRLJ[S:0] = 0x0 and |O_MUX_PIN_CTRL[7:4] = 0x0;
CLK_OUTS then set |O_MUX_PIN_CTRLJ[S:0] = 0x0 and |O_MUX_PIN_CTRL[1 1:8] = 0x0.
Note:
Only the above mentioned combinations of clock source and clock output pins are possible.
The CLK_OUT1 ~ 3can be found in IO_MUX Pad List.

IO _MUX_SWITCH_PRT_NUM IO pad power switch delay, delay unit is one APB clock.

IO MUX_PAD_POWER_CTRL Select power voltage for GPIOS3 ~ 37. 1: select VDD_SPI 1.8 V; 0:
select VDDSP3_CPU 3.3 V.

Espressif Systems 123 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.35: 1O_MUX_p_REG (7: GPIOO-GP1021, GPIO26-GPIO046) (0x0010+4*/)

> yy ~ SO
ge SF FS «SS

x ss OX QS
SY LF PSSA, MU Vo

 

 

 

O
S S
Zé ws we we SY”, sf SH o”
€ er 0% O*O%O% LOO“ OOO”
[a1 [6 [a wu wl ole]? |e slefe[e[a[e]
fo 0 0 00 00 0900 00 0 0 0 Ofoxo x0 | oe [ofo]fo] o [o]o[o]o] 4 IReset

 

IO MUX _MCU_OE Output enable of the pad in sleep mode. 1: Output enabled; 0: Output disabled.
(RAV)

IO MUX_SLP_SEL Sleep mode selection of this pad. Set to 1 to put the pad in sleep mode. (R/W)

IO MUX _MCU_WPD Pull-down enable of the pad during sleep mode. 1: Internal pull-down enabled;
O: Internal pull-down disabled. (RAV)

IO MUX_MCU_WPU Pull-up enable of the pad during sleep mode. 1: Internal pull-up enabled; 0:
Internal pull-up disabled.

IO _MUX_MCU_IE Input enable of the pad during sleep mode. 1: Input enabled; O: Input disabled.

(RW)

1O_MUX_FUN_WPD Pull-down enable of the pad. 1: Pull-down enabled; 0: Pull-down disabled.
(RW)

IO MUX_FUN_WPU Pull-up enable of the pad. 1: Internal pull-up enabled; 0: Internal pull-up dis-
abled. (RAV)

IO _MUX_FUN_IE Input enable of the pad. 1: Input enabled; 0: Input disabled. (R/W)

IO _MUX_FUN_DRV Select the drive strength of the pad. 0: ~5 mA: 1: ~10 mA: 2: ~20 mA; 3: ~40
mA. (RAW)

IO_MUX_MCU_SEL Select |O MUX function for this signal. 0: Select Function 0; 1: Select Function
1, etc. (RW)

10 _MUX_FILTER_EN Enable filter for pin input signals. 1: Filter enabled; 2: Filter disabled. (RAV)

Espressif Systems 124 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

5.15.3 Sigma Delta Modulated Output Registers

Register 5.36: GPIOSD_SIGMADELTA”_REG (7: 0-7) (0x0000+4*/)

 

 

 

y%
ey
E
x =
QO Or
S
RG ov So
& oo -
« S S
[1 16 [15 al7 o|
[oo 0 900000000000 9 Oxf | Oxo |Reset

 

GPIOSD_SD”_IN This field is used to configure the duty cycle of sigma delta modulation output.
(RAV)

GPIOSD_SDn_PRESCALE This field is used to set a divider value to divide APB clock. (RAV)

Register 5.37: GPIOSD_SIGMADELTA_CG_REG (0x0020)

 

 

 

 

GPIOSD_CLK_EN Clock enable bit of configuration registers for sigma delta modulation. (RW)

Register 5.38: GPIOSD_SIGMADELTA_MISC_REG (0x0024)

S
er
Oo
ro
©
OY, SS
O79’ Ss
SF &
Ss & Se

 

 

 

 

 

 

0);0]0 0 0 0 00 0 0 0 00 0 00 00 0 00 00 00 0 0 0 0 0 0 OfReset

 

GPIOSD FUNCTION CLK _EN Clock enable bit of sigma delta modulation. (RAV)

GPIOSD_SPI_LSWAP Reserved. (RAW)

Espressif Systems 125 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.39: GPIOSD_SIGMADELTA_VERSION_REG (0x0028)

 

 

 

x
Vel
S 7
er
S SO”
& &
| 31 28 | 27 9 |
fo 0 0 of 0x1 802260 |Reset

 

GPIOSD_GPIO_SD DATE Version control register. (RAM)

5.15.4 Dedicated GPIO Registers

Register 5.40: DEDIC_GPIO_OUT_DRT_REG (0x0000)
| 31 8 | 7 0 |
foo 00000000000000090000 00 0 xO |Reset
DEDIC_GPIO_OUT_DRT_VLAUE This register is used to configure direct output value of 8-channel
dedicated GPIO. (WO)
Register 5.41: DEDIC_GPIO_OUT_MSK_REG (0x0004)

| 31 16 | 15 8 | 7 0 |
[oo 0 900000000000 9 x0 | x0 |Reset
DEDIC_GPIO_OUT_VALUE Thisregister is used to configure updated output value of 8-channel ded-
icated GPIO. (WO)
DEDIC_GPIO_OUT_MSK This register is used to configure channels which would be updated. 1:
corresponding channel's output would be updated. (WO)
Espressif Systems 126 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.42: DEDIC_GPIO_OUT_IDV_REG (0x0008)

 

 

 

 

 

 

 

 

 

 

 

 

OxO [Reset

 

DEDIC_GPIO_OUT_IDV_CHO Configure channel 0 output value.
value. 2: clear output value. 3: inverse output value. (WO)

DEDIC_GPIO_OUT_IDV_CH1 Configure channel 1 output value.
value. 2: clear output value. 3: inverse output value. (WO)

DEDIC_GPIO_OUT_IDV_CH2 Configure channel 2 output value.
value. 2: clear output value. 3: inverse output value. (WO)

DEDIC_GPIO_OUT_IDV_CH3 Configure channel 3 output value.
value. 2: clear output value. 3: inverse output value. (WO)

DEDIC_GPIO_OUT_IDV_CH4 Configure channel 4 output value.
value. 2: clear output value. 3: inverse output value. (WO)

DEDIC_GPIO_OUT_IDV_CH5 Configure channel 5 output value.
value. 2: clear output value. 3: inverse output value. (WO)

DEDIC_GPIO_OUT_IDV_CH6 Configure channel 6 output value.
value. 2: clear output value. 3: inverse output value. (WO)

DEDIC_GPIO_OUT_IDV_CH7 Configure channel 7 output value.
value. 2: clear output value. 3: inverse output value. (WO)

Espressif Systems 127

Submit Documentation Feedback

: hold output value. 1: set output

: hold output value.

: hold output value.

: hold output value.

: hold output value.

: hold output value.

: hold output value.

: hold output value.

: set output

: set output

: set output

: set output

: set output

: set output

: set output

ESP32-S2 TRM (Preliminary V0.4)
5. 1O MUX and GPIO Matrix

 

Register 5.43: DEDIC_GPIO_OUT_CPU_REG (0x0010)

©

& x
CRO OROROR ORO)
SPEED
& CE EEE EES

 

es} 7] 6]5 4/3 ]2 1 °

 

 

00000000 0600000060 00 0 0 060 0 6 ofofolololo}olo] o IReset

 

 

 

 

 

 

 

 

 

 

Espressif Systems 128

DEDIC_GPIO_OUT_CPU_SELO Select GPIO out value configured by registers or CPU instructions
for channel 0. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

DEDIC_GPIO_OUT_CPU_SEL1 Select GPIO out value configured by registers or CPU instructions
for channel 1. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

DEDIC_GPIO_OUT_CPU_SEL2 Select GPIO out value configured by registers or CPU instructions
for channel 2. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

DEDIC_GPIO_OUT_CPU_SEL3 Select GPIO out value configured by registers or CPU instructions
for channel 8. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

DEDIC_GPIO_OUT_CPU_SEL4 Select GPIO out value configured by registers or CPU instructions
for channel 4. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

DEDIC_GPIO_OUT_CPU_SEL5 Select GPIO out value configured by registers or CPU instructions
for channel 5. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

DEDIC_GPIO_OUT_CPU_SEL6 Select GPIO out value configured by registers or CPU instructions
for channel 6. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

DEDIC_GPIO_OUT_CPU_SEL7 Select GPIO out value configured by registers or CPU instructions
for channel 7. 0: Configured by registers. 1: Configured by CPU instructions. (RAM)

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
5. 1O MUX and GPIO Matrix

 

Register 5.44: DEDIC_GPIO_IN_DLY_REG (0x0014)

jo 0 0 9 9 0 0 9 09 00 0 0 0 0 of o | oo | oo | oo | oo | 0 | ox | 00 Reset

 
DEDIC_GPIO_IN_DLY_CHO Configure GPIOO input delay. 0: no delay. 1: one clock delay. 2: two

clock delay. 3: three clock delay. (RAW)

DEDIC_GPIO_IN_DLY_CH1 Configure GPIO1 input delay.
clock delay. 3: three clock delay. (RAW)

DEDIC_GPIO_IN_DLY_CH2 Configure GPIO2 input delay.
clock delay. 3: three clock delay. (RAW)

DEDIC_GPIO_IN_DLY_CH3 Configure GPIOS input delay.
clock delay. 3: three clock delay. (RAW)

DEDIC_GPIO_IN_DLY_CH4 Configure GPIO4 input delay.
clock delay. 3: three clock delay. (RAW)

DEDIC_GPIO_IN_DLY_CH5 Configure GPIO5 input delay.
clock delay. 3: three clock delay. (RAW)

DEDIC_GPIO_IN_DLY_CH6 Configure GPIO6 input delay.
clock delay. 3: three clock delay. (RAW)

DEDIC_GPIO_IN_DLY_CH7 Configure GPIO7 input delay.
clock delay. 3: three clock delay. (RAW)

Espressif Systems 129

: no delay.

: no delay.

: no delay.

: no delay.

: no delay.

: no delay.

: no delay.

Submit Documentation Feedback

1: one clock delay. 2: two

1: one clock delay. 2: two
1: one clock delay. 2: two
1: one clock delay. 2: two
1: one clock delay. 2: two
two

1: one clock delay. 2:

1: one clock delay. 2: two

ESP32-S2 TRM (Preliminary V0.4)
5. 1O MUX and GPIO Matrix

 

Register 5.45: DEDIC_GPIO_INTR_RCGN_REG (0x001C)

 

 

 

 

Espressif Systems 130

DEDIC_GPIO_INTR_MODE_CHO Configure channel 0 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

DEDIC_GPIO_INTR_MODE_CH1 Configure channel 1 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

DEDIC_GPIO_INTR_MODE_CH2 Configure channel 2 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

DEDIC_GPIO_INTR_MODE_CH3 Configure channel 3 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

DEDIC_GPIO_INTR_MODE_CH4 Configure channel 4 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

DEDIC_GPIO_INTR_MODE_CH5 Configure channel 5 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

DEDIC_GPIO_INTR_MODE_CH6 Configure channel 6 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

DEDIC_GPIO_INTR_MODE_CH7 Configure channel 7 interrupt generate mode. 0/1:
erate interrupt. 2: low level trigger. 3: high level trigger. 4: falling edge trigger. 5:
trigger. 6/7: falling and raising edge trigger. (RAV)

Submit Documentation Feedback

do not gen-
raising edge

do not gen-
raising edge

do not gen-
raising edge

do not gen-
raising edge

do not gen-
raising edge

do not gen-
raising edge

do not gen-
raising edge

do not gen-
raising edge

ESP32-S2 TRM (Preliminary V0.4)
5. 1O MUX and GPIO Matrix

 

Register 5.46: DEDIC_GPIO_OUT_SCAN_REG (0x000C)
[a1 al o|
foo 00000000000000090000 00 0 0x0 |Reset

 

DEDIC_GPIO_OUT_STATUS GPIO output value configured by DEDIC_GPIO_OUT_DRT_REG,
DEDIC_GPIO_OUT_MSK_REG, and DEDIC_GPIO_OUT_IDV_REG. (RO)

Register 5.47: DEDIC_GPIO_IN_SCAN_REG (0x0018)

 

 

 

a)
&
S
oS
f
~~
> 5
g so
NG &
[1 al o|
joo 9 0000000900000 090090000 00 9 OxO |Reset

 

DEDIC_GPIO_IN_STATUS GPIO input value after configured by DEDIC_GPIO_IN_DLY_REG. (RO)

Espressif Systems

131

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
5. 1O MUX and GPIO Matrix

 

Register 5.48: DEDIC_GPIO_INTR_RAW_REG (0x0020)

 

 

 

 

DEDIC_GPIOO_INT_RAW This interrupt raw bit turns to high level
level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.

DEDIC_GPIO1_INT_RAW This interrupt raw bit turns to high level
level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.

DEDIC_GPIO2_INT_RAW This interrupt raw bit turns to high level
level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.

DEDIC_GPIO3_INT_RAW This interrupt raw bit turns to high level
level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.

DEDIC_GPIO4_INT_RAW This interrupt raw bit turns to high level
level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.

DEDIC_GPIO5_INT_RAW This interrupt raw bit turns to high level
level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.

DEDIC_GPIO6_INT_RAW This interrupt raw bit turns to high level
level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG.

DEDIC_GPIO7_INT_RAW This interrupt raw bit turns to high level

when
(RO)

when
(RO)

when
(RO)

when
(RO)

when
(RO)

when
(RO)

when
(RO)

when

dedicated GPIOO has

has

dedicated GPIO1

has

dedicated GPIO2

dedicated GPIO3 has

dedicated GPIO4 has

dedicated GPIO5 has

dedicated GPIO6 has

dedicated GPIO7 has

level/edge change configured by DEDIC_GPIO_INTR_RCGN_REG. (RO)

132
Submit Documentation Feedback

Espressif Systems ESP32-S2 TRM (Preliminary V0.4)
5. 1O MUX and GPIO Matrix

 

Register 5.49: DEDIC_GPIO_INTR_RLS_REG (0x0024)



DEDIC_GPIOO_INT_ENA The enable bit for DEDIC_GPIOO_INT_ST register. (RAV)
DEDIC_GPIO1_INT_ENA The enable bit for DEDIC_GPIO1_INT_ST register. (RAV)
DEDIC_GPIO2_INT_ENA The enable bit for DEDIC_GPIO2_INT_ST register. (RAV)
DEDIC_GPIO3_INT_ENA The enable bit for DEDIC_GPIO3_INT_ST register. (RAV)
DEDIC_GPIO4_INT_ENA The enable bit for DEDIC_GPIO4_INT_ST register. (RAV)
DEDIC_GPIO5_INT_ENA The enable bit for DEDIC_GPIOS_INT_ST register. (RAV)
DEDIC_GPIO6_INT_ENA The enable bit for DEDIC_GPIO6_INT_ST register. (RAV)

DEDIC_GPIO7_INT_ENA The enable bit for DEDIC_GPIO7_INT_ST register. (RAV)

Espressif Systems 188 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.50: DEDIC_GPIO_INTR_ST_REG (0x0028)


DEDIC_GPIOO_INT_ST This is the status bit for DEDIC_GPIOO_INT RAW when
DEDIC_GPIOO_INT_ENA is set to 1. (RO)

DEDIC_GPIO1_INT_ST This is the status bit for DEDIC_GPIO1_INT.RAW when
DEDIC_GPIO1_INT_ENA is set to 1. (RO)

DEDIC_GPIO2_INT_ST This is the status bit for DEDIC_GPIO2_INT RAW when
DEDIC_GPIO2_INT_ENA is set to 1. (RO)

DEDIC_GPIO3_INT_ST This is the status bit for DEDIC_GPIOS_INT RAW when
DEDIC_GPIOS3_INT_ENA is set to 1. (RO)

DEDIC_GPIO4_INT_ST This is the status bit for DEDIC_GPIO4_INT. RAW when
DEDIC_GPIO4_INT_ENA is set to 1. (RO)

DEDIC_GPIO5_INT_ST This is the status bit for DEDIC_GPIOS_INT. RAW when
DEDIC_GPIO5S_INT_ENA is set to 1. (RO)

DEDIC_GPIO6_INT_ST This is the status bit for DEDIC_GPIO6_INT. RAW when
DEDIC_GPIO6_INT_ENA is set to 1. (RO)

DEDIC_GPIO7_INT_ST This is the status bit for DEDIC_GPIO7_INT RAW when
DEDIC_GPIO7_INT_ENA is set to 1. (RO)

Espressif Systems 134 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.51: DEDIC_GPIO_INTR_CLR_REG (0x002C)

 

 

 

 

 

 

 

[1 elves ]«[e]e]: [eo]
jo9 9000000000000 00 00 00 0 0 ofofofofo]ol[o]o]o IReset
DEDIC_GPIOO_INT_CLR_ Set this bit to clear the DEDIC_GPIOO_INT_RAW interrupt. (WO)
DEDIC_GPIO1_INT_CLR Set this bit to clear the DEDIC_GPIO1_INT_RAW interrupt. (WO)
DEDIC_GPIO2_INT_CLR Set this bit to clear the DEDIC_GPIO2_INT_RAW interrupt. (WO)
DEDIC_GPIO3_INT_CLR Set this bit to clear the DEDIC_GPIO3_INT_RAW interrupt. (WO)
DEDIC_GPIO4_INT_CLR Set this bit to clear the DEDIC_GPIO4_INT_RAW interrupt. (WO)
DEDIC_GPIO5_INT_CLR Set this bit to clear the DEDIC_GPIO5_INT_RAW interrupt. (WO)
DEDIC_GPIO6_INT_CLR Set this bit to clear the DEDIC_GPIO6_INT_RAW interrupt. (WO)
DEDIC_GPIO7_INT_CLR Set this bit to clear the DEDIC_GPIO7_INT_RAW interrupt. (WO)
5.15.5 RTC 1IO MUX Registers
Register 5.52: RTCIO_RTC_GPIO_OUT_REG (0x0000)
g
o
sO”
S
0” sf
& E
| 31 10 | 9 o |
| 0 [o0 0 0 0 0 0 0 2 OfReset

 

RTCIO_GPIO_OUT_DATA GPIOO ~ 21 output register. BittO corresponds to GPIOO, bit11 corre-
sponds to GPIO1, etc. (RAY)

Espressif Systems 135 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.53: RTCIO_RTC_GPIO_OUT_W1TS_REG (0x0004)

 

 

 

&
ev
f
oO
307
0” se
& &
[1 1o[» o|
| 0 [o0 0 0 0 0 0 0 2 OfReset

 

RTCIO_GPIO_OUT_DATA_W1TS GPIOO~ 21 output set register. If the value 1 is written to a bit here,
the corresponding bit in RTCIO_RTC_GPIO_OUT_REG will be set to 1. Recommended operation:
use this register to set RTCIO_RTC_GPIO_OUT_REG. (WO)

Register 5.54: RTCIO_RTC_GPIO_OUT_W1TC_REG (0x0008)
 

 

RTCIO_GPIO_OUT_DATA_W1TC GPIOO ~ 21 output clear register. If the value 1 is written to a
bit here, the corresponding bit in RTCIO_RTC_GPIO_OUT_REG will be cleared. Recommended
operation: use this register to clear RTCIO_RTC_GPIO_OUT_REG. (WO)

Register 5.55: RTCIO_RTC_GPIO_ENABLE_REG (0x000C)
| 0 [o 0000000 0 O]Reset

 

RTCIO_GPIO_ENABLE GPIOO ~ 21 output enable. Bit1O corresponds to GPIOO, bit1 1 corresponds
to GPIO1, etc. If the bit is set to 1, it means this GPIO pad is output. (RAM)

Espressif Systems 136 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.56: RTCIO_RTC_GPIO_ENABLE_W1TS_REG (0x0010)

 

 

 

x
NZ
Ss
307
oO” &
& E
[1 1o[» o|
| 0 [o0 0 0 0 0 0 0 2 OfReset

 

RTCIO_GPIO_ENABLE_W1TS GPIOO~ 21 output enable set register. If the value 1 is written to a bit
here, the corresponding bit in RTCIO_RTC_GPIO_ENABLE_REG will be set to 1. Recommended
operation: use this register to set RTCIO_RTC_GPIO_ENABLE_REG. (WO)

Register 5.57: RTCIO_RTC_GPIO_ENABLE_W1TC_REG (0x0014)

31 1o}9 o
0 0 0 00 0 0 0 0 0 OfReset

 

 

 

 

RTCIO_GPIO_ENABLE_W1TC GPIOO ~ 21 output enable clear register. If the value 1 is written to
a bit here, the corresponding bit in RTCIO_RTC_GPIO_ENABLE_REG will be cleared. Recom-
mended operation: use this register to clear RTCIO_RTC_GPIO_ENABLE_REG. (WO)

Register 5.58: RTCIO_RTC_GPIO_STATUS_REG (0x0018)

 

 

 

s
se
O7%
oe ra
&€ &
E op ]
| 0 [o 0000 000 0 O]Reset

 

RTCIO_GPIO_STATUS_INT GPIOO ~ 21 interrupt status register. Bit10 corresponds to GPIOO,
bitt1 corresponds to GPIO1, etc. This register should be used together with RIT-
CIO_RTC_GPIO_PIN7_INT_TYPE in RTCIO_RTC_GPIO_PINo_REG. 0: no interrupt; 1: corre-
sponding interrupt. (RAM)

Espressif Systems 187 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.59: RTCIO_RTC_GPIO_STATUS_W1TS_REG (0x001C)

 

 

 

x
oS
4
&
of
<
O7 &
“Oo &
< x
[a1 ro] o|
| 0 jo0 0 9 0 0 0 0 0 OlReset

 

RTCIO_GPIO_STATUS_INT_W1TS GPIOO ~ 21 interrupt set register. If the value 1 is written to a
bit here, the corresponding bit in RTCIO_GPIO_STATUS_INT will be set to 1. Recommended
operation: use this register to set RTCIO_GPIO_STATUS_INT. (WO)

Register 5.60: RTCIO_RTC_GPIO_STATUS_W1TC_REG (0x0020)

 

 

 

x
oS
4
&
of
<
O7 &
“Oo &
< x
[a1 ro] o|
| 0 jo0 0 9 0 0 0 0 0 OlReset

 

RTCIO_GPIO_STATUS_INT_W1TC GPIOO ~ 21 interrupt clear register. If the value 1 is written to
a bit here, the corresponding bit in RTCIO_GPIO_STATUS_INT will be cleared. Recommended
operation: use this register to clear RTCIO_GPIO_STATUS_INT. (WO)

Register 5.61: RTCIO_RTC_GPIO_IN_REG (0x0024)



Dummy


 

Register 5.62: RTCIO_RTC_GPIO_PIN7_REG (0x0028)




 (7: 0-21)
 

 

7
re ¢
7 & &
wos oO”
wr’ we
0” 30” sO”
S & S xY Ss
rs O7 Ren & 7 &
& L€ € € €
[a1 ni] 1 | ie ate fa o|
jo9 9000000000000 00 00 0 ofof o [0 0 6 ofo]o  olReset

 

RTCIO_GPIO_PIN»_PAD_DRIVER Pad driver selection. 0: normal output; 1: open drain. (RAV)

RTCIO_GPIO_PIN»°_INT_TYPE GPIO interrupt type selection. 0: GPIO interrupt disabled; 1: rising
edge trigger; 2: falling edge trigger; 3: any edge trigger; 4: low level trigger; 5: high level trigger.

(RW)

RTCIO_GPIO_PIND_WAKEUP_ENABLE GPIO wake-up enable. This will only wake up ESP32-S2
from Light-sleep. (R/W)

Espressif Systems 189 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.63: RTCIO_TOUCH_PAD”_REG (7: 0-14) (0x0084+4*n)

 

 

 

SIS FSO NM SE SISS
PLP PLP O POHL
/ 7 7 7 7 / 7 QV NO? OY, / OY, NO?
& Oe con & So o SSNS S
Ee e&e €& &EEE € EEEE
[ st [20 23| 2 | 2 | 25 [25 23| 2 | 21 | 20 [19 |e wf [|u| s[e o|
[o| 2 [i ]ofo] Ox4. [ofofo]o] 0 [ofofojofo o 0 0 9 0 9 0 0 0 0 0 OfReset

 

RTCIO_TOUCH_PADn_FUN_IE Input enable in normal execution. (RAM)
RTCIO_TOUCH_PADn_SLP_OE Output enable in sleep mode. (RAM)
RTCIO_TOUCH_PADn_SLP_IE Input enable in sleep mode. (R/W)
RTCIO_TOUCH_PADn_SLP_SEL 0: no sleep mode; 1: enable sleep mode. (R/W)
RTCIO_TOUCH_PADn_FUN_SEL Function selection. (RAM)

RTCIO_TOUCH_PADn_MUX_SEL Connect the RTC pad input to digital pad input. 0 is available.
(RAV)

RTCIO_TOUCH_PADr_XPD Touch sensor power on. (RAV)
RTCIO_TOUCH_PADn_TIE_OPT The tie option of touch sensor. 0: tie low; 1: tie high. (RAV)
RTCIO_TOUCH_PADn_START Start touch sensor. (RW)

RTCIO_TOUCH_PADn_DAC Touch sensor slope control. 3-bit for each touch pad, defaults to 0x4.
(RAV)

RTCIO_TOUCH_PADn_RUE Pull-up enable of the pad. 1: internal pull-up enabled, O: internal pull-up
disabled. (RAM)

RTCIO_TOUCH_PADn_RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
pull-down disabled. (RAV)

RTCIO_TOUCH_PADn_DRV Select the drive strength of the pad. 0: ~5 mA: 1: ~10 mA: 2: ~20 mA;
3: ~40 mA. (RAV)

Espressif Systems 140 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

Register 5.64: RTCIO_XTAL_32P_PAD_REG (0x00C0)

s\ xX xy tb Qe’ FO? SS
S Le PS’ SHH S
So BS? So Lo AS RB’
& 42 HYD! & o' 4 42 OHH! &
& 6O Oe S ee xe OS S
CS WS & QV Nees &

 

[ a1 [x 29 | 28 | 27 | 26 20] 19 [8 v7] 6 | a5 | w | 13 [2 o|

[0] 2 [0] oo 0 0 0 0 0 of o | 0 [o]ofo]ofo 00000000000 O]Reset

 

 

 

RTCIO_X32P_FUN_IE Input enable in normal execution. (RAV)
RTCIO_X32P_SLP_OE Output enable in sleep mode. (R/W)
RTCIO_X32P_SLP_IE Input enable in sleep mode. (RAV)
RTCIO_X32P_SLP_SEL 1: enable sleep mode; 0: no sleep mode (RAW)
RTCIO_X32P_FUN_SEL Function selection (R/W)
RTCIO_X32P_MUX_SEL 1: use RTC GPIO, 0: use digital GPIO (R/V)

RTCIO_X32P_RUE Paull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled.

(RAV)
RTCIO_X32P_RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal pull-down
disabled. (RAM)
RTCIO_X32P_DRV Select the drive strength of the pad. 0: ~5 mA: 1: ~10 mA: 2: ~20 mA; 3: ~40
mA. (RAW)
Espressif Systems 141 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.65: RTCIO_XTAL_32N_PAD_REG (0x00C4)

YY Le &

ge KY

SO SS SIS’ 88.8
DY YS < 9 <
ey Sop’ ey ey Sion’

x SP PS N BPP PSP SP 05 N
& - oto? § O% 07 04040407 §
PS KOKO g SS KOKOKOKS g
Pe && f € & €€&é ¢

 

8
@
3
8
ny
&
Nu
Q
ny
a
y
3
6
&
ql
a

[ule o|

 

 

[o] 2 [o]ofo 0 0 0 0 0 of o | 0 [ofofo]ofo 00000000000 O|Reset

 

RTCIO_X32N_ FUN_IE Input enable in normal execution. (RAV)
RTCIO_X32N_ SLP_OE Output enable in sleep mode. (RAV)
RTCIO_X32N SLP_IE Input enable in sleep mode. (RAV)

RTCIO_X32N SLP_SEL 1: enable sleep mode; 0: no sleep mode (RAV)
RTCIO_X32N_FUN_SEL Function selection (RV)
RTCIO_X32N_MUX_SEL 1: use RTC GPIO, 0: use digital GPIO (RAW)

RTCIO_X32N RUE Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal pull-up disabled.

(RAV)
RTCIO_X32N_ RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal pull-down
disabled. (RAM)
RTCIO_X32N_DRV Select drive strength of the pad. 0: ~5 mA; 1: ~10 mA; 2: ~20 mA; 3: ~40 mA,
(RAV)
Espressif Systems 142 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.66: RTCIO_PAD_DAC1_REG (0x00C8)


S LS PS SSSSHEL x
Ov OGY” OY NZ XOXO. OGY GY’ oY
a & Ss S SK SF SOOO rw oe S
3 XC f 07.07 SO% O% O70 720 72070 O07 SO% x
& O OKO & O O OKO KO KOKO KO O &
CS SS & EC CEE EES € &
[ st [20 2| 2 | 27 [25 20 1 [1 7] as | is w[e]e] ufo 3[2 o|
[o| 2 [ofofo 0 00 0 0 of o| 0 [ofofo][ofo]o] 0 [o 0 O]Reset

 

RTCIO_PDAC1_DAC Configure DAC_1 output when RTCIO_PDAC1_DAC_XPD_FORCE is set to 1.
(RAV)

RTCIO_PDAC1_XPD DAC When RTCIO_PDAC1_DAC_XPD_FORCE is set to 1, 1: enable DAC_1
output; 0: disable DAC_1 output. (RAV)

RTCIO_PDAC1_DAC_XPD_FORCE 1: use RTCIO_PDAC1_XPD_DAC to control DAC_1 output; 0:
use SAR ADC FSM to control DAC_1 output. (RAY)

RTCIO_PDAC1_FUN_IE Input enable in normal execution. (R/V)
RTCIO_PDAC1_SLP_OE Output enable in sleep mode. (RW)
RTCIO_PDAC1_SLP_IE Input enable in sleep mode. (R/W)
RTCIO_PDAC1_SLP_SEL 1: enable sleep mode; 0: no sleep mode. (RAV)
RTCIO_PDAC1_FUN_SEL DAC_1 function selection. (RAY)
RTCIO_PDAC1_MUX_SEL 1: use RTC GPIO, 0: use digital GPIO (R/W)

RTCIO_PDAC1_RUE Pull-up enable of the pad. 1: internal pull-up enabled, 0: internal pull-up dis-
abled. (R/V)

RTCIO_PDAC1_RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal pull-
down disabled. (R/W)

RTCIO_PDAC1_DRV_ Select drive strength of the pad. 0: ~5 mA; 1: ~10 mA; 2: ~20 mA; 3: ~40
mA. (RAW)

Espressif Systems 143 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.67: RTCIO_PAD_DAC2_REG (0x00CC)

 

 

 

xy
&
<
YY My ve OF
KM YE KY +
SF SS WS’ SSS SKK’ sx
oh he Oe YM Gy’ oh
PSooe Kp oESSE® og 2
SX XO & OY KOK OKO KOKO S &
CE SS & OS CEE ESE &€ &
[ st [20 2| 2 | 27 [25 20 1 [1 w]e [as | ue [as [22 [1 | 0 3[2 o|
[o| 2 [ofofo o 0 0 0 0 ofof 0 [ofofo][ofo]o] 0 [o 0 O]Reset

 

RTCIO_PDAC2_ DAC Configure DAC_2 output when RTCIO_PDAC2_DAC_XPD_FORCE is set to 1.
(RAV)

RTCIO_PDAC2_XPD_DAC When RTCIO_PDAC2_DAC_XPD_FORCE is set to 1, 1: enable DAC_2
output; 0: disable DAC_2 output. (RAV)

RTCIO_PDAC2_DAC_XPD_FORCE 1: use RTCIO_PDAC2_XPD_DAC to control DAC_2 output; O:
use SAR ADC FSM to control DAC_2 output. (RAW)

RTCIO_PDAC2_FUN_IE Input enable in normal execution. (R/V)
RTCIO_PDAC2_SLP_OE Output enable in sleep mode. (R/W)
RTCIO_PDAC2_SLP_IE Input enable in sleep mode. (R/W)
RTCIO_PDAC2_ SLP_SEL 1: enable sleep mode; 0: no sleep mode (R/W)
RTCIO_PDAC2_FUN_SEL DAC_2 function selection. (RAY)
RTCIO_PDAC2_MUX_SEL 1: use RTC GPIO, 0: use digital GPIO. (RAV)

RTCIO_PDAC2_RUE Pull-up enable of the pad. 1: internal pull-up enabled, 0: internal pull-up dis-
abled. (R/V)

RTCIO_PDAC2_RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal pull-
down disabled. (R/W)

RTCIO_PDAC2_DRV Select drive strength of the pad. 0: ~5 mA; 1: ~10 mA; 2: ~20 mA; 3: ~40
mA. (RAW)

Espressif Systems 144 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.68: RTCIO_RTC_PAD19_REG (0x00D0)

 

 

 

YY Me &
S SE KY
$ && NS SEES
227 907007 MDH 97370970 7,07
S 838 8 S& S88
O7 OZ 7 7 O7 O%Z%0 KOO 7
E € &€ & &€ &PEE &
[ st [20 2| 2 | 27 [25 20 1 [1 wf [|u| s[e o|
[o| 2 [iJofe o 0 0 0 o ofof 0 [ofofojofo o 0 0 9 0 9 0 0 0 0 0 OfReset

 

RTCIO_RTC_PAD19 FUN_IE Input enable in normal execution. (RW)
RTCIO_RTC_PAD19 SLP_OE Output enable in sleep mode. (R/W)
RTCIO_RTC_PAD19 SLP_IE Input enable in sleep mode. (R/W)
RTCIO_RTC_PAD19 SLP_SEL 1: enable sleep mode; 0: no sleep mode. (RAW)
RTCIO_RTC_PAD19_FUN_SEL Function selection (RAV)
RTCIO_RTC_PAD19_MUX_SEL 1: use RTC GPIO, 0: use digital GPIO (R/W)

RTCIO_RTC_PAD19 RUE Pull-up enable of the pad. 1: internal pull-up enabled, O: internal pull-up
disabled. (RAM)

RTCIO_RTC_PAD19 RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
pull-down disabled. (RAV)

RTCIO_RTC_PAD19_DRV Select drive strength of the pad. O: ~5 mA; 1: ~10 mA; 2: ~20 mA; 3:
~40 mA. (RAW)

Espressif Systems 145 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.69: RTCIO_RTC_PAD20_REG (0x00D4)

 

 

 

YY Me &
S SE KY
\ Ye & te 7 FOI RQ TS!
S Le PS SSSS
PD Pap’ Po Po PAPEL”
SS SS SIS
O7 OZ 7 7 O7 O%Z%0 KOO 7
& of ofS a of $ osososoe &
E € &€ & &€ &PEE &
[ st [20 2| 2 | 27 [25 20 1 [1 wf [|u| s[e o|
[o| 2 [iJofe o 0 0 0 o ofof 0 [ofofojofo o 0 0 9 0 9 0 0 0 0 0 OfReset

 

RTCIO_RTC_PAD20 FUN_IE Input enable in normal execution. (RW)
RTCIO_RTC_PAD20 SLP_OE Output enable in sleep mode. (R/W)
RTCIO_RTC_PAD20 SLP_IE Input enable in sleep mode. (R/W)
RTCIO_RTC_PAD20 SLP_SEL 1: enable sleep mode; 0: no sleep mode. (RAV)
RTCIO_RTC_PAD20 FUN_SEL Function selection. (RW)
RTCIO_RTC_PAD20_MUX_SEL 1: use RTC GPIO, 0: use digital GPIO. (RW)

RTCIO_RTC_PAD20 RUE Pull-up enable of the pad. 1: internal pull-up enabled; O: internal pull-up
disabled. (RAM)

RTCIO_RTC_PAD20 RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
pull-down disabled. (RAV)

RTCIO_RTC_PAD20_DRV Select drive strength of the pad. O: ~5 mA; 1: ~10 mA; 2: ~20 mA; 3:
~40 mA. (RAW)

Espressif Systems 146 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

 

Register 5.70: RTCIO_RTC_PAD21_REG (0x00D8)



YY Me &
YM VE OY
£ ss MS SIS
ye ag? ye ae pio?
SS SS SS
O7 OZ 7 7 O7 O%Z%0 KOO 7
& oS KF S of oF SSE &
E € &€ & &€ &PEE &
[ st [20 2| 2 | 27 [25 20 1 [1 wf [|u| s[e o|
[o| 2 [iJofe o 0 0 0 o ofof 0 [ofofojofo o 0 0 9 0 9 0 0 0 0 0 OfReset

 

RTCIO_RTC_PAD21_FUN_IE Input enable in normal execution. (RW)
RTCIO_RTC_PAD21_SLP_OE Output enable in sleep mode. (R/W)
RTCIO_RTC_PAD21_ SLP_IE Input enable in sleep mode. (R/W)
RTCIO_RTC_PAD21_SLP_SEL 1: enable sleep mode; 0: no sleep mode. (RAW)
RTCIO_RTC_PAD21_FUN_SEL Function selection. (RW)
RTCIO_RTC_PAD21_MUX_SEL 1: use RTC GPIO,0: use digital GPIO. (R/W)

RTCIO_RTC_PAD21_RUE Paull-up enable of the pad. 1: internal pull-up enabled; O: internal pull-up
disabled. (RAM)

RTCIO_RTC_PAD21_RDE Pull-down enable of the pad. 1: internal pull-down enabled; 0: internal
pull-down disabled. (RAV)

RTCIO_RTC_PAD21_DRV_ Select drive strength of the pad. O: ~5 mA; 1: ~10 mA; 2: ~20 mA; 3:

 

 

 

~40 mA. (RAW)
Register 5.71: RTCIO_XTL_EXT_CTR_REG (0x00E0)

[1 ar|2s o|
| 0 joo 0 0000000000009 00900 00 09 0 0 0 0 OlReset

 

RTCIO_XTL_EXT_CTR_SEL Select the external crystal power down enable source to get into
sleep mode. 0: select GPIOO; 1: select GPIO1, etc. The input value on this pin XOR
RTC_CNTL_EXT_XTL_CONF_REGJS0] is the crystal power down enable signal. (RAV)

Espressif Systems 147 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
5. 1O MUX and GPIO Matrix

Register 5.72: RTCIO_SAR_I2C_lO_REG (0x00E4)
RS ok &
Oo? oF
6X gO &
& «
31 30/29 28] 27 oO
0 0 fo o0000000000000000000 000 0 0 0 0 O]peset

 

 

RTCIO_SAR_I2C SCL SEL Selects a pad the RTC I2C SCL signal connects to. 0: use TOUCH
PADO; 1: use TOUCH PAD2. (RAW)

RTCIO_SAR_I2C SDA SEL Selects a pad the RTC |I2C SDA signal connects to. 0: use TOUCH
PAD1; 1: use TOUCH PADS. (RAW)

Espressif Systems 148

ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

6. System Registers

6.1 Overview

The ESP82-S82 integrates a large number of peripherals, and enables the control of individual peripherals to
achieve optimal characteristics in performance-vs-power-consumption scenarios. Specifically, ESP32-S2 has a
various of system configuration registers that can be used for the chip’s clock management (clock gating), power
management, and the configuration of peripherals and core-system modules. This chapter lists all these system
registers and their functions.

6.2 Features
ESP32-S2 system registers can be used to control the following peripheral blocks and core modules:

* System and memory

* Reset and clock

® Interrupt matrix

* eFuse controller

° Low-power management

* Peripheral clock gating and reset

6.3 Function Description
6.3.1 System and Memory Registers

The following registers are used for system and memory configuration, such as cache configuration and memory
remapping. For additional information, please refer to Chapter 1 System and Memory.

© SYSTEM _ROM_CTRL_O_REG

© SYSTEM_ROM_CTRL_1_REG

SYSTEM_SRAM_CTRL_O_REG

SYSTEM_SRAM_CTRL_1_REG

SYSTEM_SRAM_CTRL_2_REG

SYSTEM_RSA_PD_CTRL_REG

SYSTEM_MEM_PD_MASK_REG

SYSTEM_CACHE_CONTROL_REG

SYSTEM_BUSTOEXTMEM_ENA_ REG

© SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG

Espressif Systems 149 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

ROM Power Consumption Control

Registers SYSTEM_ROM_CTRL_O_REG and SYSTEM_ROM_CTRL_1_REG can be used to control the power
consumption of ESP382-S2’s ROM. Specifically:

® Setting different bits of the SYSTEM _ROM_FO field in register SYSTEM_ROM_CTRL_O_REG forces on the
clock gates of different blocks of ROM.

® Setting different bits of the SYSTEM_ROM_FORCE_PD field in register SYSTEM_ROM_CTRL_1_REG
powers down different blocks of internal ROM.

* Setting different bits of the SYSTEM_ROM_FORCE_PU field in register SYSTEM_ROM_CTRL_1_REG
powers up different blocks of internal ROM.

For detailed information about the controlling bits of different blocks, please see Table 31 below.

Table 31: ROM Controlling Bit

 

 

 

 

 

 

 

 

 

ROM Lowest Address Highest Address1 | Lowest Address2 | Highest Address2 | Controlling Bit
BlockO 0x4000_0000 O0x4000_FFFF - - BitO
Block1 0x4001_ 2000 0x4001_FFFF Ox3FFA_0000 OxSFFA_FFFF Bitt

 

SRAM Power Consumption Control

Registers SYSTEM_SRAM_CTRL_O_REG, SYSTEM_SRAM_CTRL_1_REG, and SYSTEM_SRAM_CTRL_2_ REG
can be used to control the power consumption of ESP382-S2’s internal SRAM. Specifically,

® Setting different bits of the SYSTEM _SRAM_FO field in register SYSTEM _SRAM_CTRL_O_REG forces on
the clock gates of different blocks of internal SRAM.

* Setting different bits of the SYSTEM_SRAM_FORCE_PD field in register SYSTEM_SRAM_CTRL_1_REG

powers down different blocks of internal SRAM.

® Setting different bits of the SYSTEM_SRAM_FORCE_PU field in register SYSTEM_SRAM_CTRL_2_REG
powers up different blocks of internal SRAM.

For detailed information about the controlling bits of different blocks, please see Table 32 below.

Table 32: SRAM Controlling Bit

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

SRAM Lowest Address Highest Address1 | Lowest Address2 | Highest Address2 | Controlling Bit
BlockO 0x4002_0000 0x4002_1FFF Ox3FFB_O0000 Ox3FFB_1FFF BitO
Block1 0x4002_2000 0x4002_3FFF Ox3FFB_2000 Ox3FFB_3FFF Bitt
Block2 0x4002_4000 0x4002_5FFF Ox3FFB_4000 Ox3FFB_5FFF Bit2
Block3 0x4002_6000 0x4002_7FFF Ox3FFB_6000 Ox3FFB_7FFF Bits
Block4 0x4002_8000 0x4002_BFFF Ox3FFB_8000 Ox3FFB_BFFF Bit4
BlockS 0x4002_CO00 0x4002_FFFF Ox3FFB_CO00 Ox3FFB_FFFF BitS
Blocké 0x4003_0000 0x4003_SFFF Ox3FFC_O000 Ox3FFC_SFFF Bité6
Block? 0x4003_4000 0x4003_7FFF Ox3FFC_4000 Ox3FFC_7FFF Bit7
Block8& 0x4003_8000 0x4003_BFFF Ox3FFC_8000 Ox3FFC_BFFF Bits
Block9 0x4003_CO000 0x4003_FFFF Ox3FFC_CO0O Ox3FFC_FFFF Bit9
Block10 0x4004_0000 0x4004_3FFF Ox3FFD_O0000 Ox3FFD_SFFF Bit10

 

Espressif Systems

150

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 

 
6. System Registers

 

 

Block11

0x4004_4000

0x4004_7FFF

OxSFFD_4000

OxSFFD_7FFF

Bitt4

 

Block12

0x4004_8000

0x4004_BFFF

Ox3FFD_8000

OxSFFD_BFFF

Biti2

 

Block13

0x4004_CO00

0x4004_FFFF

OxSFFD_CO000

Ox3FFD_FFFF

Bitts

 

Block14

0x4005_0000

0x4005_SFFF

Ox3FFE_0000

OxSFFE_SFFF

Biti4

 

Block15

Ox4005_4000

0x4005_7FFF

OxSFFE_4000

OxSFFE_/7FFF

BittS

 

Block16

Ox4005_8000

0x4005_BFFF

OxSFFE_8000

OxSFFE_BFFF

Biti6

 

Block17

0x4005_CO00

0x4005_FFFF

OxSFFE_CO00

Ox3FFE_FFFF

Bitt7

 

Block18

O0x4006_0000

0x4006_SFFF

OxSFFF_0000

Ox3FFF_SFFF

Bitts

 

Block19

Ox4006_4000

0x4006_7FFF

OxSFFF_4000

Ox3FFF_7FFF

Bit19

 

Block20

O0x4006_8000

0x4006_BFFF

OxSFFF_8000

Ox3FFF_BFFF

Bit20

 

 

Block21

 

Ox4006_CO00

 

O0x4006_FFFF

 

OxSFFF_CO00

 

Ox3FFF_FFFF

 

Bit21

 

6.3.2 Reset and Clock Registers

The following registers are used for reset and clock. For additional information, please refer to Chapter 2 Reset

and Clock.

° SYSTEM_CPU_PER_CONF_REG

° SYSTEM_SYSCLK_CONF_REG

°* SYSTEM_BT_LPCK_DIV_FRAC_REG

6.3.3 Interrupt Matrix Registers

The following registers are used for generating the CPU interrupt signals for the interrupt matrix. For additional
information, please refer to Chapter 4 interrupt Matrix

® SYSTEM_CPU_INTR_FROM_CPU_0_REG

© SYSTEM_CPU_INTR_FROM_CPU_1_REG

*® SYSTEM_CPU_INTR_FROM_CPU_2_REG

© SYSTEM_CPU_INTR_FROM_CPU_3_REG

6.3.4 JTAG Software Enable Registers

The following registers are used for revoking the temporary disable of eFuse to JTAG.

© SYSTEM_JTAG_CTRL_O_REG

© SYSTEM_JTAG_CTRL_1_REG

Espressif Systems

SYSTEM_JTAG_CTRL_2_REG
SYSTEM_JTAG_CTRL_3_REG
SYSTEM_JTAG_CTRL_4_ REG
SYSTEM_JTAG_CTRL_5_REG
SYSTEM_JTAG_CTRL_6_REG

SYSTEM_JTAG_CTRL_7_REG

151

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
6. System Registers

 

6.3.5 Low-power Management Registers
The following registers are used for low-power management.

* SYSTEM_RTC_FASTMEM_CONFIG_REG

* SYSTEM_RTC_FASTMEM_CRC_REG

6.3.6 Peripheral Clock Gating and Reset Registers

The following registers are used for controlling the clock gating and reset of different peripherals. Details can be

seen in Table 33.

© SYSTEM_CPU_PERI_CLK_EN_REG

*¢ SYSTEM_CPU_PERI_LRST_EN_REG

° SYSTEM_PERIP_CLK_ENO_REG

°¢ SYSTEM_PERIP_RST_ENO_REG

© SYSTEM_PERIP_CLK_EN1_REG

°¢ SYSTEM_PERIP_RST_EN1_REG

Table 33: Peripheral Clock Gating and Reset Bits

 

 

 

 

 

 

 

Peripheral Clock Enabling Bit" Reset Controlling Bit??

CPU Peripherals SYSTEM_CPU_PERI_CLK_EN_REG SYSTEM_CPU_PERI_RST_EN_REG
DEDICATED GPIO SYSTEM_CLK_EN_DEDICATED_GPIO | SYSTEM_RST_EN_DEDICATED_GPIO
Peripherals SYSTEM_PERIP_CLK_ENO_REG SYSTEM_PERIP_RST_ENO_REG
Timers SYSTEM_TIMERS_CLK_EN SYSTEM_TIMERS_RST

Timer GroupO SYSTEM_TIMERGROUP_CLK_EN SYSTEM_TIMERGROUP_RST

Timer Group1 SYSTEM_TIMERGROUP1_CLK_EN SYSTEM_TIMERGROUP1_RST

 

System Timer

SYSTEM_SYSTIMER_CLK_EN

SYSTEM_SYSTIMER_RST

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

UARTO SYSTEM_UART_CLK_EN SYSTEM_UART_RST
UART1 SYSTEM_UART1_CLK_EN SYSTEM_UART1_RST
UART MEM SYSTEM_UART_MEM_CLK_EN + SYSTEM_UART_MEM_RST
SPIO, SPI1 SYSTEM_SPI01_CLK_EN SYSTEM_SPI01_RST
SPl2 SYSTEM_SPI2_CLK_EN SYSTEM_SPI2_RST

SPIS SYSTEM_SPIS_DMA_CLK_EN SYSTEM_SPI3_RST

SPI4 SYSTEM_SPI4_CLK_EN SYSTEM_SPI4_RST

SPl2 DMA SYSTEM_SPI2_DMA_CLK_EN SYSTEM_SP|2_DMA_RST
SPI3 DMA SYSTEM_SPIS_DMA_CLK_EN SYSTEM_SPI3_DMA_RST
12CO SYSTEM_l2C_EXTO_CLK_EN SYSTEM_I2C_EXTO_RST
1201 SYSTEM_l2C_EXT1_CLK_EN SYSTEM_I2C_EXT1_RST
1280 SYSTEM_|I2S0_CLK_EN SYSTEM_I2S0_RST

281 SYSTEM_|2S1_CLK_EN SYSTEM_|I2S1_RST

TWAI Controller SYSTEM_CAN_CLK_EN SYSTEM_CAN_RST
UHCIO SYSTEM_UHCIO_CLK_EN SYSTEM_UHCIO_RST
UHCI SYSTEM_UHCI1_CLK_EN SYSTEM_UHCI1_RST
USB SYSTEM_USB_CLK_EN SYSTEM_USB_RST

RMT SYSTEM_RMT_CLK_EN SYSTEM_RMT_RST

 

Espressif Systems

152

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
6. System Registers

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

PCNT SYSTEM_PCNT_CLK_EN SYSTEM_PCNT_RST

PWMO SYSTEM_PWMO0_CLK_EN SYSTEM_PWMO_RST

PWM1 SYSTEM_PWM1_CLK_EN SYSTEM_PWM1_RST

PWM2 SYSTEM_PWM2_CLK_EN SYSTEM_PWM2_RST

PWMS3 SYSTEM_PWMS3_CLK_EN SYSTEM_PWM3_RST

LED_PWM Controller SYSTEM_LEDC_CLK_EN SYSTEM_LEDC_RST

eFuse SYSTEM_EFUSE_CLK_EN SYSTEM_EFUSE_RST

APB SARADC SYSTEM_APB_SARADC_CLK_EN SYSTEM_APB_SARADC_RST
ADC2 ARB SYSTEM_ADC2_ARB_CLK_EN SYSTEM_ADC2_ARB_RST

WDG SYSTEM_WDG_CLK_EN SYSTEM_WDG_RST
Accelerators SYSTEM_PERIP_CLK_EN1_REG SYSTEM_PERIP_RST_EN1_REG
DMA SYSTEM_CRYPTO_DMA_CLK_EN SYSTEM_CRYPTO_DMA_RST °
HMAC SYSTEM_CRYPTO_HMAC_CLK_EN SYSTEM_CRYPTO_HMAC_RST
Digital Signature SYSTEM_CRYPTO_DS_CLK_EN SYSTEM_CRYPTO_DS_RST 7
RSA Accelerator SYSTEM_CRYPTO_RSA_CLK_EN SYSTEM_CRYPTO_RSA_RST
SHA Accelerator SYSTEM_CRYPTO_SHA_CLK_EN SYSTEM_CRYPTO_SHA_RST
AES Accelerator SYSTEM_CRYPTO_AES_CLK_EN SYSTEM_CRYPTO_AES_ RST

 

 

2
3. Reset registers are not cleared by hardware.
4

UART memory from entering the clock-gated state.

5. Crypto DMA is shared by AES and SHA accelerators.

1. Set the clock enable register to 1 to enable the clock, and to O to disable the clock;

. Set the reset enabling register to 1 to reset a peripheral, and to O to disable the reset.

. UART memory is shared by all UART peripherals, meaning having any active UART peripherals will prevent the

 

6. Resetting this bit also resets the SHA accelerator.

 

 

7. Resetting this bit also resets the AES, SHA, and RSA accelerators.

 

Espressif Systems 153 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
6. System Registers

 

6.4 Base Address

Users can access the system registers with base address, which can be seen in the following table. For more

information about accessing system registers, please see Chapter 1 System and Memory.

Table 34: System Register Base Address

 

Bus to Access Peripheral

Base Address

 

PeriBUS1

 

Ox3F4C0000

 

 

 

6.5 Register Summary

The addresses in the following table are relative to the system registers base addresses provided in Section

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

6.4.
Name | Description Address | Access
System and Memory Registers
SYSTEM_ROM_CTRL_O_REG System ROM configuration register O Ox0000 | RAV
SYSTEM_ROM_CTRL_1_REG System ROM configuration register 1 0x0004 | RAV
SYSTEM_SRAM_CTRL_O_REG System SRAM configuration register O Ox0008 | RAV
SYSTEM_SRAM_CTRL_1_REG System SRAM configuration register 1 Ox000C | RAV
SYSTEM_SRAM_CTRL_2_REG System SRAM configuration register 2 O0x0088 | RAV
SYSTEM_MEM_PD_MASK_REG Memory power-related controlling register (under | OxOO38C | RAV
low-sleep)
SYSTEM_RSA_PD_CTRL_REG RSA memory remapping register Ox0068 | RAV
SYSTEM_BUSTOEXTMEM_ENA_ REG EDMA enable register Ox006C | RAV
SYSTEM_CACHE_CONTROL_REG Cache control register 0x0070 | RAV
SYSTEM_EXTERNAL_DEVICE_ENCRYPT_ | External memory encrypt and decrypt controlling oxo074 | RW
DECRYPT_CONTROL_REG register
Reset and Clock Registers
SYSTEM_CPU_PER_CONF_REG CPU peripheral clock configuration register 0x0018 | RAV
SYSTEM_BT_LPCK_DIV_FRAC_REG Divider fraction configuration register for low- | Ox0054 | RAV
power clock
SYSTEM_SYSCLK_CONF_REG SoC clock configuration register Ox008C_ | Varies
Interrupt Matrix Registers
SYSTEM_CPU_INTR_FROM_CPU_O_REG | CPU interrupt controlling register O Ox0058 | RAV
SYSTEM_CPU_INTR_FROM_CPU_1_REG | CPU interrupt controlling register 1 Ox005C_ | RAV
SYSTEM_CPU_INTR_FROM_CPU_2 REG | CPU interrupt controlling register 2 Ox0060 | RAV
SYSTEM_CPU_INTR_FROM_CPU_3 REG | CPU interrupt controlling register 3 Ox0064 | RAV
JTAG Software Enable Registers
SYSTEM_JTAG_CTRL_O_REG JTAG configuration register 0 O0x001C | WO
SYSTEM_JTAG_CTRL_1_REG JTAG configuration register 1 0x0020 | WO
SYSTEM_JTAG_CTRL_2 REG JTAG configuration register 2 0x0024 | WO
SYSTEM_JTAG_CTRL_3_ REG JTAG configuration register 3 0x0028 | WO
SYSTEM_JTAG_CTRL_4_ REG JTAG configuration register 4 Ox002C | WO
SYSTEM_JTAG_CTRL_5 REG JTAG configuration register 5 0x0030 | WO
SYSTEM_JTAG_CTRL_6_REG JTAG configuration register 6 0x0034 | WO

 

 

 

 

 

Espressif Systems

154

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
6. System Registers

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
SYSTEM_JTAG_CTRL_7_REG JTAG configuration register 7 0x0038 | WO
Low-Power Management Registers
SYSTEM_RTC_FASTMEM_CONFIG_REG_ |} RTC fast memory configuration register 0x0078 | Varies
SYSTEM_RTC_FASTMEM_CRC_REG RTC fast memory CRC controlling register O0x007C | RO
Peripheral Clock Gating and Reset Registers
SYSTEM_CPU_PERI_CLK_EN_REG CPU peripheral clock enable register 0x0010 | RAV
SYSTEM_CPU_PERI_LRST_EN_REG CPU peripheral reset register 0x0014 | RAV
SYSTEM_PERIP_CLK_ENO_REG System peripheral clock (for hardware accelera- | Ox0040 | RAV

tors) enable register 0
SYSTEM_PERIP_CLK_EN1_REG System peripheral clock (for hardware accelera- | Ox0044 | RAV

tors) enable register 1
SYSTEM_PERIP_RST_ENO_REG System peripheral (hardware accelerators) reset | Ox0048 | RAV

register O
SYSTEM_PERIP_RST_EN1_REG System peripheral (hardware accelerators) reset | OxO04C | RAV

register 1
Version Register
SYSTEM_REG_DATE_REG Version control register | OxOFFC | RAV

6.6 Registers
The addresses below are relative to the system registers base addresses provided in Section 6.4.
Register 6.1: SYSTEM_ROM_CTRL_0_REG (0x0000)



 

SYSTEM_ROM_FO This field is used to force on clock gate of internal ROM. For details, please refer

to Table 31. (RAN)

Espressif Systems

155

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
6. System Registers

 

Register 6.2: SYSTEM_ROM_CTRL_1_REG (0x0004)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

» Q
Ow
gs gs
CO
oe oY
5 eS
& SS
Ce se X&
| 31 4 | 3 2 | 1 0 |
jo9 0000000000000 00000 0000 00 0 0f 3 | 0 IReset
SYSTEM_ROM_FORCE_PD This field is used to power down internal ROM. For details, please refer
to Table 31. (RAN)
SYSTEM_ROM_FORCE_PU This field is used to power up internal ROM. For details, please refer to
Table 31. (RAW)
Register 6.3: SYSTEM_SRAM_CTRL_0 REG (0x0008)
oO
ee
S 7
Ss x
€ Ss
31 22) 21 0
0000000 0 0 0 Oxf Reset
SYSTEM_SRAM_FO This field is used to force on clock gate of internal SRAM. For details, please
refer to Table 32. (RW)
Register 6.4: SYSTEM_SRAM_CTRL_1_REG (0x000C)
Q
ge
SF
<
&
S a
ss x
€ &
| 31 22 | 21 0 |
fo 0 0 0 0 000 0 9] 0 |Reset
SYSTEM_SRAM_FORCE_PD This field is used to power down internal SRAM. For details, please
refer to Table 32. (RW)
Espressif Systems 156 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
6. System Registers

 

Register 6.5: SYSTEM_CPU_PERI_CLK_EN_REG (0x0010)

 

ge

QO 4

&

SS
&
ov
Na
S Ss S

& ww &

S xs Ss

@ Ye €
31 8 7 6 5 o

 

 

oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO

Reset

 

 

 

 

 

SYSTEM_CLK_EN_DEDICATED_GPIO_ Set this bit to enable clock of DEDICATED GPIO module.

Register 6.6: SYSTEM_CPU_PERI_RST_EN_REG (0x001 4)

 

 

 

ge
Or
Oo
S
ov
S*
eS
& Oe oe
x LO oS
€ Se &
[1 af 7|s[s o|
jo9 9 09 000000900000 00000 0 0 0 ofi[1fo 0 0 0 0 OlReset

 

SYSTEM_RST_EN_DEDICATED_GPIO Set this bit to reset DEDICATED GPIO module. (RAV)

Espressif Systems

157 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
6. System Registers

 

Register 6.7: SYSTEM_CPU_PER_CONF_REG (0x0018)

 

 

 

 

SYSTEM_CPUPERIOD SEL This field is used to select the clock frequency of CPU or CPU period.
For details, please refer to Table 8 in Chapter 2 Reset and Clock. (RAN)

SYSTEM_PLL_FREQ SEL This fieldis used to select the PLL clock frequency based on CPU period.
For details, please refer to Table 8 in Chapter 2 Reset and Clock. (RAN)

SYSTEM_CPU_WAIT_MODE_FORCE_ON Set this bit to force on CPU wait mode. In this mode,
the clock gate of CPU is turned off until any interrupts happen. This mode could also be force on
via WAITI instruction. (RAM)

SYSTEM_CPU_WAITI_DELAY_NUM Sets the number of delay cycles to enter CPU wait mode after
a WAIT] instruction. (RAV)

Register 6.8: SYSTEM_JTAG_CTRL_0O_REG (0x001C)
 

SYSTEM_CANCEL EFUSE DISABLE JTAG_TEMPORARY_0 Stores the 0 to 31 bits of the 256
bits register used to cancel the temporary disable of eFuse to JTAG.

Espressif Systems 158 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

Register 6.9: SYSTEM_JTAG_CTRL_1_REG (0x0020)

 

 

 

ah
af
&
x
KO
Or
“
a
S
SO
§
<_
O
a
&
S
[z ‘|
| 0 |Reset

 

SYSTEM_CANCEL EFUSE DISABLE JTAG_TEMPORARY_1 Stores the 32 to 63 bits of the 256
bits register used to cancel the temporary disable of eFuse to JTAG.

Register 6.10: SYSTEM_JTAG_CTRL_2_REG (0x0024)

 

 

 

a %
ve
gs
&
KO
er”
>
Na
e
wx’
wo
Or
oe
mV
&
S
[a ]
| 0 |Reset

 

SYSTEM_CANCEL EFUSE DISABLE JTAG_TEMPORARY_2 Stores the 64 to 95 bits of the 256
bits register used to cancel the temporary disable of eFuse to JTAG.

Espressif Systems 159 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

Register 6.11: SYSTEM_JTAG_CTRL_3_REG (0x0028)

 

 

 

ah
af
&
x
KO
Or
“
a
S
SO
§
<_
O
a
&
S
[z ‘|
| 0 |Reset

 

SYSTEM_CANCEL EFUSE DISABLE _JTAG_TEMPORARY_3 Stores the 96 to 127 bits of the 256
bits register used to cancel the temporary disable of eFuse to JTAG.

Register 6.12: SYSTEM_JTAG_CTRL_4 REG (0x002C)

 

 

 

ok
é
&
KO
er”
>
Na
e
wx’
wo
Or
oe
mV
&
S
[a ]
| 0 |Reset

 

SYSTEM_CANCEL EFUSE DISABLE JTAG_TEMPORARY _4 Stores the 128 to 159 bits of the
256 bits register used to cancel the temporary disable of eFuse to JTAG.

Espressif Systems 160 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

Register 6.13: SYSTEM_JTAG_CTRL_5_REG (0x0030)

 

 

 

©
s\7
af
&
A.
KO
Or
“
a
S
SO
§
<_
O
a
&
S
[z ‘|
| 0 |Reset

 

SYSTEM_CANCEL EFUSE DISABLE JTAG_TEMPORARY_5 Stores the 160 to 191 bits of the
256 bits register used to cancel the temporary disable of eFuse to JTAG.

Register 6.14: SYSTEM_JTAG_CTRL_6_REG (0x0034)



ok
é
&
KO
er”
>
Na
e
wx’
wo
Or
oe
mV
&
S
[a ]
| 0 |Reset

 

SYSTEM_CANCEL EFUSE DISABLE JTAG_TEMPORARY _6 Stores the 192 to 223 bits of the
256 bits register used to cancel the temporary disable of eFuse to JTAG.

Espressif Systems 161 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

Register 6.15: SYSTEM_JTAG_CTRL_7_REG (0x0038)

 

 

 

“A
s\7
af
&
A.
KO
Or
“
a
S
SO
§
<_
O
a
&
S
[z ‘|
| 0 |Reset

 

SYSTEM_CANCEL EFUSE DISABLE JTAG_TEMPORARY_7 Stores the 224 to 255 bits of the
256 bits register used to cancel the temporary disable of eFuse to JTAG.

Register 6.16: SYSTEM_MEM_PD_MASK_REG (0x003C)

 

 

 

 

N-
we
ee
ov
>
g
S Y
x <
& &
[1 1] o |
joo 0 0 0000090000000 9 00900000 00 0 0 0 0 0 0[1 IReset
SYSTEM_LSLP_MEM_PD_MASK Set this bit to allow the memory to work as usual when the chip
enters the light-sleep state. (RAV)
Register 6.17: SYSTEM_PERIP_CLK_ENO_REG (0x0040)
SS
S S Ss
A > i Y
SSRs. $Y OS Ss Os x Ss S

“LY 7 YY 7 co,

S SLO OS es OS eS Hos sS 7 Sy oS S > Se LIS S S Sy
CESS ELS SKS OSS EEO z
f WR Ss S “ ¢ 4 Ls L Ls “ a “ f 4 4% f S Lf
SELLS EEL LS SEP LEL AES PES LES SILI SS
VQOQOOOOOOOOOOOOOOOOOOOOOOOOOOKOnrwe

 

 

 

Xf ea sf ea sf se se se se oe sf oe sf oe sf oe sf sf ea sf ea sf ea IO se se oe aN oe IO oe se
[| [2] 2[2[slsl=la]2[a[~2felelr[els|el ele] u]o| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
Litt fs fofeti fifi fofofofofo]s fifi fi fofofofofofofi fi fof s fifi] freset

 

SYSTEM_CPU_PERI_CLK_ENO REG Configures this register to enable different peripheral clocks.
For details, please refer to Table 33.

Espressif Systems 162 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

Register 6.18: SYSTEM_PERIP_CLK_EN1_REG (0x0044)

S PPPS
EEEEEE ES
€ SSS SSS KE

 

[1 7els[«[s][2[:]e]

joo 0 0000000090000 000 00 0 0 0 0 ofofololofo[o][o ]Rreset

SYSTEM_PERIP_CLK_EN1_ REG Configures this register to enable different accelerator clocks. For
details, please refer to Table 33.

Register 6.19: SYSTEM_PERIP_RST_ENO_REG (0x0048)



 

 

 

A S A
S S
A & Cx S A US
OP'S CS A N , A
CEVE S S SA oS So «a A
EN 7 Ye% Sos YAS Pas ¢Y OS FIFO KR SO TOES 2EIZOAES
PFO LESS O LMS PES LESLIE LE GEE EE FES
SEOSSSESSSSSESSSSSESSSSSESSSEOSSS SESS SES
[ 3 30 29 | 2 | 2 | 2 25 x | 23 | 2 | 20 20 19 18 17 16 | 1s 14 13 12 i | 2 8 7 ele[«[e[e[s][e]
Lefefefefofofofofofofofofofofofofofofofofofofofofofofofofofo]o]o jreset
SYSTEM_PERIP_RST_ENO_REG Configures this register to reset different peripherals. For details,
please refer to Table 33.
Register 6.20: SYSTEM _PERIP_RST_EN1_REG (0x004C)
E€s Eb
ee VES EE
CCE
SEE EEE
Ss Wy WY, Ze WS >
£ EEEEEES
€ OSs
[1 7Lefs[«[=]2]:[o]
jo9 0 0900000900000 00 00 00 0 0 oftfi]ift[i]i]o JReset
SYSTEM_PERIP_RST_EN1_REG Configures this register to reset different accelerators. For details,
please refer to Table 33.
Espressif Systems 163 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
6. System Registers

 

Register 6.21: SYSTEM_BT_LPCK_DIV_FRAC_REG (0x0054)

 

[a1 29] 26 | 27 | 26 | 25 | & [2s wu o|

[0 0 ofofofo]s]o] 1 | 1 |Reset

 

 

 

SYSTEM_LPCLK_SEL_ RTC SLOW Set this bit to select RTC slow clock as the low power clock.
(RAV)

SYSTEM_LPCLK_SEL 8M _ Set this bit to select 8m clock as the low power clock. (RAV)
SYSTEM_LPCLK_SEL_XTAL Set this bit to select xtal clock as the low power clock. (RAW)
SYSTEM_LPCLK_SEL_XTAL32K Set this bit to select xtal82k clock as the low power clock. (R/W)

SYSTEM_LPCLK_RTC_EN Set this bit to enable the RTC low power clock. (R/W)

Register 6.22: SYSTEM_CPU_INTR_FROM_CPU_0_REG (0x0058)



joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset

 

 

 

SYSTEM_CPU_INTR_FROM_CPU_0 Set this bit to generate CPU interrupt 0. This bit needs to be
reset by software in the ISR process. (R/W)

Register 6.23: SYSTEM_CPU_INTR_FROM_CPU_1_REG (0x005C)

S\
ye
x
&

[ T°]

joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset

 

 

 

SYSTEM_CPU_INTR_FROM_CPU_1 Set this bit to generate CPU interrupt 1. This bit needs to be
reset by software in the ISR process. (R/W)

Espressif Systems 164 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

Register 6.24: SYSTEM_CPU_INTR_FROM_CPU_2_REG (0x0060)

x
x
&

Ee i

joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset

 

 

SYSTEM_CPU_INTR_FROM_CPU_2 Set this bit to generate CPU interrupt 2. This bit needs to be
reset by software in the ISR process. (R/W)

Register 6.25: SYSTEM_CPU_INTR_FROM_CPU_3_REG (0x0064)

x
x
&

 

31 1] 0

 

 

 

 

oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO
oO

Reset

 

SYSTEM_CPU_INTR_FROM_CPU_3 Set this bit to generate CPU interrupt 3. This bit needs to be
reset by software in the ISR process. (R/W)

Register 6.26: SYSTEM_RSA_PD_CTRL_REG (0x0068)



SYSTEM_RSA_MEM _PD Set this bit to power down RSA memory. This bit has the lowest priority.
When Digital Signature occupies the RSA, this bit is invalid. (RAM)

SYSTEM_RSA_MEM_FORCE_PU Set this bit to force power up RSA memory. This bit has the
second highest priority. (R/V)

SYSTEM_RSA_MEM_FORCE_PD Set this bit to force power down RSA memory. This bit has the
highest priority. (RAV)

Espressif Systems 165 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

Register 6.27: SYSTEM_BUSTOEXTMEM_ENA_REG (0x006C)

 

 

 

 

 

 

 

 

3s
&
Ss
xO
e
= Q
S 7
é &
& So
Ee i
jo 9000000000000 0000000 00090 00 0 0 0 0] 1 IReset
SYSTEM_BUSTOEXTMEM_ENA Set this bit to enable bus to EDMA. (R/V)
Register 6.28: SYSTEM_CACHE_CONTROL_REG (0x0070)




ss
OS
ESS
Sook
ry oe
O00 7
5 Sass
és LLL
& SSS
[z PEt]
joo 0 0 0000000000090 0000009 00 0 0 0 ofo[1][1 IReset
SYSTEM_PRO_ICACHE CLK_ON Set this bit to enable clock of i-cache. (R/W)
SYSTEM_PRO_DCACHE CLK_ON Set this bit to enable clock of d-cache. (R/W)
SYSTEM_PRO_CACHE_RESET Set this bit to reset cache. (R/W)
Espressif Systems 166 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
6. System Registers

 

Register 6.29: SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG (0x0074)

 

 

 

SYSTEM_ENABLE_ SPI_MANUAL ENCRYPT Set this bit to enable Manual Encryption under SPI
Boot mode. (RAW)

SYSTEM_ENABLE DOWNLOAD _DB_ENCRYPT Set this bit to enable Auto Encryption under
Download Boot mode. (R/W)

SYSTEM_ENABLE DOWNLOAD _GOCB_DECRYPT Set this bit to enable Auto Decryption under
Download Boot mode. (R/W)

SYSTEM_ENABLE_ DOWNLOAD _MANUAL_ENCRYPT Set this bit to enable Manual Encryption
under Download Boot mode. (RAV)

Register 6.30: SYSTEM_RTC_FASTMEM_CONFIG_REG (0x0078)


Aj
S x e
s Se © .
O7 O7 O7 O7
ws ws ws ws
O”7 © oo oe oo
af ae $ $ S
& & & & Ss
S S S 5 &
[ st [20 219 of e |r o|
| 0 | Ox7ff | x0 | 0 [o 0000 0 0 O]Reset

 

SYSTEM_RTC_MEM CRC START Set this bit to start the CRC of RTC memory. (R/W)
SYSTEM_RTC_MEM _CRC_ADDR This field is used to set address of RTC memory for CRC. (RAN)

SYSTEM_RTC_MEM CRC _LEN This field is used to set length of RTC memory for CRC based on
start address. (R/W)

SYSTEM_RTC_MEM CRC FINISH Thisbit stores the status of RTC memory CRC. High level means
finished while low level means not finished. (RO)

Espressif Systems 167 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

Register 6.31: SYSTEM_RTC_FASTMEM_CRC_REG (0x007C)

 

 

 

EP
a
e
eo
A
xO
se

[a ‘|
| 0 | Reset

 

SYSTEM_RTC_MEM CRC_RES This field stores the CRC result of RTC memory. (RO)

Register 6.32: SYSTEM_SRAM_CTRL_2_REG (0x0088)

 

 

 

»
ge
ev
&
Qe
SS a
& &
e S
[1 2221 o|
[o 0000000 0 o| OX |Reset

 

SYSTEM_SRAM_FORCE_ PU This field is used to power up internal SRAM. For details, please refer
to Table 82. (RAN)

Register 6.33: SYSTEM_SYSCLK_CONF_REG (0x008C)

 

 

 

oO
& & Ss
oa ow XY
5 ov sv we
Lo Lo
& S S S
[1 [18 [0 1o[» o|
[o 0 0 00 00 000 0 o| 0 | 0 | oxi |Reset

 

SYSTEM_PRE_DIV_CNT This field is used to set the count of prescaler of XTAL_CLK. For details,
please refer to Table 10 in Chapter 2 Reset and Clock. (RAN)

SYSTEM _SOC CLK_SEL This field is used to select SOC clock. For details, please refer to Table 8
in Chapter 2 Reset and Clock. (RM)

SYSTEM_CLK_XTAL_FREQ This field is used to read XTAL frequency in MHz. (RO)

Espressif Systems 168 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
6. System Registers

 

 

 

 

 

Register 6.34: SYSTEM _REG_DATE_REG (OxOFFC)
&
Or
er
©
S ws
gf &
g BY
€ S
| 31 28 | 7 0 |
[o 0 0 | 0x1908020 |Reset
SYSTEM_DATE Version control register. (RAV)
Espressif Systems 169 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
7. DMA Controller

 

7. DMA Controller

7.1. Overview

Direct Memory Access (DMA) is a feature that allows peripheral-to-memory and memory-to-memory data transfer

at a high speed. The CPU is not involved in the DMA transfer, and therefore it becomes more efficient.

ESP32-S2 has three types of DMA, namely Internal DMA, EDMA and Copy DMA. Internal DMA can only access
internal RAM and is used for data transfer between internal RAM and peripherals. EDMA can access both
internal RAM and external RAM and is used for data transfer between internal RAM, external RAM and
peripherals. Copy DMA can only access internal RAM and is used for data transfer from one location in internal

RAM to another.

Eight peripherals on ESP32-S2 have DMA features. As shown in figure 7-1, UARTO and UART1 share one
Internal DMA; SPIS and ADC Controller share one Internal DMA; AES Accelerator and SHA Accelerator share one
EDMA,; SPI2 and |?S0 have their individual EDMA. Besides, the CPU Peripheral module on ESP32-S2 also has

one Copy DMA.

 

Modules

 

UARTO

UART1

 

 

SPI3

ADC

 

 

AES

 

SHA

 

 

SPI2

 

 

SO

 

 

 

CPU Peripheral

 

 

 

Data Transfer

Between internal
RAM and
peripherals

Between internal
RAM, external
RAM and
peripherals

} Within internal RAM

 

 

Figure 7-1. Modules with DMA and Supported Data Transfers

7.2 Features

The DMA controller has the following features:

© AHB bus architecture

® Half-duplex and full-duplex mode

* Programmable length of data to be transferred in bytes

° INCR burst transfer when accessing internal RAM

* Access to an address space of 320 KB at most in internal RAM

* Access to an address space of 10.5 MB at most in external RAM

* High-speed data transfer using DMA

Espressif Systems

170

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
7. DMA Controller

 

7.3 Functional Description

In ESP32-S2, all modules that need high-speed data transfer support DMA. The DMA controller and CPU data
bus have access to the same address space in internal RAM and external RAM. DMA controllers for different
modules vary in functions according to needs, but their architecture is identical.

7.3.1. DMA Engine Architecture

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

DMA_ENGINE
outlink
Internal » descriptor 0
Ram Tx
>
a descriptor n
= inlink
un
descriptor 0
Extemal us RX
Ram
descriptor n

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 7-2. DMA Engine Architecture

A DMA engine reads/writes data to/from external RAM or internal RAM via the AHB_BUS. Figure 7-2 shows the
basic architecture of a DMA engine. For how to access RAM, please see Chapter 1 System and’ Memory.
Software can use the DMA engine through linked lists. The DMA_ENGINE transmits data in corresponding RAM
according to the outlink (i.e. a linked list of transmit descriptors), and stores received data into specific address
space in RAM according to the inlink (i.e. a linked list of receive descriptors).

7.3.2 Linked List

Linked List

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

31 30 29 28 27 23 ii 60
Dwo

Dwi Dwo | owner | suc_eof [Reserved| err_eof |Reserved| length| size |

Dw2 ee DW1 | buffer address pointer |

an Dwo Dw2 | Next descriptor address |
DW1
Dw2
J DWO
DW1
Dw2

 

 

 

Figure 7-3. Structure of a Linked List

Figure 7-3 shows the structure of a linked list. An outlink and an inlink have the same structure. A linked list is
formed by one or more descriptors, and each descriptor consists of three words. Linked lists should be in
internal RAM for the DMA engine to be able to use them. The meaning of each field is as follows:

* Owner (DWO) [81]: Specifies who is allowed to access the buffer that this descriptor points to.
1’bO: CPU can access the buffer;
1’b1: The DMA controller can access the buffer.
When the DMA controller stops using the buffer, this bit is cleared by hardware. You can set
PERI_IN_LOOP_TEST bit to disable automatic clearing by hardware. When software loads a linked list, this

Espressif Systems 171 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
7. DMA Controller

 

bit should be set to 1.
Note: refers to modules that support DMA transfers, e.g. 2S, SPI, UHCI, etc.

suc_eof (DWO) [30]: Specifies whether this descriptor is the last descriptor in the list.

1’bO: This descriptor is not the last one;

1’b1: This descriptor is the last one.

When a packet has been received, this bit in the last receive descriptor is set to 1 by hardware, and this bit
in the last transmit descriptor is set to 1 by software.

Reserved (DW0O) [29]: Reserved.

err_eof (DWO) [28]: Specifies whether the received cata has errors.
This bit is used only when UART DMA receives data. When an error is detected in the received packet, this
bit in the receive descriptor is set to 1 by hardware.

Reserved (DW0) [27:24]: Reserved.

Length (DW0) [28:12]: Specifies the number of valid bytes in the buffer that this descriptor points to. This
field in a transmit descriptor is written by software and indicates how many bytes can be read from the
buffer; this field in a receive descriptor is written by hardware automatically and indicates how many bytes
have been stored into the buffer.

When the DMA controller accesses external RAM, this filed must be a multiple of 16/32/64 bytes. Please
see more details in Section 7.3.6 Accessing External RAM,

Size (DWO) [11:0]: Specifies the size of the buffer that this descriptor points to.
When the DMA controller accesses external RAM, this field must be a multiple of 16/32/64 bytes. Please
see more details in Section 7.3.6 Accessing External RAM,

Buffer address pointer (DW1): Pointer to the buffer.
When the DMA controller accesses external RAM, the destination address must be aligned with
| EXT_MEM_BK_SIZE field. Please see more details in Section 7.3.6 Accessing External RAM,

Next descriptor address (DW2): Pointer to the next descriptor. If the current descriptor is the last one
(suc_eof = 1), this value is 0. This field can only point to internal RAM.

If the length of data received is smaller than the size of the buffer, the DMA controller will not use available space
of the buffer in the next transaction.

7.3.3 Enabling DMA
Software uses the DMA controller through linked lists. When the DMA controller receives data, software loads an
inlink, configures _INLINK_ADDR field with address of the first receive descriptor, and sets

_INLINK_START bit to enable DMA. When the DMA controller transmits data, software loads an outlink,
prepares data to be transmitted, configures _OUTLINK_ADDR field with address of the first transmit
descriptor, and sets _OUTLINK_START bit to enable DMA. _INLINK_START bit and

_OUTLINK_START bit are cleared automatically by hardware.

The DMA controller can be restarted. If you are not sure whether the loaded linked list has been used up or not
and want to load a new linked list, you can use this Restart function without affecting the loaded linked list. When
using the Restart function, software needs to rewrite address of the first descriptor in the new list to DW2 of the
last descriptor in the loaded list, loads the new list as shown in Figure 7-4, and set _INLINK_RESTART bit or
_OUTLINK_RESTART bit (these two bits are cleared automatically by hardware). By doing so, hardware can
obtain the address of the first descriptor in the new list when reading the last descriptor in the loaded list, and

Espressif Systems 172 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
7. DMA Controller

 

then read the new list.

 

 

 

The last descriptor
of linked list

 

 

 

 

 

 

 

Next descriptor address \
Next descriptor a
a : New linked list

 

 

 

 

 

 

Figure 7-4. Relationship among Linked Lists

7.3.4 Linked List reading process

Once configured and enabled by software, the DMA controller starts to read the linked list from internal RAM.
PERI_IN_DSCR_ERR_INT_ENA bit or PFA/_OUT_DSCR_ERR_INT_ENA bit can be set to enable descriptor error
interrupt. If the buffer address pointer (DW1) does not point to Ox8FFBOOO0 ~ Ox3FFFFFFF when the DMA
controller accesses internal RAM, or does not point to Ox3F500000 ~ OxSFF7FFFF when the DMA controller
accesses external RAM, a descriptor error interrupt is generated.

Note: The third word (DW2) in a descriptor can only point to internal RAM; it points to the next descriptor to use
and descriptors must be in internal memory.

7.3.5 EOF

The DMA controller uses EOF (end of file) flags to indicate the completion of data transfer.

Before the DMA controller transmits data, PEP/_OUT_TOTAL_EOF_INT_ENA bit should be set. If data in the
buffer pointed by the last descriptor has been transmitted, a PER/_OUT_TOTAL_EOF_INT interrupt is
generated.

Before the DMA controller receives data, PEA/_IN_SUC_EOF_INT_ENA bit should be set. If data has been
received successfully, a PER/_IN_SUC_EOF_INT interrupt is generated. In addition to PEA/_IN_SUC_EOF_INT
interrupt, UART DMA also supports UHCI_IN_ERR_EOF_INT. This interrupt is enabled by setting
UHCI_IN_ERR_EOF_INT_ENA bit, and it indicates that a data packet has been received with errors.

When a PER/_OUT_TOTAL_EOF_INT or a PER/_IN_SUC_EOF_INT interrupt is detected, software can record the
value of field PFR/_OUTLINK_DSCR_ADDR or PF A/_INLINK_DSCR_ADDR, i.e. address of the last descriptor
(right shifted 2 bits). Therefore, software can tell which descriptors have been used and reclaim them.

7.3.6 Accessing External RAM

Of all DMA controllers for ESP32-S2 peripherals, only I?S0, SPI2, AES and SHA DMA have access to external
RAM. The address space of external RAM that the DMA controller can access is OxSF500000 ~ OxSFF/FFFF.
Please note that destination addresses (in this case addresses for writing data to external RAM) must be 16-byte,
82-byte or 64-byte aligned. Table 36 illustrates the value of PFA/_EXT_MEM_BK_SIZE bit when destination
address is 16-byte, 32-byte and 64-byte aligned respectively.

Note: Source addresses (in this case, namely addresses for reading data from external RAM) do not need to be
aligned.

Espressif Systems 173 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
7. DMA Controller

 

Table 36: Relationship Between Configuration Register and Destination Address

 

 

 

 

 

 

PEP|_EXT_MEM_BkK_SIZE Destination address align-
ment

0 16-bit aligned

1 82-bit aligned

2 64-bit aligned

 

 

7.4 Copy DMA Controller

Copy DMA is used for data transfer from one location in internal RAM to another. Figure 7-5 shows the
architecture of a Copy DMA engine. Unlike Internal DMA and EDMA, Copy DMA first reads data to be transferred
from internal RAM, stores the data into the DMA FIFO via an outlink, and then writes the data to the target
internal RAM via an inlink.

Copy DMA should be configured by software as follows:

1. Set CP_DMA_IN_RST, CP_DMA_OUT_RST, CP_DMA_FIFO_RST and CP_DMA_CMDFIFO_RST bit first to
1 and then to 0, to reset Copy DMA state machine and FIFO pointer;

2. Set CP_DMA_FIFO_RST bit first to 1 and then to 0, to reset FIFO pointer;

3. Load an outlink, and configure CP_DMA_OUTLINK_ADDR with address of the first transmit descriptor;
4. Load an inlink, and configure CP_DMA_INLINK_ADDR with address of the first receive descriptor;

5. Set CP_DMA_OUTLINK_START to enable DMA transmission;

6. Set CP_DMA_INLINK_START to enable DMA reception.

 

 

 

DMA_ENGINE
outlink

 

descriptor 0

 

 

 

descriptor n
Internal P

Ram

 

sng aHv

inlink

 

descriptor 0

 

 

 

 

 

descriptor n

 

 

 

 

 

 

 

 

 

 

 

 

Figure 7-5. Copy DMA Engine Architecture

7.5 UART DMA (UDMA) Controller
ESP32-S2 has two UART controllers. They share one UDMA controller. UHCI_LUART_CE specifies which UART
controller gets access to UDMA.

Figure 7-6 shows how data is transferred using UDMA. Before UDMA receives data, software prepares an inlink.
UHCI_INLINK_ADDR points to the first receive descriptor in the inlink. After UHCI_INLINK_START is set, UHCI
sends cata that UART has received to the Decoder. The decoded data is then stored into the RAM pointed by
the inlink under the control of UDMA.

Espressif Systems 174 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
7. DMA Controller

 

 

 

 

 

 

 

 

 

 

 

UDMA UART
UHCI
Encoder Transmitter| b<d_out
DMA_ENGINE
‘i rxd_in
+—— Decoder Receiver =

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 7-6. Data Transfer in UDMA Mode

Before UDMA sends data, software prepares an outlink and data to be sent. UHC|_OUTLINK_ADDR points to
the first transmit descriptor in the outlink. After UHCI_OUTLINK_START is set, UDMA reads data from the RAM
pointed by outlink. The data is then encoded by the Encoder, and sent sequentially by the UART

transmitter.

Data packets of UDMA have separators at the beginning and the end, with data bits in the middle. The encoder
inserts separators in front of and after data bits, and replaces data bits identical to separators with special
characters. The decoder removes separators in front of and after data bits, and replaces special characters with
separators. There can be more than one continuous separator at the beginning and the end of a data packet.
The separator is configured by UHCI_SEPER_CHAR, OxC0 by default. The special character is configured by
UHCI_ESC_SEQO_CHARO (OxDB by default) and UHCILESC_SEQO_CHAR?1 (0xDD by default). When all data
has been sent, a UHCI_OUT_TOTAL_EOF_INT interrupt is generated. When all data has been received, a
UHCI_IN_SUC_EOF_INT is generated.

7.6 SPI DMA Controller

 

 

DMA_ENGINE SPI2

 

 

 

DMA_ENGINE SPI3

 

 

 

 

 

 

 

 

 

Figure 7-7. SPI DMA

As shown in Figure 7-7, SPI2 and SPIS have separate DMA controllers.

SPI DMA receives and transmits data through descriptors at least one byte at a time. The transmission of data
can be done in bursts.

SPI_OUTLINK_START bit of SPI_DMA_OUT_LINK_REG register and SPI_INLINK_START bit of
SPI_DMA_IN_LINK_REG register are used to enable the DMA engine and are cleared by hardware. When
SPI_OUTLINK_START is set to 1, the DMA engine loads an outlink and prepares data to be transferred; when
SPIINLINK_START is set to 1, the DMA engine loads an inlink and prepares to receive data.

When receiving data, SP! DMA should be configured by software as follows:

Espressif Systems 175 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
7. DMA Controller

 

1. Set SPI_DMA_IN_RST, SPI_AHBM_FIFO_RST and SPI_LAHBM_RST bit first to 1 and then to 0, to reset
DMA state machine and FIFO pointer;

2. Load an inlink, and configure SPI_DMA_INLINK_ADDR with address of the first receive descriptor;
3. Set SPIDMA_INLINK_START to enable DMA reception.
When transmitting data, SP! DMA should be configured by software as follows:

1. Set SPIDMA_OUT_RST, SPILAHBM_FIFO_RST and SPI_AHBM_RST bit first to 1 and then to 0, to reset
RMA state machine and FIFO pointer;

2. Load an outlink, and configure SPILDMA_OUTLINK_ADDR with address of the first transmit descriptor;
3. Set SPILDMA_OUTLINK_START to enable DMA transmission.

Note: When SPI DMA transfers data between internal RAM and external RAM, SPILMEM_TRANS_EN should be
set.

SPI DMA also supports data transfer in segments.

7./ |? DMA Controller

ESP32-S2 I?S has an individual DMA. 12S_DSCR_EN bit of 12S _FIFO_CONF_REG register is used to enable
DMA transfer of |?S. ?S DMA receives and transmits data through linked lists. The transmission of data can be
done in bursts. 12S _RX_EOF_NUM[31:0] bit of 12S_RXEOF_NUM_REG register is used to configure how many
words of data to be received at a time.

128 OUTLINK_ START bit of 128 _OUT_LINK_REG and I2S_INLINK_START bit of 12S_IN_LINK_REG register are
used to enable the DMA engine and are cleared by hardware. When |2S_OUTLINK_START bit is set to 1,the
DMA engine loads an outlink and prepares data to be transferred; when |2S_INLINK_START is set to 1,the DMA
engine loads an inlink and prepares to receive data.

When receiving data, 7S DMA should be configured by software as follows:

1. Set I2S_IN_RST, l2S_AHBM_FIFO_RST and |2S_AHBM_RST bit first to 1 and then to 0, to reset DMA state
machine and FIFO pointer;

2. Load an inlink, and configure I2S_INLINK_ADDR with address of the first receive descriptor;
3. Set 12S_INLINK_START to enable DMA reception.
When transmitting data, 12S DMA should be configured by software as follows:

1. Set 12S OUT_RST, 12S AHBM_FIFO_RST and Il2S_AHBM_RST bit first to 1 and then to 0, to reset DMA
state machine and FIFO pointer;

2. Load an outlink, and configure I2S_OUTLINK_ADDR with address of the first transmit descriptor;
3. Set 12S _OUTLINK_START to enable DMA transmission.

Note: When I?S DMA transfers data between internal RAM and external RAM using I?S DMA,
I2S_MEM_TRANS_EN should be set.

Espressif Systems 176 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

8. UART Controller

8.1 Overview

In embedded system applications, data is required to be transferred in a simple way with minimal system
resources. This can be achieved by a Universal Asynchronous Receiver/Transmitter (UART}, which flexibly
exchanges data with other peripheral devices in full duplex mode. ESP32-S2 has two UART controllers
compatible with various UART devices. They support Infrared Data Association (IrDA) and RS-485
transmission.

ESP32-S2 has two UART controllers. Each has a group of registers that function identically. In this chapter, the
two UART controllers are referred to as UARTn, in which 7 denotes O or 1.

8.2 Features
Each UART controller has the following features:

* Programmable baud rate

512 x 8-bit RAM shared by TX FIFOs and RX FIFOs of two UART controllers

Full duplex asynchronous communication

Automatic baud rate detection

Data bits ranging from 5 to 8

Stop bits whose length can be 1, 1.5, 2 or 3 bits

Parity bits

Special character AT_CMD detection

* RS-485 protocol

IrDA protocol

High-speed data communication using DMA

e UART as wake-up source

Software and hardware flow control

8.3. Functional Description
8.3.1 UART Introduction

A UART is a character-oriented data link for asynchronous communication between devices. Such
communication does not add clock signals to data sent. Therefore, in order to communicate successfully, the
transmitter and the receiver must operate at the same baud rate with the same stop bit and parity bit.

A UART data packet usually begins with one start bit, followed by data bits, one parity bit (optional) and one or
more stop bits. UART controllers on ESP32-S2 support various lengths of data bits and stop bits. These
controllers also support software and hardware flow control as well as DMA for seamless high-speed cata
transfer. This allows developers to use multiple UART ports at minimal software cost.

Espressif Systems 177 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

   

 

 

 

 

 

 

 

DMA UART
apb_wr
Tx_FIFO| | tt
apb_wdata fifo_rd _ J | = »
———_ fifo rdatery FIFO Ctrl HW_Flow_Ctrl cten
- lq
Tx_FSM
Clock CLK
UART_TICK_ALWAYS_ON
APB_CLK
APB_GIK td
REF_TICK 0 [pwicer
txd_out
ou SW_Flow_Ctrl wpm] © | |
fifo_we Rx_FSM -
apb_rd ffowdatRy FIFO_Ctri

 

 

 

 

 

 

 

 

 

apb_rdata|Rx_FIFO
——_

 

 

Baudrate_Detect
wake_up
Wakeup_Ctrl

Figure 8-1. UART Structure

 

 

 

 

 

8.3.2 UART Structure

Figure 8-1 shows the basic structure of a UART controller. It has two possible clock sources: a 80 MHz
APB_CLK and a reference clock REF_TICK (for details, please refer to Chapter 2 Reset and Clock), which are
selected by configuring UART_TICK_REF_ALWAYS_ON. The selected clock source is divided by a divider to
generate clock signals that drive the UART controller. The divisor is configured by UART_CLKDIV_REG:
UART_CLKDIV for the integral part, and UART_CLKDIV_FRAG for the fractional part.

A UART controller is broken down into two parts according to functions: a transmitter and a receiver.

The transmitter contains a TX FIFO, which buffers data to be sent. Software can write data to Tx_FIFO via the
APB bus, or move data to Tx_FIFO using DMA. Tx_FIFO_Ctrl controls writing and reading Tx_FIFO. When
Tx_FIFO is not empty, Tx_FSM reads bytes via Tx_FIFO_Ctrl, and converts them into a bitstream. The levels of
output signal txd_out can be inverted by configuring UART_TXD_INV register.

The receiver contains a RX FIFO, which buffers data to be processed. Software can read data from Rx_FIFO via
the APB bus, or receive data using DMA. The levels of input signal rxd_in can be inverted by configuring
UART_RXD_INV register, and the signal is then input to the Rx components of the UART Controller:
Baudrate_Detect measures the baud rate of input signal rxd_in by detecting its minimum pulse width.
Start_Detect detects the start bit in a data frame. If the start bit is detected, Rx_FSM stores data bits in the data
frame into Rx_FIFO by Rx_FIFO_Ctrl.

HW_Flow_Ctrl controls rxd_in and txd_out data flows by standard UART RTS and CTS flow control signals
(rtsn_out and ctsn_in). SW_Flow_Ctrl controls data flows by automatically adding special characters to outgoing
data and detecting special characters in incoming data. When a UART controller is in the Light-sleep mode,
Wakeup_Ctrl counts up rising edges of rxc_in. When the number reaches (UART_ACTIVE_THRESHOLD + 2), a
wake_up signal is generated and sent to RTC, which then wakes up the ESP82-S2 chip.

Espressif Systems 178 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

RAM

 

offset:0
UARTO Tx_FIFO 1 block ,

offset:128 128 bytes
UART1 Tx_FIFO

 

 

offset:256

UARTO Rx_FIFO
offset:384

 

UART1 Rx_FIFO

 

 

 

Figure 8-2. UART Controllers Sharing RAM

8.3.3 UART RAM

The two UART controllers on ESP82-S2 share 512 x 8 bits of FIFO RAM. As figure 8-2 illustrates, RAM is divided
into 4 blocks, each has 128 x 8 bits. Figure 8-2 shows by default how many RAM blocks are allocated to TX
FIFOs and RX FIFOs of the two UART controllers. UARTn Tx_FIFO can be expanded by configuring
UART_TX_SIZE, while UARTn Rx_FIFO can be expanded by configuring UART_RX_SIZE. The size of UARTO
Tx_FIFO can be increased to 4 blocks (the whole RAM), the size of UART1 Tx_FIFO can be increased to 3 blocks
(from offset 128 to the end address), the size of UARTO Rx_FIFO can be increased to 2 blocks (from offset 256 to
the end address), but the size of UART1 Rx_FIFO cannot be increased. Please note that expanding one FIFO
may take up the default space of other FIFOs. For example, by setting UART_TX_SIZE of UARTO to 2, the size of
UARTO Tx_FIFO is increased by 128 bytes (from offset 0 to offset 255). In this case, UARTO Tx_FIFO takes up
the default space for UART1 Tx_FIFO, and UART1’s transmitting function cannot be used as a result.

When neither of the two UART controllers is active, RAM could enter low-power mode by setting
UART_MEM_FORCE_PD.

UARTO Tx_FIFO and UART1 Tx_FIFO are reset by setting UART_TXFIFO_RST. UARTO Rx_FIFO and UART1
Rx_FIFO are reset by setting UART_RXFIFO_RST.

Data to be sent is written to TX FIFO via the APB bus or using DMA, read automatically and converted from a
frame into a bitstream by hardware Tx_FSM; data received is converted from a bitstream into a frame by
hardware Rx_FSM, written into RX FIFO, and then stored into RAM via the APB bus or using DMA. The two
UART controllers share one DMA controller.

The empty signal threshold for Tx_FIFO is configured by setting UART_TXFIFO_EMPTY_THRHD. When cata
stored in Tx_FIFO is less than UART_TXFIFO_EMPTY_THRHD, a UART_TXFIFO_EMPTY_INT interrupt is
generated.

The full signal threshold for Rx_FIFO is configured by setting UART_RXFIFO_FULL_THRHD. When data stored in
Rx_FIFO is greater than UART_RXFIFO_FULL_THRHD, a UART_RXFIFO_FULL_INT interrupt is generated. In
addition, when Rx_FIFO receives more data than its capacity, a UART_RXFIFO_OVF_INT interrupt is

generated.

8.3.4 Baud Rate Generation and Detection
8.3.4.1. Baud Rate Generation

Before a UART controller sends or receives data, the baud rate should be configured by setting corresponding
registers. A UART Controller baud rate generator functions by dividing the input clock source. It can divide the
clock source by a fractional amount. The divisor is configured by UART_CLKDIV_REG: UART_CLKDIV for the

Espressif Systems 179 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

integral part, and UART_CLKDIV_FRAG for the fractional part. When using an 80 MHz input clock, the VART
controller supports a maximum baud rate of 5 Mbaud.

The divisor of the baud rate divider is equal to UART_CLKDIV + (UART_CLKDIV_FRAG / 16), meaning that the
final baud rate is equal to INPUT_FREQ / (UART_CLKDIV + (UART_CLKDIV_FRAG / 16)). For example, if
UART_CLKDIV = 694 and UART_CLKDIV_FRAG = 7 then the divisor value is (694 + 7/16) = 694.4375. If the
input clock frequency is 80MHz APB_CLK, the baud rate will be (8OMHz / 69.4375) = 115201.

When UART_CLKDIV_FRAG is zero, the baud rate generator is an integer clock divider where an output pulse is
generated every UART_CLKDIV input pulses.

When UART_CLKDIV_FRAG is not zero, the divider is fractional and the output baud rate clock pulses are not
strictly uniform. As shown in figure 8-3, for every 16 output pulses, the generator divides either (UART_CLKDIV +
1) input pulses or UART_CLKDIV input pulses per output pulse. A total of UART_CLKDIV_FRAG output pulses
are generated by dividing (UART_CLKDIV + 1) input pulses, and the remaining (16 - UART_CLKDIV_FRAG)
output pulses are generated by dividing UART_CLKDIV input pulses.

The output pulses are interleaved as shown in figure 8-3 below, to make the output timing more uniform:

UU)

UART_CLKDIV) «+» UART_CLKDIV UART_CLKDIV+1 UART_CLKDIV ... UART_CLKDIV UART_CLKDIV+1 UART_CLKDIV UART_CLKDIV+1
clock pluses clock pluses clock pluses clock pluses clock pluses clock pluses clock pluses clock pluses

 

UART_CLKDIV_FRAG

wwe — IL ELLE ILL L__]

16 output clock pluses

 

 

Figure 8-3. UART Controllers Division

To support IrDA (see Section 8.3.7 /rDA for details), the fractional clock divider for IrDA data transmission
generates clock signals divided by 16x UART_CLKDIV_REG. This divider works similarly as the one elaborated
above: it takes UART_CLKDIV/16 as the integer value and the lowest four bits of UART_CLKDIV as the fractional
value.

8.3.4.2 Baud Rate Detection

Automatic baud rate detection (Autobaud) on UARTSs is enabled by setting UART_AUTOBAUD_EN. The
Baudrate_Detect module shown in figure 8-1 will measure pulse widths while filtering any noise whose pulse
wiath is shorter than UART_GLITCH_FILT.

Before communication starts, the transmitter could send random data to the receiver for baud rate detection.
UART_LOWPULSE_MIN_CNT stores the minimum low pulse width, UART_HIGHPULSE_MIN_CNT stores the
minimum high pulse width, VART_POSEDGE_MIN_CNT stores the minimum pulse width between two rising
edges, and UART_NEGEDGE_MIN_CNT stores the minimum pulse width between two falling edges. These four
registers are read by software to determine the transmitter’s baud rate.

Baud rate can be determined in the following three ways:

1. Normally, to avoid sampling erroneous data along rising or falling edges in semi-stable state, which results in
inaccuracy of UART_LOWPULSE_MIN_CNT or UART_HIGHPULSE_MIN_CNT, use a weighted average of these

Espressif Systems 180 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

UART_HIGHPULSE_MIN_CNT

<«

 

 

>

UART_LOWPULSE_MIN_CNT

Figure 8-4. The Timing Diagram of Weak UART Signals Along Falling Edges

two values to eliminate errors. In this case, baud rate is calculated as follows:

Fak

Pret = ART _LOWPULSE_MIN_CNT + UART _HIGHPULSE_MIN_CNT)2

 

2. If UART signals are weak along falling edges as shown in figure 8-4, which leads to inaccurate average of
UART_LOWPULSE_MIN_CNT and UART_HIGHPULSE_MIN_CNT, use UART_POSEDGE_MIN_CNT to
determine the transmitter’s baud rate as follows:

fi clk
UART_POSEDGE_MIN_CNT/2

3. If VART signals are weak along rising edges, use UART_NEGEDGE_MIN_CNT to determine the transmitter’s
baud rate as follows:

Buart =

Fak

Buen = UART_NEGEDGE_MIN_CNT/2

8.3.5 UART Data Frame

 

\start/ BITO \ BITL \ BIT2 \ arm | pry) STOP \ater

 

 

aime to generate UART_PARITY_ERR_INT, UART_FRM_ERR_INT

 

 

 
 
 

 

dataO { datal | data2 0 0 os eaten cata | cat | a | onan) 0 \ Q \ a
We —
brk_num UART_TX_IDLE_NUM brk_num

Figure 8-5. Structure of UART Data Frame

Figure 8-5 shows the basic structure of a data frame. A frame starts with one START bit, and ends with STOP
bits which can be 1, 1.5, 2 or 3 bits long, configured by UART_STOP_BIT_NUM, UART_DL1_EN and
UART_DLO_EN. The START bit is logical low, whereas STOP bits are logical high.

The actual data length can be anywhere between 5 ~ 8 bit, configured by UART_BIT_NUM. When
UART_PARITY_EN is set, a parity bit is added after data bits. UART_PARITY is used to choose even parity or
odd parity. When the receiver detects a parity bit error in data received, a UART_PARITY_ERR_INT interrupt is
generated and data received is still stored into RX FIFO. When the receiver detects a data frame error, a
UART_FRM_ERR_INT interrupt is generated, and cata received by default is stored into RX FIFO.

If all data in Tx_FIFO has been sent, a UART_TX_DONE_INT interrupt is generated. After this, if the
UART_TXD_BRK bit is set then the transmitter will send several NULL characters in which the TX data line is
logical low. The number of NULL characters is configured by UART_TX_BRK_NUM. Once the transmitter has
sent all NULL characters, a UART_TX_BRK_DONE_INT interrupt is generated. The minimum interval between
data frames can be configured using UART_TX_IDLE_NUM. If the transmitter stays idle for UART_TX_IDLE_NUM
or more time, a UART_TX_BRK

_IDLE_DONE_INT interrupt is generated.

Espressif Systems 181 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

 

 

 

 

 

 

 

UART_PRE_IDLE_NUM UART_RX_GAP_TOUT UART_POST_IDLE_NUM
AT_CMD AT_CMD AT_CMD
data _CHAR _CHAR ” _CHAR data

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

UART_CHAR_NUM

Figure 8-6. AT_CMD Character Structure

Figure 8-6 is the structure of a special character AT_CMD. If the receiver constantly receives AT_CMD_CHAR and
the following conditions are met, a UART_AT_CMD_CHAR_DET_INT interrupt is generated.

® The interval between the first AT_CMD_CHAR and the last non AT_CMD_CHAR character is at least UART
_PRE_IDLE_NUM single-bit cycles.

® The interval between two AT_CMD_CHAR characters is less than UART_RX_GAP_TOUT single-bit cycles.
° The number of AT_CMD_CHAR characters is equal to or greater than UART_CHAR_NUM.

© The interval between the last AT_CMD_CHAR character and next non AT_CMD_CHAR character is at least
UART_POST_IDLE_NUM single-bit cycles.

8.3.6 RS485

The two UART controllers support RS485 standard. This standard uses differential signals to transmit data, so it
can communicate over longer distances at higher bit rates than RS232. RS485 has two-wire half-duplex mode
and four-wire full-duplex mode. UART controllers support two-wire half-duplex transmission and bus snooping.
In atwo-wire RS485 multidrop network, there can be 32 slaves at most.

8.3.6.1. Driver Control

As shown in figure 8-7, in a two-wire multidrop network, an external RS485 transceiver is needed for differential
to single-ended conversion. A RS485 transceiver contains a driver and a receiver. When a UART controller is not
in transmitter mode, the connection to the differential line can be broken by disabling the driver. When DE is 1,
the driver is enabled; when DE is 0, the driver is disabled.

The receiving UART converts differential signals to single-ended signals via an external receiver. RE is the enable
control signal for the receiver. When RE is 0, the receiver is enabled; when RE is 1, the receiver is disabled. If RE
is configured as 0, the UART controller is allowed to snoop data on the bus, including data sent by itself.

DE can be controlled by either software or hardware. To reduce cost of software, in our design DE is controlled
by hardware. As shown in figure 8-7, DE is connected to dtrn_out of UART (please refer to Section8.3.9.1
Hardware Flow Control for more details).

 

 

RS485 transeciver
D+

TXD — D-

 

 

 

dtrn_out

 

UART

0 RE

 

 

 

 

 

 

 

 

 

Figure 8-7. Driver Control Diagram in RS485 Mode

Espressif Systems 182 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

8.3.6.2 Turnaround Delay

By default, the two UART controllers work in receiver mode. When a UART controller is switched from transmitter
mode to receiver mode, the RS485 protocol requires a turnaround delay of at least one cycle after the stop bit.
The transmitter supports turnaround delay of two cycles added after the stop bit. When UART_DL1_EN is set,
turnaround delay of one single-bit cycle is added; when UART_DLO_EN is set, turnaround delay of a second
cycle is added.

8.3.6.3 Bus Snooping

By default, an RS485 device is not allowed to transmit and receive data simultaneously. However, the UART
controller peripheral supports snooping this bus by receiving while transmitting. If UART_RS485TX_RX_EN is set
and the external RS485 transceiver is configured as in figure 8-7, a UART controller may receive data in
transmitter mode and snoop the bus. If UART_RS485RXBY_TX_EN is set, a UART controller may transmit data
in receiver mode.

The two UART controllers can snoop data sent by themselves. In transmitter mode, when a UART controller
monitors a collision between data sent and data received, a UART_RS485_CLASH_INT is generated; when a
UART controller monitor a data frame error, a UART_RS485_FRM_ERR_INT interrupt is generated; when a UART
controller monitors a polarity error, a VART_RS485_PARITY_ERR_INT is generated.

8.3.7 IrDA

IrDA protocol consists of three layers, namely the physical layer, the link access protocol and the link management
protocol. The two UART controllers implement IrDA physical layer. In IDA encoding, a UART controller supports
data rates up to 115.2 kbit/s (SIR, or serial infrared mode). As shown in figure 8-8, the IrDA encoder converts a
NRZ (non-return to zero code) signal to a RZI (return to zero code) signal and sends it to the external driver and
infrared LED. This encoder uses modulated signals whose pulse width is 3/16 bits to indicate logic “0”, and low
levels to indicate logic “1”. The IrDA decoder receives signals from the infrared receiver and converts them to
NRZ signals. In most cases, the receiver is high when it is idle, and the encoder output polarity is the opposite of
the decoder input polarity. If a low pulse is detected, it indicates that a start bit has been received.

When IrDA function is enabled, one bit is divided into 16 clock cycles. If the bit to be sent is zero, then the 9th,
10th and 11th clock cycle is high.

Espressif Systems 188 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

UART Frame

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

START Stop Bit
UART Tx 0 1 0 1 1 0 0 1 0 1
START Stop Bi
IrDA Tx 0 1 | 0 1 1 | 0 0 1 |o 1
Bit Time t IR Frame > =e
Pulse Width = 3/16 Bit Time
|
IrDA Rx 0 1 |o 1 1 | 0 0 1 |o 1
UART Rx 0 1 0 1 1 0 0 1 0 1

 

 

 

 

 

 

 

 

 

 

 

Figure 8-8. The Timing Diagram of Encoding and Decoding in SIR mode

The IrDA transceiver is half-duplex, meaning that it cannot send and receive data simultaneously. As shown in
figure 8-9, IrDA function is enabled by setting UART_IRDA_EN. When UART_IRDA_TX_EN is set (high), the IrDA
transceiver is enabled to send data and not allowed to receive data; when UART_IRDA_TX_EN is reset (low), the
IrDA transceiver is enabled to receive data and not allowed to send data.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

IrDA
0
UART_TXD 1 IrDA Enc >
WwW UART_IXD
UART IVART_IRDA_EN |UART_IRDA_TX_EN
v|
UART_AXD
UART_AXD | | 1 WDA Dec
I
0

 

 

 

 

 

 

 

Figure 8-9. IrDA Encoding and Decoding Diagram

8.3.8 Wake-up

UARTO and UART1 can be set as wake-up source. When a UART controller is in Light-sleep mode, Wakeup_Ctrl
counts up the rising edges of rxd_in. When the number of rising edges is greater than
(UART_ACTIVE_THRESHOLD + 2), a wake_up signal is generated and sent to RTC, which then wakes up
ESP32-S2.

8.3.9 Flow Control

UART controllers have two ways to control data flow, namely hardware flow control and software flow control.
Hardware flow control is achieved using output signal rtsn_out and input signal dsrn_in. Software flow control is
achieved by inserting special characters in data flow sent and detecting special characters in data flow
received.

Espressif Systems 184 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

 

Hardware Flow Control

   
   
  
 
 
  

UART_RX_FLOW_EN

UART_SW_RTS >

 

 

rtsn_out
_UART_RTS_INV_, | D -

 

 

1X_fifo_cnt |CGomparator

 

 

 

 

 

UART_LOOPBACK

 

 

ctsn_in
D :

UART_CTS_INV

UART_SW_DTR
| So dtrn_out

UART_DTR_INV DB >

 

 

 

 

 

 

 

 

 

  
 
   

 

UART_LOOPBACK

 

 

q dsrn_in

Mt eR
UART_DSR_INV

 

 

 

 

 

 

Figure 8-10. Hardware Flow Control Diagram

8.3.9.1 Hardware Flow Control

Figure 8-10 shows hardware flow control of a UART controller. Hardware flow control uses output signal rtsn_out
and input signal dsrn_in. Figure 8-11 illustrates how these signals are connected between ESPS2-S2 UART
(hereinafter referred to as IUO) and the external UART (hereinafter referred to as EUO).

When rtsn_out of IUO is low, EUO is allowed to send data; when rtsn_out of IUO is high, EUO is notified to stop
sending data until rtsn_out of UO returns to low. Output signal rtsn_out can be controlled in two ways.

* Software control: Enter this mode by setting UART_RX_FLOW_EN to 0. In this mode, the level of rtsn_out
is changed by configuring UART_SW_RTS.

* Hardware control: Enter this mode by setting UART_RX_FLOW_EN to 1. In this mode, rtsn_out is pulled
high when data in Rx_FIFO exceeds UART_RX_FLOW_THRHD.

 

 

ESP32-S2 UART External UART

 

 

Transmitter Receiver

rtsn_out rtsn_out

 

 

 

 

 

 

ctsn_in ctsn_in

Receiver RX TX| Transmitter

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 8-11. Connection between Hardware Flow Control Signals
When ctsn_in of IU0 is low, |UO is allowed to send data; when ctsn_in is high, UO is not allowed to send data.
When |UO detects an edge change of ctsn_in, a UART_CTS_CHG_INT interrupt is generated.

If dtrn_out of IUO is high, it indicates that |UO is reacly to transmit data. dtrn_out is generated by configuring
register UART_SW_DTR. When the IUO transmitter detects a edge change of dsrn_in, a VART_DSR_CHG_INT

Espressif Systems 185 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

interrupt is generated. After this interrupt is detected, software can obtain the level of input signal dsrn_in by
reading UART_DSRN. If dsrn_in is high, it indicates that EUO is ready to transmit data.

In a two-wire RS485 multidrop network enabled by setting UART_RS485_EN, dtrn_out is used for
transmit/receive turnaround. In this case, dtrn_out is generated by hardware. When data transmission starts,
dtrn_out is pulled high and the external driver is enabled; when data transmission completes, cltrn_out is pulled
low and the external driver is disabled. Please note that when there is turnaround delay of one cycle added after
the stop bit, dtrn_out is pulled low after the delay.

UART loopback test is enabled by setting UART_LOOPBACK. In the test, UART output signal txd_out is
connected to its input signal rxc_in, rtsn_out is connected to ctsn_in, and ctrn_out is connected to dsrn_out. If
data sent matches data received, it indicates that UART controllers are working properly.

8.3.9.2 Software Flow Control

Instead of CTS/RTS lines, software flow control uses XON/XOFF characters to start or stop data transmission.
Such flow control is enabled by setting UART_SW_FLOW_CON_EN to 1.

When using software flow control, hardware automatically detects if there are XON/XOFF characters in data flow
received, and generate a UART_SW_XOFF_INT or a UART_SW_XON_INT interrupt accordingly. If an XOFF
character is detected, the transmitter stops data transmission once the current byte has been transmitted; if an
XON character is detected, the transmitter starts data transmission. In addition, software can force the
transmitter to stop sending data by setting UART_FORCE_XOFF, or to start sending data by setting
UART_FORCE_XON.

Software determines whether to insert flow control characters according to the remaining room in RX FIFO. When
UART_SEND_XOFF is set, the transmitter sends an XOFF character configured by UART_XOFF_CHAR after the
current byte in transmission; when UART_SEND_XON is set, the transmitter sends an XON character configured
by UART_XON_CHAR after the current byte in transmission. If the RX FIFO of a UART controller stores more cata
than UART_XOFF_THRESHOLD, UART_SEND_XOFF is set by hardware. As a result, the transmitter sends an
XOFF character after the current byte in transmission. If the RX FIFO of a UART controller stores less data than
UART_XON_THRESHOLD, UART_SEND_XON is set by hardware. As a result, the transmitter sends an XON
character after the current byte in transmission.

8.3.10 UDMA
The two UART controllers on ESP382-S2 share one UDMA (UART DMA), which supports the decoding and
encoding of HCI data packets. For more information, please refer to Chapter 7: DMA Controler.

8.3.11 UART Interrupts
e UART_AT_CMD_CHAR_DET_INT: Triggered when the receiver detects an AT_CMD character.

UART_RS485_CLASH_INT: Triggered when a collision is detected between the transmitter and the receiver
in RS485 mode.

UART_RS485_FRM_ERR_INT: Triggered when an error is detected in the data frame sent by the
transmitter in RS485 mode.

UART_RS485_PARITY_ERR_INT: Triggered when an error is detected in the parity bit sent by the
transmitter in RS485 mode.

e UART_TX_DONE INT: Triggered when all data in the transmitter’s TX FIFO has been sent.

Espressif Systems 186 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

UART_TX_BRK_IDLE_DONE_INT: Triggered when the transmitter stays idle for the minimum interval
(threshold) after sending the last data bit.

UART_TX_BRK_DONE_INT: Triggered when the transmitter sends a NULL character after all data in TX
FIFO has been sent.

UART_GLITCH_DET_INT: Triggered when the receiver detects a glitch in the middle of the start bit.

UART_SW_XOFF_INT: Triggered when UART_SW_FLOW_CON_EN is set and the receiver receives a Xoff
character.

UART_SW_XON_INT: Triggered when UART_SW_FLOW_CON_EN is set and the receiver receives a Xon
character.

UART_RXFIFO_TOUT_INT: Triggered when the receiver takes more time than UART_RX_TOUT_THRHD to
receive one byte.

UART_BRK_DET_INT: Triggered when the receiver detects a NULL character after stop bits.
UART_CTS_CHG_INT: Triggered when the receiver detects an edge change of CTSn signals.
UART_DSR_CHG_INT: Triggered when the receiver detects an edge change of DSRn signals.
UART_RXFIFO_OVF_INT: Triggered when the receiver receives more data than the capacity of RX FIFO,
UART_FRM_ERF_INT: Triggered when the receiver detects a data frame error.
UART_PARITY_ERR_INT: Triggered when the receiver detects a parity error.

UART_TXFIFO_EMPTY_INT: Triggered when TX FIFO stores less data than what
UART_TXFIFO_EMPTY_THRHD specifies.

UART_RXFIFO_FULL_INT: Triggered when the receiver receives more data than what
UART_RXFIFO_FULL_THRHD specifies.

UART_WAKEUP_INT: Triggered when UART is woken up.

8.3.12 UHCI Interrupts

UHCI_DMA_INFIFO_FULL_WIM_INT: Triggered when the counter value of DMA RX FIFO exceeds
UHCIDMA_INFIFO_FULL_THRS.

UHCISEND_A_REG_Q_INT: Triggered when DMA has sent a series of short packets using always_send.
UHCISEND_S_REG_Q_INT: Triggered when DMA has sent a series of short packets using single_send.
UHCI_OUT_TOTAL_EOF_INT: Triggered when all data has been sent.

UHCIOUTLINK_EOF_ERR_INT: Triggered when an EOF error is detected in a transmit descriptor.
UHCI_IN_DSCR_EMPTY_INT: Triggered when there are not enough receive descriptors for DMA.
UHCI_OUT_DSCR_ERRF_INT: Triggered when an error is detected in a transmit descriptor.
UHCI_IN_DSCR_ERRF_INT: Triggered when an error is detected in an receive descriptor.
UHCI_OUT_EOF_INT: Triggered when the EOF bit in a descriptor is 1.

UHCIOUT_DONE_INT: Triggered when a transmit descriptor is completed.

UHCI_IN_ERR_EOF_INT: Triggered when an EOF error is detected in an receive descriptor.

Espressif Systems 187 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
8. UART Controller

 

© UHCI_TX_HUNG_INT: Triggered when DMA spends too much time on reading RAM.

UHCI_IN_SUC_EOF_INT: Triggered when a data packet has been received.

UHCIIN_DONE_INT: Triggered when an receive descriptor is completed.

UHCIRX_HUNG_INT: Triggered when DMA spends too much time on receiving data.

e¢ UHCI_TX_START_INT: Triggered when DMA detects a separator character.

e UHCI_RX_START_INT: Triggered when a separator character has been sent.

8.4 Base Address

Users can access UARTO, UART1 and UHCIO respectively with two register base addresses shown in the

following table. For more information about accessing peripherals from different buses please see Chapter 1:

 

 

 

 

 

 

 

System and Memory.
Table 37: Base addresses of UARTO, UART1 and UHCIO

Name Bus to Access Peripheral Base Address

PeriBUS1 Ox3F400000
UARTO ;

PeriBUS2 Ox60000000

PeriBUS1 Ox3F410000
UART1 -

PeriBUS2 0x600 10000

PeriBUS1 Ox3F 414000
UHCIO -

PeriBUS2 0x60014000

 

 

 

 

 

8.5 Register Summary

The addresses in the following table are relative to the UART base addresses provided in Section 8.4.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access
FIFO Configuration

UART_FIFO_REG FIFO data register O0x0000 | RO
UART_MEM_CONF_REG UART threshold and allocation configuration Ox005C_ | RAV
Interrupt registers

UART_INT_RAW_REG Raw interrupt status 0x0004 | RO
Interrupt Register

UART_INT_ST_REG Masked interrupt status 0x0008 | RO
UART_INT_ENA_REG Interrupt enable bits Ox000C | RAV
UART_INT_CLR_REG Interrupt clear bits 0x0010 | WO
Configuration Register

UART_CLKDIV_REG Clock divider configuration 0x0014 | RAV
UART_CONFO_REG Configuration register 0 0x0020 | RAV
UART_CONF1_REG Configuration register 1 0x0024 | RAV
UART_FLOW_CONF_REG Software flow control configuration 0x0034 | RAV
UART_SLEEP_CONF_REG Sleeping mode configuration 0x0038 | RAV
UART_SWFC_CONFO_REG Software flow control character configuration Ox0038C_ | RAV
UART_SWFC_CONF1_REG Software flow-control character configuration 0x0040 | RAV

 

Espressif Systems

188

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
8. UART Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
UART_IDLE_CONF_REG Frame-end idle configuration 0x0044 | RAV
UART_RS485_CONF_REG RS485 mode configuration 0x0048 | RAV
Autobaud Register

UART_AUTOBAUD_REG Autobaud configuration register 0x0018 | RAV
UART_LOWPULSE_REG Autobaud minimum low pulse duration register | Ox0028 | RO
UART_HIGHPULSE_REG Autobaud minimum high pulse duration register | OxO02C | RO
UART_RXD_CNT_REG Autobaud edge change count register 0x0030 | RO
UART_POSPULSE_REG Autobaud high pulse register Ox006C | RO
UART_NEGPULSE_REG Autobaud low pulse register 0x0070 | RO
Status Register

UART_STATUS_REG UART status register 0x001C | RO
UART_MEM_TX_STATUS_REG TX FIFO write and read offset address Ox0060 | RO
UART_MEM_RX_STATUS_REG RX FIFO write and read offset address 0x0064 | RO
UART_FSM_STATUS_REG UART transmit and receive status 0x0068 | RO
AT Escape Sequence Selection Configuration

UART_AT_CMD_PRECNT_REG Pre-sequence timing configuration Ox004C | RAV
UART_AT_CMD_POSTCNT_REG Post-sequence timing configuration Ox0050 =| RAV
UART_AT_CMD_GAPTOUT_REG Timeout configuration 0x0054 | RAV
UART_AT_CMD_CHAR_REG AT Escape Sequence Selection Configuration O0x0058 | RAV
Version Register

UART_DATE_REG | UART version control register | oxoo74 | RW
Name | Description | Address | ACCess
Configuration Register

UHCI_CONFO_REG UHCI configuration register Ox0000 | RAV
UHCI_CONF1_REG UHCI configuration register Ox002C | RAV
UHCILAHB_TEST_REG AHB test register 0x0048 | RAV
UHCILESCAPE_CONF_REG Escape characters configuration Ox0064 | RAV
UHCILHUNG_CONF_REG Timeout configuration Ox0068 | RAV
UHCI_QUICK_SENT_REG UHCI quick send configuration register 0x0074 | RAV
UHCI_REG_QO_WORDO_REG QO_WORDO quick_sent register 0x0078 | RAV
UHCILREG_QO_WORD1_REG QO_WORD1 quick_sent register Ox007C | RAV
UHCILREG_Q1_WORDO_REG Q1_WORDO quick_sent register Ox0080 | RAV
UHCILREG_Q1_WORD1_REG Q1_WORD1 quick_sent register 0x0084 | RAV
UHCILREG_Q2_WORDO_REG Q2_WORDO quick_sent register O0x0088 | RAV
UHCILREG_Q2_WORD1_REG Q2_WORD1 quick_sent register Ox008C | RAV
UHCILREG_Q3_WORDO_REG Q3_WORDO quick_sent register Ox0090 | RAV
UHCI_REG_Q3_WORD1_REG Q3_WORD?1 quick_sent register 0x0094 | RAV
UHCILREG_Q4_WORDO_REG Q4_WORDO quick_sent register Ox0098 | RAV
UHCILREG_Q4_WORD1_REG Q4_WORD?1 quick_sent register Ox009C | RAV
UHCILREG_Q5_WORDO_REG Q5_WORDO quick_sent register OxO0AO | RAV
UHCILREG_Q5_WORD1_REG Q5_WORD?1 quick_sent register OxO0A4 | RAV
UHCI_REG_Q6_WORDO_REG Q6_WORDO quick_sent register OxO0A8 | RAV

 

Espressif Systems

189

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
8. UART Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
UHCI_REG_Q6_WORD1_REG Q6_WORD1 quick_sent register OxOOAC | RAV
UHCILESC_CONFO_REG Escape sequence configuration register O OxO0BO | RAV
UHCILESC_CONF1_REG Escape sequence configuration register 1 Ox00B4 | RAV
UHCILESC_CONF2_REG Escape sequence configuration register 2 Ox00B8 | RAV
UHCI_LESC_CONF3_REG Escape sequence configuration register 3 OxOOBC | RAV
UHCI_PKT_THRES_REG Configure register for packet length Ox00CO | RAV
Interrupt Register

UHCIINT_RAW_REG Raw interrupt status 0x0004 | RO
UHCI_INT_ST_REG Masked interrupt status 0x0008 | RO
UHCI_INT_ENA_REG Interrupt enable bits Ox000C | RAV
UHCI_INT_CLR_REG Interrupt clear bits 0x0010 | WO
DMA Status

UHCI_DMA_OUT_STATUS_REG DMA data-output status register 0x0014 | RO
UHCI_DMA_IN_STATUS_REG UHCI data-input status register 0x001C | RO
UHCI_STATEO_REG UHCI decoder status register 0x0030 | RO
UHCI_DMA_OUT_EOF_DES_ADDR Outlink descriptor address when EOF occurs 0x0038 | RO
_REG

UHCI_DMA_IN_SUC_EOF_DES_ ADDR | Inlink descriptor address when EOF occurs Ox0038C | RO
_REG

UHCI_DMA_IN_ERR_EOF_DES_ ADDR _ | Inlink descriptor address when errors occur 0x0040 | RO
_REG

UHCI_DMA_OUT_EOF_BFR_DES_ Outlink descriptor address before the last trans- | 0x0044 | RO
ADDR_REG mit descriptor

UHCI_DMA_IN_DSCR_REG The third word of the next receive descriptor 0x004C | RO
UHCI_DMA_IN_DSCR_BFO_REG The third word of current receive descriptor O0x0050 | RO
UHCI_DMA_IN_DSCR_BF1_REG The second word of current receive descriptor 0x0054 | RO
UHCI_DMA_OUT_DSCR_REG The third word of the next transmit descriptor 0x0058 | RO
UHCI_DMA_OUT_DSCR_BFO_REG The third word of current transmit descriptor Ox005C | RO
UHCI_DMA_OUT_DSCR_BF1_REG The second word of current transmit descriptor | OxOO60 | RO
UHCI_RX_HEAD_REG UHCI packet header register 0x0070 | RO
UHCI_STATE1_REG UHCI encoder status register 0x0084 | RO
DMA Configuration

UHCI_DMA_OUT_PUSH_REG Push control register of data-output FIFO 0x0018 | RAV
UHCI_DMA_IN_POP_REG Pop control register of data-input FIFO 0x0020 =| varies
UHCI_DMA_OUT_LINK_REG Link descriptor address and control 0x0024 | varies
UHCI_DMA_IN_LINK_REG Link descriptor address and control 0x0028 =| varies
Version Register

UHCI_DATE_REG UHCI version control register OxOOFC | RAV

 

Espressif Systems

190

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
8. UART Controller

 

8.6 Registers

Register 8.1: UART_FIFO_REG (0x0000)

 

 

 

 

 

 

 

x
¥
oa
€
& —-
ss ~
& »
| 31 8 | 7 o |
[oo 0000000000000 000000 00 9 Oxo |Reset
UART_RXFIFO_RD_BYTE This register stores one byte data read from RX FIFO. (RO)
Register 8.2: UART_MEM_CONF_REG (0x005C)
SQ © ©
SE & &
K7 7
sas © io w
» a ve
s 2K’ & & & & g
€ wr w wr vy yr
[a1 2s] a7 | 26 [2s 16 [is ie [3 ‘fo |
[foo 0 ofofo] Oxa OxO [| om | 1 [0 JReset

 

UART_RX_SIZE This register is used to configure the amount of mem allocated for RX FIFO. The
default number is 128 bytes. (RAV)

UART_TX_SIZE This register is used to configure the amount of mem allocated for TX FIFO. The
default number is 128 bytes. (RAV)

UART_RX_FLOW_THRHD This register is used to configure the maximum amount of data that can
be received when hardware flow control works. (R/W)

UART_RX_TOUT_THRHD This register is used to configure the threshold time that receiver takes to
receive one byte. The UART_RXFIFO_TOUT_INT interrupt will be triggered when the receiver takes
more time to receive one byte with UART RX_TOUT_EN set to 1. (RAM)

UART_MEM_FORCE PD Set this bit to force power down UART memory. (RAW)

UART_MEM_FORCE_PU Set this bit to force power up UART memory. (R/W)

Espressif Systems 191 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.3: UART_INT_RAW_REG (0x0004)

cae 4 $
oR Keo <? a
LEE LY LSS S SS. Si Ks
SFESEE SEBS SAP sa wwe
PEFR SS EEO LILES SES RSS
Ss FAS SL SO Soe sos SSS
SOROS OI SPOIL KK FOP EA OO”
FL PPieP Sr EF EOS QI EW EK
S\ PEI ASS WLR SEI LEG
& LE ELAN S SNK EE MA
s EEPEELEESEELS EES EESEESEE EEL’
& SPS SPS SPSS SSS SPS PF?

 

 

 

 

UART_RXFIFO_FULL_INT_RAW This interrupt raw bit turns to high level when receiver receives more
data than what UART_RXFIFO_FULL_THRHD specifies. (RO)

UART_TXFIFO_EMPTY_INT_RAW This interrupt raw bit turns to high level when the amount of data
in TX FIFO is less than what UART_TXFIFO_EMPTY_THRHD specifies. (RO)

UART_PARITY_ERR_INT_RAW This interrupt raw bit turns to high level when receiver cletects a parity
error in the data. (RO)

UART_FRM_ERR_INT_RAW This interrupt raw bit turns to high level when receiver detects a data
frame error. (RO)

UART_RXFIFO_OVF_INT_RAW This interrupt raw bit turns to high level when receiver receives more
data than the FIFO can store. (RO)

UART_DSR_CHG_INT_RAW This interrupt raw bit turns to high level when receiver detects the edge
change of DSRn signal. (RO)

UART_CTS_CHG_INT_RAW This interrupt raw bit turns to high level when receiver detects the edge
change of CTSn signal. (RO)

UART_BRK_DET_INT_RAW This interrupt raw bit turns to high level when receiver detects a 0 after
the stop bit. (RO)

UART_RXFIFO_TOUT_INT_RAW This interrupt raw bit turns to high level when receiver takes more
time than UART_RX_TOUT_THRHD to receive a byte. (RO)

UART_SW_XON_INT_RAW This interrupt raw bit turns to high level when receiver receives XON char-
acter when UART_SW_FLOW_CON_EN is set to 1. (RO)

UART_SW_XOFF_INT_RAW This interrupt raw bit turns to high level when receiver receives XOFF
character when UART_SW_FLOW_CON _EN is set to 1. (RO)

UART_GLITCH_DET_INT_RAW This interrupt raw bit turns to high level when receiver detects a
glitch in the middle of a start bit. (RO)

UART_TX_BRK_DONE_INT_RAW This interrupt raw bit turns to high level when transmitter com-
pletes sending NULL characters, after all data in TX FIFO are sent. (RO)

UART_TX_BRK_IDLE_DONE_INT_RAW This interrupt raw bit turns to high level when transmitter
has kept the shortest duration after sending the last data. (RO)
Continued on the next page...

Espressif Systems 192 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.3: UART_INT_RAW_REG (0x0004)

Continued from the previous page...

UART_TX_DONE_INT_RAW This interrupt raw bit turns to high level when transmitter has sent out
all data in FIFO. (RO)

UART_RS485_PARITY_ERR_INT_RAW This interrupt raw bit turns to high level when receiver de-
tects a parity error from the echo of transmitter in RS485 mode. (RO)

UART_RS485_FRM_ERR_INT_RAW This interrupt raw bit turns to high level when receiver detects
a data frame error from the echo of transmitter in RS485 mode. (RO)

UART_RS485_CLASH_INT_RAW This interrupt raw bit turns to high level when detects a clash be-
tween transmitter and receiver in RS485 mode. (RO)

UART_AT_CMD_CHAR_DET_INT_RAW This interrupt raw bit turns to high level when receiver de-
tects the configured UART_AT_CMD CHAR. (RO)

UART_WAKEUP_INT_RAW This interrupt raw bit turns to high level when input rxd edge changes
more times than what UART_ACTIVE_THRESHOLD specifies in Light-sleep mode. (RO)

Espressif Systems 193 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.4: UART_INT_ST_REG (0x0008)

Oe
Ay
N
\D >
Or
N
C3
AYO
\ Me
oe
A»
Sp

or
Ap
OK
Ke
Ze
4;
N Ay
ox
A>
4»
4,
Le
Wy,

8
Sy %
AG
AGO
08
s%
one
ey
OO
RY “bes
MY

\
>
\
>»
\
o
>»
\
>
\

a

 

 

 

 

UART_RXFIFO_FULL_INT_ST This is the status bit for UART_RXFIFO_FULL_INT_RAW when
UART_RXFIFO_FULL_INT_ENA is set to 1. (RO)

UART_TXFIFO_EMPTY_INT_ST This is the status bit for UART_TXFIFO_EMPTY_INT_RAW when
UART_TXFIFO_EMPTY_INT_ENA is set to 1. (RO)

UART_PARITY_ERR_INT_ST This is the status bit for UART_PARITY_ERR_INT_RAW when
UART_PARITY_ERR_INT_ENA is set to 1. (RO)

UART_FRM_ERR_INT_ST This is the status bi
UART_FRM_ERR_INT_ENA is set to 1. (RO)

it. for UART_FRM_ERR_INT RAW when

UART_RXFIFO_OVF_INT_ST This is the status bit for UART_RXFIFO_OVF_INT_RAW when
UART_RXFIFO_OVF_INT_ENA is set to 1. (RO)

UART_DSR_CHG_INT_ST This is the status bit for UART_DSR_-CHG_INT_RAW when
UART_DSR_CHG_INT_ENA is set to 1. (RO)

UART_CTS_CHG_INT_ST This is the status bit for UART_CTS_CHG_INT_RAW when
UART_CTS_CHG_INT_ENA is set to 1. (RO)

UART_BRK_DET_INT_ST This is the status bi
UART_BRK_DET_INT_ENA is set to 1. (RO)

it for UART_BRK_DET_INT_RAW when

UART_RXFIFO_TOUT_INT_ST This is the status bit for UART_RXFIFO_TOUT_INT_RAW when
UART_RXFIFO_TOUT_INT_ENA is set to 1. (RO)

UART_SW_XON_INT_ST This is the status bi
UART_SW_XON_INT_ENA is set to 1. (RO)

t for UART_SW_XON_INT_RAW — when

UART_SW_XOFF_INT_ST This is the status bit for UART_SW_XOFF_INT_RAW when
UART_SW_XOFF_INT_ENA is set to 1. (RO)

UART_GLITCH_DET_INT_ST This is the status bit for UART_GLITCH_DET_INT_RAW when
UART_GLITCH_DET_INT_ENA is set to 1. (RO)

UART_TX_BRK_DONE_INT_ST This is the status bit for UART_TX_BRK_DONE_INT_RAW when
UART_TX_BRK_DONE_INT_ENA is set to 1. (RO)

UART_TX_BRK_IDLE_DONE_INT_ST This is the status bit for
UART_TX_BRK_IDLE_DONE_INT_RAW when UART_TX_BRK_IDLE_DONE_INT_ENA is. set
to 1. (RO)

Continued on the next page...
Espressif Systems 194 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
8. UART Controller

 

Register 8.4: UART_INT_ST_REG (0x0008)

Continued from the previous page...

UART_TX_DONE_INT_ST This is the status bit for UART_TX_DONE_INT_RAW_ when
UART_TX_DONE_INT_ENA is set to 1. (RO)

UART_RS485_PARITY_ERR_INT_ST Thisisthe status bit for UART_RS485_PARITY_ERR_INT_RAW
when UART_RS485_PARITY_INT_ENA is set to 1. (RO)

UART_RS485_FRM_ERR_INT_ST This is the status bit for UART_RS485_FRM_ERR_INT_RAW
when UART_RS485_FM_ERR_INT_ENA is set to 1. (RO)

UART_RS485_CLASH_INT_ST This is the status bit for UART_RS485_CLASH_INT_RAW when
UART_RS485_CLASH_INT_ENA is set to 1. (RO)

UART_AT_CMD_CHAR_DET_INT_ST This is the status bit for UART_AT_CMD_DET_INT_RAW
when UART_AT_CMD_CHAR_DET_INT_ENA is set to 1. (RO)

UART_WAKEUP_INT_ST This is. the status bit for UART_WAKEUP_INT_RAW when
UART_WAKEUP_INT_ENA is set to 1. (RO)

Espressif Systems 195 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.5: UART_INT_ENA_REG (0x000C)






UART_RXFIFO_FULL_INT_ENA This is the enable bit for UART_RXFIFO_FULL_INT_ST register. (RAW)

UART_TXFIFO_EMPTY_INT_ENA This is the enable bit for UART_TXFIFO_EMPTY_INT_ST register. (RAW)

UART_PARITY_ERR_INT_ENA This is the enable bit for UART_PARITY_ERR_INT_ST register. (RAV)

UART_FRM_ERR_INT_ENA This is the enable bit for UART_FRM_ERR_INT_ST register. (RAV)

UART_RXFIFO_OVF_INT_ENA This is the enable bit for UART_RXFIFO_OVF_INT_ST register. (RAV)

UART_DSR_CHG_INT_ENA This is the enable bit for UART_DSR_CHG_INT_ST register. (R/W)
UART_CTS_CHG_INT_ENA This is the enable bit for UART_CTS_CHG_INT_ST register. (RAW)
UART_BRK_DET_INT_ENA This is the enable bit for UART_BRK_DET_INT_ST register. (RAV)

UART_RXFIFO_TOUT_INT_ENA This is the enable bit for UART_RXFIFO_TOUT_INT_ST register.
(RAW)

UART_SW_XON_INT_ENA This is the enable bit for UART_SW_XON_INT_ST register. (RAW)
UART_SW_XOFF_INT_ENA This is the enable bit for UART_SW_XOFF_INT_ST register. (R/W)

UART_GLITCH_DET_INT_ENA Thisis the enable bit for UART_GLITCH_DET_INT_ST register. (RAV)

UART_TX_BRK_DONE_INT_ENA This is the enable bit for UART_TX_BRK_DONE_INT_ST register.
(RAW)

UART_TX_BRK_IDLE_DONE_INT_ENA This is the enable bit for
UART_TX_BRK_IDLE_DONE_INT_ST register. (RAV)
UART_TX_DONE_INT_ENA This is the enable bit for UART_TX_DONE_INT_ST register. (R/W)

UART_RS485_PARITY_ERR_INT_ENA This is the enable bit for
UART_RS485_PARITY_ERR_INT_ST register. (R/W)

UART_RS485_FRM_ERR_INT_ENA This is the enable bit for UART_RS485_PARITY_ERR_INT_ST
register. (R/W)

Continued on the next page...

Espressif Systems 196 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.5: UART_INT_ENA_REG (0x000C)

Continued from the previous page...

UART_RS485_CLASH_INT_ENA This is the enable bit for UART_RS485_CLASH_INT_ST register.
(RAW)

UART_AT_CMD_CHAR_DET_INT_ENA This is the enable bit for
UART_AT_CMD_CHAR_DET_INT_ST register. (RAV)

UART_WAKEUP_INT_ENA This is the enable bit for UVART_WAKEUP_INT_ST register. (RAV)

Espressif Systems 197 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.6: UART_INT_CLR_REG (0x0010)

 

 

 

& SOF oe gz
LPOSEP SE’ SOQ S wz MvMS
PDR Ka YY oO Q S Ver OY
SF SCESL LESS LSS RIK IES
AER ERI GASES SESE
SISK PE FES OS SOK SEK”
S07 > < YS a7 Mo ge wy PEA? oO”
& LVI ECLMMN SE SELF EEE
Ss SEEEE EEE EEE EEE EEL EEE
€ WEP SP MP SP SP SPP? PPE EWP WP??? VF?
31 20] 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 o
0 0 0 0 0 0 0 0 o oflololofololo}lofololo}]olololo}]ololo]o]o] o IReset

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

UART_RXFIFO_FULL_INT_CLR Set this bit to clear UART_THE RXFIFO_FULL_INT_RAW interrupt.

(WO)

UART_TXFIFO_EMPTY_INT_CLR Set this bit to clear UART_TXFIFO_EMPTY_INT_RAW interrupt.

(WO)

UART_PARITY_ERR_INT_CLR_ Set this bit to clear UART_PARITY_ERR_INT_RAW interrupt. (WO)

UART_FRM_ERR_INT_CLR Set this bit to clear UART_FRM_ERR_INT_RAW interrupt. (WO)

UART_RXFIFO_OVF_INT_CLR_ Set this bit to clear UART_UART_RXFIFO_OVF_INT_RAW interrupt.

(WO)

UART_DSR_CHG_INT_CLR Set this bit to clear UART_DSR_CHG_INT_RAW interrupt. (WO)

UART_CTS_CHG_INT_CLR Set this bit to clear UART_CTS_CHG_INT_RAW interrupt. (WO)

UART_BRK_DET_INT_CLR Set this bit to clear UART_BRK_DET_INT_RAW interrupt. (WO)

UART_RXFIFO_TOUT_INT_CLR Set this bit to clear UART_RXFIFO_TOUT_INT_RAW interrupt.

(WO)

UART_SW_XON_INT_CLR Set this bit to clear UART_SW_XON_INT_RAW interrupt. (WO)

UART_SW_XOFF_INT_CLR Set this bit to clear UART_SW_XOFF_INT_RAW interrupt. (WO)

UART_GLITCH_DET_INT_CLR Set this bit to clear UART_GLITCH_DET_INT_RAW interrupt. (WO)

UART_TX_BRK_DONE_INT_CLR Set this bit to clear UART_TX_BRK_DONE_INT_RAW interrupt.

(WO)

UART_TX_BRK_IDLE_DONE_INT_CLR Set this bit to clear UART_TX_BRK_IDLE_DONE_INT_RAW
interrupt. (WO)

UART_TX_DONE_INT_CLR Set this bit to clear UART_TX_DONE_INT_RAW interrupt. (WO)

UART_RS485_PARITY_ERR_INT_CLR Set this bit to clear UART_RS485_PARITY_ERR_INT_RAW
interrupt. (WO)

UART_RS485_FRM_ERR_INT_CLR Set this bit to clear UART_RS485_FRM_ERR_INT_RAW inter-

rupt. (WO)
UART_RS485 CLASH INT_CLR Set this bit to clear UART_RS485_CLASH_INT_RAW interrupt.
(WO)
EspregSf esd.on the next page... 198 ESP32-S2 TRM (Preliminary VO.4)

Submit Documentation Feedback
8. UART Controller

Register 8.6: UART_INT_CLR_REG (0x0010)

Continued from the previous page...

UART_AT_CMD_CHAR_DET_INT_CLR_ Set this bit to clear UART_AT_CMD_CHAR_DET_INT_RAW
interrupt. (WO)

UART_WAKEUP_INT_CLR Set this bit to clear UART_WAKEUP_INT_RAW interrupt. (WO)

Register 8.7: UART_CLKDIV_REG (0x0014)

 

& wv
Se S
& & oo
s & &
& Na sy
[a1 2a [23 20 | 19 o|
[0 000 0 0 0 o| x0 |

 

 

Ox2b6 |Reset

 

UART_CLKDIV The integral part of the frequency divisor. (R/V)

UART_CLKDIV_FRAG The decimal part of the frequency divisor. (RAV)

Espressif Systems 199 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.8: UART_CONFO_REG (0x0020)

 

 

 

 

UART_PARITY This register is used to configure the parity check mode. 1’hO: even. 1’h1: odd.
(RAV)

UART_PARITY_EN Set this bit to enable UART parity check. (R/W)

UART_BIT_NUM This register is used to set the length of data. 0: 5 bits 1: 6 bits 2: 7 bits 3: 8 bits.
(RAV)

UART_STOP_BIT_NUM This register is used to set the length of stop bit. 1: 1 bit 2: 1.5 bits 3: 2
bits. (RAV)

UART_SW_RTS This register is used to configure the software RTS signal which is used in software
flow control. (RAN)

UART_SW_DTR This register is used to configure the software DTR signal which is used in software
flow control. (RAN)

UART_TXD_BRK_ Set this bit to enable transmitter to send NULL when the process of sending data
is done. (RAV)

UART_IRDA_DPLX_ Set this bit to enable IrDA loopback mode. (RAV)
UART_IRDA_TX_EN This is the start enable bit for IrDA transmitter. (RAV)

UART_IRDA_WCTL 1’h1: The IrDA transmitter’s 11th bit is the same as 10th bit. 1’hO: Set IrDA
transmitter’s 11th bit to 0. (RAV)

UART_IRDA_TX_INV_ Set this bit to invert the level of IrDA transmitter. (RAV)
UART_IRDA_RX_INV_ Set this bit to invert the level of IrDA receiver. (R/W)
UART_LOOPBACK Set this bit to enable UART loopback test mode. (RAV)
UART_TX_FLOW_EN Set this bit to enable flow control function for transmitter. (RAV)
UART_IRDA_EN Set this bit to enable IrDA protocol. (R/V)

UART_RXFIFO_RST Set this bit to reset the UART RX FIFO. (RAW)
UART_TXFIFO_RST Set this bit to reset the UART TX FIFO. (R/W)

UART_RXD_INV Set this bit to inverse the level value of UART RXD signal. (RAM)
UART_CTS_INV Set this bit to inverse the level value of UART CTS signal. (RAV)
UART_DSR_INV Set this bit to inverse the level value of UART DSR signal. (RAV)

Continued on the next page... ,
Espressif Systems 200 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
8. UART Controller

 

Register 8.8: UART_CONFO_REG (0x0020)

Continued from the previous page...

UART_TXD_INV_ Set this bit to inverse the level value of UART TXD signal. (RW)
UART_RTS_INV_ Set this bit to inverse the level value of UART RTS signal. (RAV)
UART_DTR_INV Set this bit to inverse the level value of UART DTR signal. (RAM)

UART_TICK_REF_ALWAYS_ON This register is used to select the clock. 1’h1: APB_CLK. 1’h0:
REF_TICK. (RAW)

UART_MEM_CLK_EN UART memory clock gate enable signal. 1: UART memory powers on, the
data of which can be read and written. 0: UART memory powers down. (R/W)

Register 8.9: UART_CONF1_REG (0x0024)

 

 

 

&
Soe & yy”
KL QRS ~~ Ss
COTS e- oe
eee > s _

SPP & w vy

| st | 2 | 29 | 2 [17 ole o|

| 0 | 0 | 0 [o 000000000 o| Ox60 | ox60 |Reset

 

UART_RXFIFO_FULL_THRHD It will produce UART_RXFIFO_FULL_INT interrupt when receiver re-
ceives more data than this register value. (R/W)

UART_TXFIFO_EMPTY_THRHD It will produce UART_TXFIFO_EMPTY_INT interrupt when the data
amount in TX FIFO is less than this register value. (RAV)

UART_RX_TOUT_FLOW_DIS. Set this bit to stop accumulating idle_cnt when hardware flow control
works. (RAW)

UART_RX_FLOW_EN This is the flow enable bit for UART receiver. 1’h1: Choose software flow
control with configuring sw_rts signal. 1’hO: Disable software flow control. (RAV)

UART_RX_TOUT_EN This is the enable bit for UART receiver's timeout function. (R/W)

Espressif Systems 201 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.10: UART_FLOW_CONF_REG (0x0034)




UART_SW_FLOW_CON_EN Set this bit to enable software flow control. It is used with register
SW_XON or SW_XOFF. (RAW)

UART_XONOFF_DEL Set this bit to remove flow control character from the received data. (RAW)
UART_FORCE_XON_ Set this bit to enable the transmitter to go on sending data. (RAM)
UART_FORCE_XOFF Set this bit to stop the transmitter from sending data. (R/W)

UART_SEND_XON Set this bit to send XON character. It is cleared by hardware automatically. (R/W)

UART_SEND_XOFF Set this bit to send XOFF character. It is cleared by hardware automatically.

 

 

 

(RAW)
Register 8.11: UART_SLEEP_CONF_REG (0x0038)




& S
[1 1o[» o|
joo9 0000000000009 00000 0 9 OxfO |Reset

 

UART_ACTIVE_THRESHOLD The UART is activated from light sleeping mode when the input rxd
edge changes more times than this register value. (RAV)

Espressif Systems 202 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.12: UART_SWFC_CONFO_REG (0x003C)








31 17 | 16 o}s °

 

000000000000 0 0 0 0x13 Oxe0 Reset

 

 

 

 

 

UART_XOFF_THRESHOLD When the data amount in RX FIFO is more than this register value with
UART_SW_FLOW_CON_EN set to 1, it will send a XOFF character. (R/W)

UART_XOFF_CHAR This register stores the XOFF flow control character. (RAW)

Register 8.13: UART_SWFC_CONF1_REG (0x0040)

 

 

 

jo 0 0 9 0 0000000 0 0 Of Oxt1 | OxO |Reset

 

UART_XON_THRESHOLD When the data amount in RX FIFO is less than this register value with
UART_SW_FLOW_CON_EN set to 1, it will send a XON character. (RAM)

UART_XON_CHAR This register stores the XON flow control character. (R/V)

Register 8.14: UART_IDLE_CONF_REG (0x0044)


dummy
 

Register 8.15: UART_RS485_CONF_REG (0x0048)



dummy
UART_RS485_EN Set this bit to choose the RS485 mode. (R/W)
UART_DLO_EN Set this bit to delay the stop bit by 1 bit. (RAV)
UART_DL1_EN Set this bit to delay the stop bit by 1 bit. (RAV)

UART_RS485TX_RX_EN Set this bit to enable receiver could receive data when the transmitter is
transmitting data in RS485 mode. (RAV)

UART_RS485RXBY_TX_EN_ 1’h1: enable RS485 transmitter to send data when RS485 receiver line
is busy. 17hO: RS485 transmitter should not send data when its receiver is busy. (R/W)

UART_RS485_RX_DLY_NUM This register is used to delay the receiver's internal data signal. (R/W)

UART_RS485_TX_DLY_NUM This register is used to delay the transmitter’s internal data signal.
(RAV)

Register 8.16: UART_AUTOBAUD_REG (0x0018)





 

 

 

[oo 0 900000000000 9 Oxi jo 9 0 0 0 0 0/0 Reset

 

UART_AUTOBAUD EN This is the enable bit for detecting baudrate. (RW)

UART_GLITCH_FILT when input pulse wicth is lower than this value, the pulse is ignored. This register
is used in autobaud detect process. (RAV)

Espressif Systems 204 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.17: UART_LOWPULSE_REG (0x0028)

 

31 20 | 19 °

 

0 0 0000 00 0 0 0 0 Oxtffft Reset

 

 

 

 

UART_LOWPULSE_MIN_CNT This register stores the value of the minimum duration time of the low
level pulse. It is used in baud rate detection. (RO)

Register 8.18: UART_HIGHPULSE_REG (0x002C)

 

 

 

os
~
al
pv
x
S w
& sy
[a1 20 | 19 o|
fo 0 0 9 000000 0 Of Oxfffif |Reset

 

UART_HIGHPULSE _MIN_CNT This register stores the value of the maximum duration time for the
high level pulse. It is used in baud rate detection. (RO)

Register 8.19: UART_RXD_CNT_REG (0x0030)

 

[a1 ro] o|

 

 

jo0 9000000000000 00000 0 0 x0 |Reset

 

UART_RXD_EDGE_CNT This register stores the count of rxd edge change. It is used in baud rate
detection. (RO)

Espressif Systems 205 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.20: UART_POSPULSE_REG (0x006C)

 

 

 

os
we’
x
& &
é x
[1 20] 19 o|
fo 0 9 9 009 000 0 9 Oxtftf |Reset

 

UART_POSEDGE_MIN_CNT This register stores the minimal input clock count between two positive
edges. It is used in baud rate detection. (RO)

Register 8.21: UART_NEGPULSE_REG (0x0070)

 

31 20 | 19 °

 

 

 

 

0 0 0000 00 0 0 0 0 Oxtffft Reset

 

UART_NEGEDGE_MIN_CNT This register stores the minimal inout clock count between two negative
edges. It is used in baud rate detection. (RO)

Espressif Systems 206 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.22: UART_STATUS_REG (0x001C)

 

 

&} j
of of
Se eo Se a
LES xs OE af
SEE s eo’ SEE’ s A?
SS e S SK SI & S
31 30 29 28 26) 25 16 15 14 13 12 10} 9 oO
oxo] oJ 0/0 oO O 0x0 o}o]/ojo o oO Ox0 Reset

 

 

 

 

 

 

 

 

 

 

 

 

UART_RXFIFO_CNT Stores the byte number of valid data in RX FIFO. (RO)
UART_DSRN The register represent the level value of the internal UART DSR signal. (RO)
UART_CTSN This register represent the level value of the internal UART CTS signal. (RO)
UART_RXD This register represent the level value of the internal UART RXD signal. (RO)
UART_TXFIFO_CNT Stores the byte number of data in TX FIFO. (RO)

UART_DTRN This bit represents the level of the internal UART DTR signal. (RO)
UART_RTSN This bit reoresents the level of the internal UART RTS signal. (RO)

UART_TXD This bit represents the level of the internal UART TXD signal. (RO)

Register 8.23: UART_MEM_TX_STATUS_REG (0x0060)

 

 

 

ge
Sv
Ss e
S s S &”
x & x ee
Ro Ss AG SS
[1 a|2 u| 10 |» o|
[o 000000000 o| Oxo [o| ox0 |Reset

 

UART_APB_TX_WADDR This register stores the offset address in TX FIFO when software writes TX
FIFO via APB. (RO)

UART_TX_RADDR This register stores the offset address in TX FIFO when TX FSM reads data via
Tx_FIFO_Ctrl. (RO)

Espressif Systems 207 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

Register 8.24: UART_MEM_RX_STATUS_REG (0x0064)






Y
Ss Ss
Ss os
S & S ¢
s é’ x7
& ¥ & S
[a1 a1 | 20 nf 10 [s o|
fo 0 0 0 00 0 0 0 0 9 oxo [o] Ox0 |Reset

 

UART_APB_RX_RADDR This register stores the offset address in RX_FIFO when software reads cata
from RX FIFO via APB. (RO)

UART_RX_WADDR This register stores the offset address in RX FIFO when Rx_FIFO_Ctrl writes RX

 

 

 

 

 

 

 

 

 

 

FIFO. (RO)
Register 8.25: UART_FSM_STATUS_REG (0x0068)
&
cS
Ss Ss
& OY OY
s K7 x7
& SI SI
31 B17 4/3 0
000 000000000000 0000 00 00 0 oxo oxo Reset
UART_ST_URX_OUT This is the status register of receiver. (RO)
UART_ST_UTX_OUT This is the status register of transmitter. (RO)
Register 8.26: UART_AT CMD _PRECNT_REG (0x004C)
>
LS
WO
Q
& ee
ss <?
& S)
[a1 16 [is o|
fo0 9 00009000000 0 0 9 Ox901 |Reset

 

UART_PRE_IDLE_NUM This register is used to configure the idle duration time before the first
AT_CMD is received by receiver. It will not take the next data received as AT_CMD character

when the duration is less than this register value. (RAV)

Espressif Systems 208 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.27: UART_AT_ CMD_POSTCNT_REG (0x0050)

 

 

 

s
yy
Ry
\
SY
S &
& sy
[1 16 [15 o|
[oo 0 900000000000 9 Ox901 |Reset

 

UART_POST_IDLE_NUM This register is used to configure the duration time between the last
AT_CMD and the next data. It will not take the previous data as AT_CMD character when the
duration is less than this register value. (R/W)

Register 8.28: UART_AT_ CMD_GAPTOUT_REG (0x0054)

 

 

 

of
Ss’
A
eo ra
& sy
[1 16 [15 o|
[oo 0 900000000000 9 11 |Reset

 

UART_RX_GAP_TOUT This register is used to configure the duration time between the AT_CMD
chars. It will not take the data as continuous AT_CMD chars when the duration time is less than
this register value. (R/W)

Register 8.29: UART_AT_CMD_CHAR_REG (0x0058)

 

 

 

SS a
© _
. :
s & ev
& y »y
[1 16 [15 al7 o|
[o 0000000000000 0 o| 0x3 | Ox2b |Reset

 

UART_AT_CMD_CHAR This register is Used to configure the content of AT_CMD character. (RAW)

UART_CHAR_NUM This register is used to configure the number of continuous AT_CMD chars re-
ceived by receiver. (R/W)

Espressif Systems 209 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.30: UART_DATE_REG (0x0074)

x
x
& 7
wy

 

 

| 0x 18082800

| Reset

 

UART_DATE This is the version control register. (RW)

Espressif Systems 210
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
8. UART Controller

 

Register 8.31: UHCI_CONFO_REG (0x0000)

 

 

 

 

UHCI_IN_RST Set this bit to reset in DMA FSM. (RAV)

UHCI_OUT_RST Set this bit to reset out DMA FSM. (RAW)
UHCI_AHBM_FIFO_RST Set this bit to reset AHB interface cmdFIFO of DMA. (RAV)
UHCI_AHBM_RST Set this bit to reset AHB interface of DMA. (R/W)
UHCI_IN_LOOP_TEST Reserved. (R/W}

UHCI_OUT_LOOP_TEST Reserved. (R/W)

UHCLOUT_AUTO_WRBACK Set this bit to enable automatic outlink-writeback when all the data in
TX Buffer has been transmitted. (R/W)

UHCI_OUT_NO_RESTART_CLR_ Reserved. (RAW)

UHCI_OUT_EOF_MODE This register is used to specify the generation mode of UHCI_OUT_EOF_INT
interrupt. 1: When DMA has popped all data from FIFO. 0: When AHB has pushed all data to FIFO.

(RW)
UHCI_UARTO_CE Set this bit to link up HCl and UARTO. (RAW)
UHCI_UART1_CE Set this bit to link up HCl and UART1. (RAW)

UHCI_OUTDSCR_BURST_EN This register is used to specify DMA transmit descriptor transfer
mode. 1: burst mode. 0: byte mode. (R/V)

UHCI_INDSCR_BURST_EN This register is used to specify DMA receive descriptor transfer mode.
1: burst mode. 0: byte mode. (R/V)

UHCI_OUT_DATA_BURST_EN This register is used to specify data transfer mode. 1: Transmit data
in burst mode. O: Transmit data in byte mode. (R/V)

UHCI_MEM_TRANS_EN 1: UHCI transmitted data would be write back into DMA INFIFO. (RAV)
UHCI_SEPER_EN Set this bit to separate the data frame using a special char. (RAW)
UHCI_HEAD EN Set this bit to encode the data packet with a formatting header. (RAV)
UHCI_CRC_REC EN Set this bit to enable UHCI to receive the 16 bit CRC. (R/V)

UHCI_UART_IDLE EOF_EN If this bit is set to 1, UHCI will end the payload receiving process when
UART has been in idle state. (RAV)

Continued on the next page...

Espressif Systems 214 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
8. UART Controller

 

Register 8.31: UHCI_CONFO_REG (0x0000)

Continued from the previous page...

UHCI_LEN_EOF_EN If this bit is set to 1, UHCI decoder receiving payload data is end when the
receiving byte count has reached the specified value. The value is payload length indicated
by UCHI packet header when UHCILHEAD_EN is 1 or the value is a configuration value when
UHCI_HEAD_EN is 0. If this bit is set to 0, UHCI decoder receiving payload data is end when OxcO
is received. (RAV)

UHCI_ENCODE CRC _EN Set this bit to enable data integrity checking by appending a 16 bit CCITT-
CRC to the end of the payload. (R/W)

UHCI_CLK_EN 1’b1: Force clock on for register. 1’b0: Support clock only when application writes
registers. (RAV)

UHCI_UART_RX_BRK_EOF_EN if this bit is set to 1, UHCI will end payload_rec process when NULL
frame is received by UART. (RAV)

Espressif Systems 212 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.32: UHCI_CONF1_REG (0x002C)





» ES SS ¢ OS
eo 6 SS MFo Sos “
«S wy O oO KN S
S LI FSR
& x SMM ERE
& Ov Oo! Oo”. Oo! Oo”. Oo! Oo”. Om. Oo”. Ov
& S KKK YK KK Ky
[1 a|2 ofelefefs]«[s]e] [eo]
[fo 0 0 0 0 0 0 0 0 9 Of 0 fofofo]+[1fo]o]i [7 JReset

UHCI_CHECK_SUM_EN This is the enable bit to check header checksum when UHCI receives a
data packet. (RAW)

UHCI_CHECK_SEQ EN Thisis the enable bit to check sequence number when UHCI receives a data
packet. (RAW)

UHCI_CRC_DISABLE Set this bit to support CRC calculation. Data Integrity Check Present bit in
UHCI packet frame should be 1. (RAV)

UHCI_SAVE_HEAD Set this bit to save the packet header when HC! receives a data packet. (R/W)

UHCI_TX_CHECK_SUM_RE Set this bit to encode the data packet with a checksum. (RAW)

UHCI_TX_ACK_NUM_RE Set this bit to encode the data packet with an acknowledgement when a
reliable packet is to be transmit. (RW)

UHCI_CHECK_OWNER 1: Check the link list descriptor when link list owner is DMA controller; 0:
Always check link list descriptor. (R/W)

UHCI WAIT_SW_START The uhci-encoder will jump to ST_SW_WAIT status if this register is set to
1. (RW)

UHCI_SW_START If current UHCI_ENCODE_STATE is ST_SW_WATT, the UHC] will start to send data
packet out when this bit is set to 1. (RAM)

UHCI_DMA_INFIFO_FULL_THRS This field is used to generate the
UHCI_DMA_INFIFO_FULL_WM_INT interrupt when the counter value of DMA RX FIFO ex-
ceeds the value of the register. (R/W)

Espressif Systems 213 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
8. UART Controller

 

Register 8.33: UHCI_AHB_TEST_REG (0x0048)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Sx X
eS
oe oe
d 4 dS 4
a Ov ra Ov
& SF Ss
| 31 6 | 5 4 | 3 | 2 0 |
joo 0 0000000000000 00000 0000 of 0 [of 0 IReset
UHCI_AHB TESTMODE Reserved. (R/W)
UHCI_AHB TESTADDR Reserved. (RAV)
Register 8.34: UHCI ESCAPE CONF_REG (0x0064)
SAS SSAA SO
& For S. SL ore “or
RDIARA?LY D7 D7 L HP?
a a. a. Ene any. AR, aA
s \/ Oo”. OY. Oo”. Oo”. Om™. Oo”. Ov
& SMH HHI
31 8 7 6 5 4 3 2 1 0
000000000 00 000060 00 0 0 0 0 0 0 ofofo}1}1}o}o}1] 7 IReset
UHCI_TX_CO_ESC_EN Set this bit to enable decoding char OxcO when DMA receives data. (R/W)
UHCI_TX_DB_ESC EN Set this bit to enable decoding char Oxdb when DMA receives data. (RAV)
UHCI_TX_11_ESC_EN Set this bit to enable decoding flow control char 0x11 when DMA receives
data. (RAV)
UHCI_TX_13_ ESC _EN Set this bit to enable decoding flow control char 0x13 when DMA receives
data. (RAV)
UHCI_RX_CO_ESC_EN Set this bit to enable replacing OxcO by special char wnen DMA sends data.
(RAV)
UHCI_RX_DB_ESC EN Set this bit to enable replacing Oxdb by special char when DMA sends data.
(RAV)
UHCI_RX_11_ESC EN Set this bit to enable replacing flow control char 0x11 by special char when
DMA sends data. (RAV)
UHCI_RX_13_ ESC EN Set this bit to enable replacing flow control char 0x13 by special char when
DMA sends data. (RAV)
Espressif Systems 214 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
8. UART Controller

 

Register 8.35: UHCI_HUNG_CONF_REG (0x0068)

Ss x sr

AY «SE & AY &e &

SS 3 SES ~

wv VE Ww
A NS A A A A

5 SOS «
S ee e

 

[1 | 23 [22 219 12

|
[o 00000 0 of 7 | 0 | Ox10 [7] 0 | oxt0 |Reset

 

UHCI TXFIFO_TIMEOUT This register stores the timeout value. It will produce the
UHCI_TX_HUNG_INT interrupt when DMA takes more time to receive data. (RAW)

UHCI TXFIFO_TIMEOUT_SHIFT This register is used to configure the tick count maximum value.
(RAV)

UHCI TXFIFO_TIMEOUT_ENA This is the enable bit for Tx-FIFO receive-data timeout. (RAV)

UHCI_RXFIFO_TIMEOUT This register stores the timeout value. It will produce the
UHCILRX_HUNG_INT interrupt when DMA takes more time to read data from RAM. (R/W)

UHCI_RXFIFO_TIMEOUT SHIFT This register is used to configure the tick count maximum value.

(RW)

UHCI_RXFIFO_TIMEOUT_ENA This is the enable bit for DMA send-data timeout. (R/V)

Register 8.36: UHCI_QUICK_SENT_REG (0x0074)

 

 

ve ve @®
& Ss Ss Ss Ss
s Ov \7 Ov Ov
ys ys ys ys
& SS LS
31 8 7 6 4 3 2 o
00000000000 0060 00 00 0 0 0 0 0 0 of0 oxo 6} 0] oxo Reset

 

 

 

 

 

 

 

UHCI SINGLE _SEND_ NUM This register is used to specify the single_send register. (R/V)
UHCI SINGLE SEND EN Set this bit to enable single_send mode to send short packet. (RAV)
UHCI ALWAYS SEND NUM This register is used to specify the always_send register. (RAM)

UHCI_ALWAYS SEND EN Set this bit to enable always_send mode to send short packet. (R/W)

Espressif Systems 215 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.37: UHCI_REG_QO_WORDO_REG (0x0078)

 

 

 

S
S&S
ce”
4
s
Ov
sy

[a 0]
| 0x000000 | Reset

 

UHCI_SEND_QO WORDO This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.38: UHCI_REG_QO_WORD1_REG (0x007C)

N
SF
oF
&
Ov
sy
[a 0]

| 0x000000 | Reset

 

 

 

UHCI_SEND_QO WORD1 This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.39: UHCI_REG_Q1_WORDO_REG (0x0080)

 

 

 

©
&
& 4
S 4
Ov
sy
[= |
| 0x000000 | Reset

 

UHCI_SEND_Qi_WORDO This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Espressif Systems 216 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.40: UHCI_REG_Q1_WORD1_REG (0x0084)

 

 

 

&
& 4
gS
Ov
sy
[a 0]
| 0x000000 | Reset

 

UHCI_SEND_Qi_WORD1 This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.41: UHCI_REG_Q2_ WORDO_REG (0x0088)

S
Lg

S&F

oy

O f

&

Ov

sy

[ 7]

| 0x000000 | Reset

 

 

 

UHCI_SEND_Q2 WORDO This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.42: UHCI_REG_Q2_WORD1_REG (0x008C)

 

 

 

eS
»s
oy
4
S
Ov
sy

[= |
| 0x000000 | Reset

 

UHCI_SEND_Q2 WORD1 This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Espressif Systems 217 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.43: UHCI_REG_Q3_WORDO_REG (0x0090)

 

 

 

S
S&S
cP”
4
s
Ov
sy

[a 0]
| 0x000000 | Reset

 

UHCI_SEND_Q3_ WORDO This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.44: UHCI_REG_Q3_WORD1_REG (0x0094)

N
SF
oF
&
Ov
sy
[a 0]

| 0x000000 | Reset

 

 

 

UHCI_SEND_Q3_WORD1 This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.45: UHCI_REG_Q4_WORDO_REG (0x0098)

 

 

 

S
S&S
a
4
3
Ov
sy

[= |
| 0x000000 | Reset

 

UHCI_SEND_Q4 WORDO This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Espressif Systems 218 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.46: UHCILREG_Q4_WORD1_REG (0x009C)
\
&
a
oO”
S

\7
se

[ 7]

| 0x000000 | Reset

 

 

 

UHCI_SEND_Q4 WORD1 This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.47: UHCI_REG_Q5_WORDO_REG (0x00A0)

S

Lg
S&F
&

Ov

sy

[ 7]

| 0x000000 | Reset

 

 

 

UHCI_SEND_Q5 WORDO This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.48: UHCI_REG_Q5_WORD1_REG (0x00A4)

 

 

 

aN
&
oe”
4
S
Ov
sy

[= |
| 0x000000 | Reset

 

UHCI_SEND_Q5 WORD1 This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Espressif Systems 219 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.49: UHCI_REG_Q6_WORDO_REG (0x00A8)

 

 

 

S
S&S
ce’
4
s
Ov
sy

[a 0]
| 0x000000 | Reset

 

UHCI_SEND_Q6 WORDO This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.50: UHCI_REG_Q6_WORD1_REG (Ox00AC)

 

 

 

aN
&
ce’
4
s
Ov
sy

[a 0]
| 0x000000 | Reset

 

UHCI_SEND_Q6 WORD1 This register is used as a quick_sent register when specified by
UHCI ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM. (R/W)

Register 8.51: UHCI_ESC_CONFO_REG (0x00B0)

 

 

A 9S
we ws

Oo Oo? &

Ka Ka e
§ § 8
S g g g
é o Oo oe
@ Ss Ss S
31 24 | 23 16] 15 el7 oO
0 0 0 0 0 0 0 0 Oxdc Oxdb OxcO Reset

 

 

 

 

 

 

UHCI_SEPER_CHAR This register is used to define the separate char that need to be encoded,
default is Oxc0. (RAV)

UHCI_SEPER_ESC CHARO This register is used to define the first char of slip escape sequence
when encoding the separate char, default is Oxdb. (RAW)

UHCI_SEPER_ESC CHART This register is used to define the second char of slip escape sequence
when encoding the separate char, default is Oxdce. (RW)

Espressif Systems 220 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.52: UHCI_ESC_CONF1_REG (0x00B4)

 

 

 

\ ©
e “
97 97 ©
& SF SF
& & 4 & 4 & 4
s Ov Ov Ov
of ee yy Xs
€ S S S
[1 x |2s 16 [15 al7 o|
| 00000000 | oxdd | oxdb | oxdb |Reset

 

UHCI_ESC_SEQ0O This register is used to define a char that need to be encoded, default is Oxdb that
used as the first char of slip escape sequence. (RAV)

UHCI_ESC_ SEQO_CHARO This register is used to define the first char of slio escape sequence when
encoding the UHCI_LESC_SEQO, default is Oxdb. (RAV)

UHCI_ESC SEQO CHART This register is used to define the second char of slip escape sequence
when encoding the UHC|_ESC_SEQ0, default is Oxdd. (RAM)

Register 8.53: UHCI_ESC_CONF2_REG (0x00B8)

 

 

 

\ oO
Ks “
NZ NZ “\
& & &
& & f & f & f
Ss Oo Ow Oo”
of ee yy Xs
€ S S S
[1 x |2s 16 [15 al7 o|
| 00000000 | Oxde | oxdb | oxt1 |Reset

 

UHCI_ESC_SEQ1 This register is used to define a char that need to be encoded, default is Ox11 that
used as flow control char. (R/W)

UHCI_ESC SEQ1_CHARO This register is used to define the first char of slip escape sequence when
encoding the UHCI_LESC_SEQ1, default is Oxdb. (RAV)

UHCI_ESC SEQ1_CHAR1 This register is used to define the second char of slip escape sequence
when encoding the UHCI_ESC_SEQ1, default is Oxde. (R/W)

Espressif Systems 221 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.54: UHCI_ESC_CONF3_REG (0x00BC)

 

 

 

< &
Roe ye
V7 VW V
& & &
& & 4 & 4 & 4
s Ov Ov Ov
of ee yy Xs
€ S S S
[1 x |2s 16 [15 al7 o|
| 00000000 | Oxdlf | oxdb | Ox13 |Reset

 

UHCI_ESC_SEQ2 This register is used to define a char that need to be decoded, default is 0x13 that
used as flow control char. (R/W)

UHCI_ESC SEQ2 CHARO This register is used to define the first char of slip escape sequence when
encoding the UHCI_LESC_SEQ2, default is Oxdb. (RAV)

UHCI_ESC SEQ2 CHART This register is used to define the second char of slip escape sequence
when encoding the UHCI_ESC_SEQ2, default is Oxdf. (RW)

Register 8.55: UHCI_PKT_THRES_REG (0x00C0)

 

 

 

O
&
S se’
sf o
& ys
[a1 3] 2 o|
foo 9000000000000 0 00 0 oxe0 |Reset

 

UHCI_PKT_THRS This register is used to configure the maximum value of the packet length when
UHCI_HEAD_EN is 0. (RW)

Espressif Systems 222 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

Register 8.56: UHCI_INT_RAW_REG (0x0004)

ge S NT OYA CYA OY CYY
- SSS SVSS
14 13 12 1

Oo;0;0);0;)/0)]0

 

 

 

 

 

 

 

 

17] 16 15
0) 90] 0] 0 [Reset

 

 

 

 

 

 

 

 

 

 

 

 

0 0 0 OJ 0);0

 

 

UHCI_RX_START_INT_RAW This is the interrupt raw bit. Triggered when a separator char has been

sent. (RO)
UHCI_TX_START_INT_RAW This is the interrupt raw bit. Triggered when DMA detects a separator

char. (RO)
UHCI_RX_HUNG_INT_RAW This is the interrupt raw bit. Triggered when DMA takes more time to

receive data than the configure value. (RO)
. Triggered when DMA takes more time to

UHCI TX_HUNG_INT_RAW This is the interrupt raw bit

read data from RAM than the configured value. (RO)
Triggered when an receive descriptor is

UHCI_IN_DONE_INT_RAW This is the interrupt raw bit
completed. (RO)
UHCI_IN_SUC_EOF_INT_RAW Thisis the interrupt raw bit. Triggered when a data packet has been

received successfully. (RO)
UHCI_IN_ERR_EOF_INT_RAW Thisis the interrupt raw bit. Triggered when there are some errors in

EOF in the receive descriptor. (RO)
UHCI_OUT_DONE_INT_RAW This is the interrupt raw bit. Triggered when an transmit descriptor is

completed. (RO)
UHCI_OUT_EOF_INT_RAW Thisis the interrupt raw bit. Triggered when the current descriptors EOF

bit is 1. (RO)
UHCI_IN_DSCR_ERR_INT_RAW This is the interrupt raw bit. Triggered when there are some errors

in the receive descriptor. (RO)
UHCI_OUT_DSCR_ERR_INT_RAW This is the interrupt raw bit. Triggered when there are some er-

rors in the transmit descriptor. (RO)
UHCIIN_DSCR_EMPTY_INT_RAW This is the interrupt raw bit. Triggered when there are not
enough inlinks for DMA. (RO)
UHCI OUTLINK_EOF_ERR_INT_RAW This is the interrupt raw bit. Triggered when there are some
errors in EOF in the transmit descriptor. (RO)
UHCI OUT_TOTAL_EOF_INT_RAW This is the interrupt raw bit. Triggered when all data in the last

buffer address has been sent out. (RO)

Continued on the next page...
223 ESP32-S2 TRM (Preliminary V0.4)

Espressif Systems
Submit Documentation Feedback
8. UART Controller

 

Register 8.56: UHCI_INT_RAW_REG (0x0004)

Continued from the previous page...

UHCI_SEND_S REG_Q_INT_RAW Thisis the interrupt raw bit. Triggered when DMA has sent out a
short packet using single_send registers. (RO)

UHCI_SEND_A REG_Q_INT_RAW This is the interrupt raw bit. Triggered when DMA has sent out a
short packet using always_send registers. (RO)

UHCI DMA_INFIFO_FULL_WM_INT_RAW This is the interrupt raw bit. Triggered when the DMA
INFIFO count has reached the configured threshold value. (RO)

Espressif Systems 224 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.57: UHCI_INT_ST_REG (0x0008)

Oo
oN
5
XQ)
an
ok
yp
aS
ny N
ae
4
%
Ke
%
os

& OMOLZOY OXY OL OY OY OY OY OY OY OY OY. OY” OY”
@ OTOYODOGOSOYXO OTOGOSOYODOGOSOXO
& KHIM KK HH Gee FS HTS

[1 we foslul ele] alos

 

 

[«[-][e]=]+]>]>]
[o 0000000000000 ofofofofofolofofofolofo]folofofo]o

 

UHCI_RX_START_INT_ST This is the masked interrupt bit for UHCI_RX_START_INT interrupt when
UHCI_RX_START_INT_ENA is set to 1. (RO)

UHCI_TX_START_INT_ST This is the masked interrupt bit for UHCI_TX_START_INT interrupt when
UHCI_TX_START_INT_ENA is set to 1. (RO)

UHCI_RX_HUNG_INT_ST This is the masked interrupt bit for UHCI_RX_HUNG_INT interrupt when
UHCI_RX_HUNG_INT_ENA is set to 1. (RO)

UHCI_TX_HUNG_INT_ST This is the masked interrupt bit for UHCI_TX HUNG_INT interrupt when
UHCI_TX_HUNG_INT_ENA is set to 1. (RO)

UHCI_IN_DONE_INT_ST This is the masked interrupt bit for UHCIIN_ DONE_INT interrupt when
UHCI_IN_DONE_INT_ENA is set to 1. (RO)

UHCI_IN_SUC_EOF_INT_ST This is the masked interrupt bit for UHCI_IN_ SUC_EOF_INT interrupt
when UHCI_IN_SUC_EOF_INT_ENA is set to 1. (RO)

UHCI_IN_ERR_EOF_INT_ST This is the masked interrupt bit for UHCLIN_ERR_EOF_INT interrupt
when UHCI_IN_ERR_EOF_INT_ENA is set to 1. (RO)

UHCI_OUT_DONE_INT_ST Thisis the masked interrupt bit for UHCI_OUT_DONE_INT interrupt when
UHCI_OUT_DONE_INT_ENA is set to 1. (RO)

UHCI_OUT_EOF_INT_ST This is the masked interrupt bit for UHC|_OUT_EOF_INT interrupt when
UHCI_OUT_EOF_INT_ENA is set to 1. (RO)

UHCI_IN_DSCR_ERR_INT_ST This is the masked interrupt bit for UHCI_IN_DSCR_ERR_INT inter-
rupt when UHCI_IN_DSCR_ERRF_INT is set to 1. (RO)

UHCI_OUT_DSCR_ERR_INT_ST This is the masked interrupt bit for UHCIOUT_DSCR_ERR_INT
interrupt when UHCl_OUT_DSCR_ERR_INT_ENA is set to 1. (RO)

UHCI_IN_DSCR_EMPTY_INT_ST This is the masked interrupt bit for UHCI_IN_DSCR_EMPTY_INT
interrupt when UHCI_IN_DSCR_EMPTY_INT_ENA is set to 1. (RO)

UHCI_OUTLINK_EOF_ERR_INT_ST This is the masked interrupt bit for
UHCI_OUTLINK_EOF_ERR_INT interrupt when UHCIOUTLINK_EOF_ERR_INT_ENA is_ set
to 1. (RO)

UHCI_OUT_TOTAL_EOF_INT_ST This is the masked interrupt bit for UHCI_OUT_TOTAL_EOF_INT
interrupt when UHCL_OUT_TOTAL_EOF_INT_ENA is set to 1. (RO)

EspreGandinugden the next page... 225 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.57: UHCI_INT_ST_REG (0x0008)

Continued from the previous page...

UHCI_SEND_S REG_Q_INT_ST Thisis the masked interrupt bit for UHCI_SEND_S_REG_Q_INT in-
terrupt when UHCI_SEND_S _REG_Q_INT_ENA is set to 1. (RO)

UHCI_SEND_A REG_Q_INT_ST Thisis the masked interrupt bit for UHCILSEND_A_ REG_Q_INT in-
terrupt when UHCI_SEND_A_REG_Q_INT_ENA is set to 1. (RO)

UHCI_DMA_INFIFO_FULL_WM_INT_ST This is the masked interrupt bit for
UHCILDMA_INFIFO_FULL_WM_INT INTERRUPT when UHCILDMA_INFIFO_FULL_WM_INT_ENA
is set to 1. (RO)

Espressif Systems 226 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

Register 8.58: UHCI_INT_ENA_REG (0x000C)

& wore’ SLES
NZ OS CD74 OO O94.)
é RXKS LOLOLO

[a1 v7] 6 fas | |e

 

5
S
5
loll |
roll ~|
loll |

fo 0 9 0 9 0000 0 00 0 0 ofofofofofo

 

UHCI_RX_START_INT_ENA Thisis the interrupt enable bit for UHCI_RX_START_INT interrupt. (RAV)

UHCI_TX_START_INT_ENA Thisis the interrupt enable bit for UHCI_TX_START_INT interrupt. (RAV)

UHCI_RX_HUNG_INT_ENA This is the interrupt enable bit for UHCI RX_HUNG_INT interrupt. (RAV)

UHCI TX_HUNG_INT_ENA This is the interrupt enable bit for UHCI_TX_HUNG_INT interrupt. (RAY)
UHCI_IN_DONE_INT_ENA This is the interrupt enable bit for UHCI_IN_DONE_INT interrupt. (RAV)

UHCIIN_SUC_EOF_INT_ENA This is the interrupt enable bit for UHCLIN_SUC_EOF_INT interrupt.

(RW)

UHCI_IN_ERR_EOF_INT_ENA This is the interrupt enable bit for UHCI_IN_ERR_EOF_INT interrupt.
(RW)

UHCI_OUT_DONE_INT_ENA This is the interrupt enable bit for UHCI_OUT_DONE_INT interrupt.
(RW)

UHCI_OUT_EOF_INT_ENA This is the interrupt enable bit for UHCIOUT_EOF_INT interrupt. (RAV)

UHCI_IN_DSCR_ERR_INT_ENA This is the interrupt enable bit for UHCI_IN_DSCR_ERR_INT inter-
rupt. (R/V)

UHCI_OUT_DSCR_ERR_INT_ENA This is the interrupt enable bit for UHCIOUT_DSCR_ERR_INT
interrupt. (R/W)

UHCI_IN_DSCR_EMPTY_INT_ENA This is the interrupt enable bit for UHCI_IN_DSCR_EMPTY_INT
interrupt. (R/W)

UHCI OUTLINK_EOF_ERR_INT_ENA This is the interrupt enable bit for
UHCI_OUTLINK_EOF_ERR_INT interrupt. (RAM)

UHCI_OUT_TOTAL_EOF_INT_ENA This is the interrupt enable bit for UHCI_OUT_TOTAL_EOF_INT
interrupt. (R/W)

UHCI_SEND_S REG_Q_INT_ENA This is the interrupt enable bit for UHCISEND_S_REG_Q_INT
interrupt. (R/W)

Continued on the next page...

Espressif Systems 227 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.58: UHCI_INT_ENA_REG (0x000C)

Continued from the previous page...

UHCI_SEND_A REG_Q_INT_ENA This is the interrupt enable bit for UHCISEND_A_REG_Q_INT
interrupt. (R/W)

UHCI_DMA_INFIFO_FULL_WM_INT_ENA This is the interrupt enable bit for
UHCI_DMA_INFIFO_FULL_WWM_INT interrupt. (RAV)

Espressif Systems 228 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.59: UHCI_INT_CLR_REG (0x0010)

 

[a

w]e [is | [as [2 | a

 

a Ee
[o 0000000000000 ofofofofofofo]ofofofofo]ofofofofo

 

UHCI_RX_START_INT_CLR_ Set this bit to clear UHCI_RX_START_INT interrupt. (WO)

UHCI_TX_START_INT_CLR_ Set this bit to clear UHCI_TX_START_INT interrupt. (WO)

UHCI_RX_HUNG_INT_CLR Set this bit to clear UHCILRX_HUNG_INT interrupt. (WO)

UHCI_TX_HUNG_INT_CLR_ Set this bit to clear UHCI_TX_HUNG_INT interrupt. (WO)

UHCI_IN_DONE_INT_CLR_ Set this bit to clear UHCI_IN_DONE_INT interrupt. (WO)

UHCI_IN_SUC_EOF_INT_CLR Set this bit to clear UHCI_IN_SUC_EOF_INT interrupt. (WO)

UHCI_IN_ERR_EOF_INT_CLR Set this bit to clear UHCI_IN_ERR_EOF_INT interrupt. (WO)

UHCI_OUT_DONE_INT_CLR Set this bit to clear UHCILOUT_DONE_INT interrupt. (WO)

UHCI_OUT_EOF_INT_CLR Set this bit to clear UHC|_OUT_EOF_INT interrupt. (WO)

UHCI_IN_DSCR_ERR_INT_CLR Set this bit to clear UHCI_IN_DSCR_ERF_INT interrupt. (WO)

UHCI_OUT_DSCR_ERR_INT_CLR Set this bit to clear UHCI_OUT_DSCR_ERF_INT interrupt. (WO)

UHCI_IN_DSCR_EMPTY_INT_CLR Set this bit to clear UHCI_IN_DSCR_EMPTY_INT interrupt. (WO)

UHCI_OUTLINK_EOF_ERR_INT_CLR Set this bit to clear UHCI_OUTLINK_EOF_ERF_INT interrupt.

(WO)

UHCI_OUT_TOTAL_EOF_INT_CLR Set this bit to clear UHCI_OUT_TOTAL_EOF_INT interrupt. (WO)

UHCI_SEND_S REG_Q_INT_CLR Set this bit to clear UHCI_LSEND_S_UHCI_Q_INT interrupt. (WO)

UHCI_SEND_A REG_Q_INT_CLR Set this bit to clear UHCI_LSEND_A_UHCI_Q_INT interrupt. (WO)

UHCI_DMA_INFIFO_FULL_WM_INT_CLR_ Set this bit to clear UHCILDMA_INFIFO_FULL_WM_INT

interrupt. (WO)

Espressif Systems

229 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.60: UHCI_DMA_OUT_STATUS_REG (0x0014)

 

 

 

 

 

 

 

 

 

 

 

 

 

<
So”
S Rete
& OO
& Oo. Ov
& sry
[a1 2| 1 | 0 |
jo9 0000000000000 000000 00090 00 0 0 Of1] 0 IReset
UHCI OUT_FULL 1: DMA data-output FIFO is full. (RO)
UHCI OUT_EMPTY 1: DMA data-output FIFO is empty. (RO)
Register 8.61: UHCI_DMA_IN_STATUS_REG (0x001C)
&
<
Ss So”
& a & RAY,
& OY & om. OY
we sy RG sy Ss
31 716 4/3 2 1 0
0000000000 00060000600 0 0 0 0 0 0 06 of oxo Jo 0111] 0 IReset

UHCIIN_FULL Data-input FIFO full signal. (RO)

UHCILIN_EMPTY Data-input FIFO empty signal. (RO)

UHCI_RX_ERR_CAUSE This register indicates the error type when DMA has received a packet with
error. 3’6001: Checksum error in HCl packet; 3’b010: Sequence number error in HC! packet;
3’b011: CRC bit error in HC! packet; 3’b100: OxcO is found but received HC! packet is not end;
3’b101: OxcO is not found when receiving HCI packet is end; 3’b110: CRC check error. (RO)

Espressif Systems 230 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
8. UART Controller

 

Register 8.62: UHCI_STATEO_REG (0x0030)

 

 

 

P SF
& & & oe
9 a S
xy’ 9 xe 7 g
Y 4 OF Lo
S © & &
& S Soy y
a \? \? \? \?
& ye ye sy
eS S S S

[ a1 [x 2s] 27 23 | 22 20 | 19 te | o|
| 0 | 0 | 0 | 0 | 0 | 0 |Reset

 

UHCIINLINK_DSCR_ADDR This register stores the current receive descriptor’s address. (RO)
UHCI_IN_DSCR_STATE reserved (RO)
UHCI IN_STATE reserved (RO)

UHCI INFIFO_CNT_DEBUG This register stores the byte number of the data in the receive descrip-
tor’s FIFO. (RO)

UHCI_DECODE_STATE UHCI decoder status. (RO)

Register 8.63: UHCILDMA_OUT_EOF_DES_ADDR_REG (0x0038)

 

 

 

go
Q
e
ev
Q
& 7
gy
Kg&7
Ss
se
[a 0]
| 0x000000 | Reset

 

UHCI_OUT_EOF_DES ADDR This register stores the address of the transmit descriptor when the
EOF bit in this descriptor is 1. (RO)

Register 8.64: UHCI_DMA_IN_SUC_EOF_DES_ADDR_REG (0x003C)

 

[ “|

| 0x000000 | Reset

 

 

UHCI_IN_ SUC _EOF_DES ADDR This register stores the address of the receive descriptor when
received successful EOF. (RO)

Espressif Systems 231 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.65: UHCI_DMA_IN_ERR_EOF_DES_ADDR_REG (0x0040)

 

 

 

ge
S
ee
g
Se
S S
x
yor
S
[a |
| 0x000000 | Reset

 

UHCI_IN_ERR_EOF_DES ADDR This register stores the address of the receive descriptor when
there are some errors in this descriptor. (RO)

Register 8.66: UHCI_DMA_OUT_EOF_BFR_DES_ADDR_REG (0x0044)

 

 

 

¥
S
er
ge
& 7
a
Ss
[a o]
| 0x000000 | Reset

 

UHCI_OUT_EOF_BFR_DES ADDR This register stores the address of the transmit descriptor before
the last transmit descriptor. (RO)

Register 8.67: UHCI_DMA_IN_DSCR_REG (0x004C)

 

E |

| 0 | Reset

 

 

UHCIINLINK_DSCR This register stores the third word of the next receive descriptor. (RO)

Espressif Systems 232 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.68: UHCI_DMA_IN_DSCR_BFO_REG (0x0050)

 

[ |

| 0 | Reset

 

 

UHCI_INLINK_DSCR_BFO This register stores the third word of the current receive descriptor. (RO)

Register 8.69: UHCI_DMA_IN_DSCR_BF1_REG (0x0054)

 

31 °

 

0 Reset

 

 

 

UHCIINLINK_DSCR_BF1 This register stores the second word of the current receive descriptor.
(RO)

Register 8.70: UHCI_DMA_OUT_DSCR_REG (0x0058)

 

[ 7]

| 0 | Reset

 

 

UHCI_OUTLINK_DSCR This register stores the third word of the next transmit descriptor. (RO)

Espressif Systems 233 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.71: UHCI DMA_OUT_DSCR_BFO_REG (0x005C)

 

[ 7]

| 0 | Reset

 

 

UHCI_OUTLINK_DSCR_BFO This register stores the third word of the current transmit descriptor.
(RO)

Register 8.72: UHC|_DMA_OUT_DSCR_BF1_REG (0x0060)

 

[ 7]

| 0 | Reset

 

 

UHCI_OUTLINK_DSCR_BF1 This register stores the second word of the current transmit descriptor.
(RO)

Register 8.73: UHCI_RX_HEAD_REG (0x0070)

 

E |

| 0x000000 | Reset

 

 

UHCI_RX_HEAD This register stores the header of the current received packet. (RO)

Espressif Systems 234 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.74: UHCI_DMA_OUT_PUSH_REG (0x0018)

 

 

 

Ca
oo x
& &
& oS & \>
& se € s
[1 7] 16 [is ole o|
[o 0000000000000 of o[o 0 0 00 0 o| OxO |Reset

 

UHCI_OUTFIFO_WDATA This is the data that need to be pushed into data-outout FIFO. (RAV)

UHCI_OUTFIFO_PUSH Set this bit to push data into the data-outout FIFO. (RAV)

Register 8.75: UHCI_DMA_IN_POP_REG (0x0020)

 

 

 

 

 

 

 

ae
& x
C’ C’
& Ss & ss
L Ov @ Ov
AG s We ye

[1 7] 16 [is [0 o|
[o 000000000000 0 of o[o 0 0 o| x0 |Reset

UHCIINFIFO_RDATA This register stores the data popping from data-input FIFO. (RO)

UHCI INFIFO_POP. Set this bit to pop data from data-inout FIFO. (RAM)

Register 8.76: UHCLDMA_OUT_LINK_REG (0x0024)
Kj
x
AES
SEES s*
PEEP LE wv
SOOO os

osoeeeSS a SS
SHS & sx
[ st | 0 | 2 | 25 [> 219 o|
[ofo[o]efo 000 00 0 o| 0x000 |Reset

 

UHCI OUTLINK_ADDR This register is used to specify the least significant 20 bits of the first transmit
descriptor’s address. (R/WV)

UHCI OUTLINK_ STOP. Set this bit to stop dealing with the transmit descriptor. (R/W)
UHCI_OUTLINK_ START Set this bit to start a new transmit descriptor. (R/V)

UHCI OUTLINK_RESTART Set this bit to restart the transmit descriptor from the last address. (R/W)

UHCI_OUTLINK_PARK 1: the transmit descriptor’s FSM is in idle state. 0: the transmit descriptor’s
FSM is working. (RO)

Espressif Systems 235 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.77: UHCI_DMA_IN_LINK_REG (0x0028)

 

[ 21 | 30 | 29 | 2 [2 a1] 20 [19 o|

 

 

[o]o]o]ofo 0 0 0 0 0 ofa] ox000 |Reset

 

UHCILINLINK_ADDR This register is used to specify the least significant 20 bits of the first receive
descriptor’s address. (R/WV)

UHCIINLINK_AUTO_RET This is the enable bit to return to current receive descriptor’s address,
when there are some errors in current packet. (R/W)

UHCILINLINK_STOP Set this bit to stop dealing with the receive descriptors. (R/WV)
UHCI INLINK_START Set this bit to start dealing with the receive descriptors. (RAN)
UHCIINLINK_RESTART Set this bit to restart new receive descriptors. (RAV)

UHCIINLINK_PARK_ 1: the receive descriptor’s FSM is in idle state. 0: the receive descriptors FSM
is working. (RO)

Register 8.78: UHCI_STATE1_REG (0x0034)

 

 

 

& Ss
& & & co
Ss eS & ey ¥
Xv Or xX we
a & & a XY
e VY 9 9 9 9
& & se sv ost se

| 31 E 227 23] 2 219 [17 o|
| 0 | 0 | 0 | 0 | 0 | 0 |Reset

 

UHCI_OUTLINK_DSCR_ADDR This register stores the current transmit descriptor’s address. (RO)
UHCI_OUT_DSCR_STATE reserved (RO)
UHCI_OUT_STATE reserved (RO)

UHCI_OUTFIFO_CNT This register stores the byte number of the data in the transmit cescriptor’s
FIFO. (RO)

UHCI_ENCODE STATE UHCI encoder status. (RO)

Espressif Systems 236 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
8. UART Controller

 

Register 8.79: UHCI_DATE_REG (0x00FC)

4
x
Ov
sy

 

31

 

 

0x18073001

Reset

 

 

UHCI_DATE This is the version control register. (RAV)

Espressif Systems

237
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
9. LED PWM Controller

 

9. LED PWM Controller

9.1 Overview
The LED PWM controller is primarily designed to control LED clevices, as well as generate PWM signals. It has
14-bit timers and waveform generators.

9.2 Features
The LED PWM controller has the following features:

* Four independent timers that support division by fractions
* Eight independent waveform generators able to produce eight PWM signals

* Fading duty cycle of PWM signals without interference from any processors. An interrupt can be generated
after the fade has completed

e Adjustable phase of PWM signal output
¢ PWM signal output in low-power mode

For the convenience of description, in the following sections the eight waveform generators are collectively
referred to as PWM)n, and the four timers are collectively referred to as Timerx.

9.3 Functional Description

9.3.1 Architecture
Figure 9-1 shows the architecture of the LED PWM controller. Figure 9-2 illustrates a PWM generator with its
selected timer and a counter.

 

LED_PWM

 

 

|__| Pwmo
pe! pwom1

 

 

TimerO —__>

 

 

 

 

tI PWM2

 

 

Timer1 >

 

r+ PWM3

 

 

Mux _—
rt PWM4

 

 

Timer2 |__|

 

 

r= PWM5

 

 

 

t+——— >, PWM6

 

Timers -~——_

 

 

 

 

 

 

 

 

 

> PWM7

 

 

 

 

Figure 9-1. LED_PWM Architecture

Espressif Systems 238 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

Timer

 
  
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

LEDG_IDLE_LV_CH
: / PWM '
| LEDG_APB_CLK_SEL[1:0] | “o” ; :
LEDC_CLK_DIV_TIMER ' | sig_outn
C_TIMEP_PAUSE “TEDG_BUTY.CH
' LEDC_ st ' : “qr
acu LEDC_PWM_CLK LEDG_HPOINT_CH Lt
| BMCLK a
| XTAL_CLK, Divider Counter | Timerx_cnt High/Low_level
' LEDC CLE. (18 bits) (14 bits) |! i comparator
il 1 | ' LEDG_SIG_OUT_EN_CH!
REF_CLK ref_pulse:
| | LED@_DUTY_START_CH
LEDC_TICK_SEL_TIMER LEDC_TIMERX. RST | | LEDC_DUTY_ING_CH
LEDC_TIMERx_DUTY_RES | | LEDC_DUTY_NUM_CH

Dee, LEDOLTIMER®_DUTY_RES | | LEDC_DUTY_CYCLE_CH
| LEDC _DUTY_SCALE CH

Figure 9-2. LED_PWM generator Diagram

ey = OT

Aclock pulses ++. Aclock pulses Atl clock pulses Aclockpulses ... Actock pubes Atl clock pulses Aclock pulses AHL clock pulses
B ( Atl ) counts

we, 1 JE ||

256 output clocks

 

 

 

 

 

 

Figure 9-3. LED_PWM Divider

9.3.2 Timers

The clock of the LED PWM controller, LEDC_PWM_CLK, has three clock sources: APB_CLK, RTC8M_CLK and
XTAL_CLK, selected by configuring LEDC_APB_CLK_SEL{1:0]. The clock of each LED PWM timer, LEDC_CLk«,
has two clock sources: LEDC_PWM_CLK or REF_TICK. When REF_TICK is used as the clock source of a timer,
LEDC_APB_CLK_SEL[1:0] should be set 1 and the cycle of REF_TICK should be an integral multiple of

APB_CLK cycles. Otherwise this clock will be not accurate. For more information on the clock sources, please
see Chapter Reset and Clock.

The output clock derived from LEDC_CLKkx is used as the base clock for the counter. The divider’s divisor is
configured by LEDC_CLK_DIV_TIMER«. It is a fixed-point number: the highest 10 bits is the integer part

represented as A, while the lowest eight bits is the fractional part represented as B. This divisor LEDC_CLK_DIVx
is calculated as:

LEDC_CLK_DIVx=A+3%%

When the fractional part B is not 0, the inout and output clock of the divider is shown as in figure 9-3. Among the
256 output clocks, B of them are divided by (A+1), whereas the remaining (256-B) are divided by A. Output
clocks divided by (A+1) are evenly distributed in the total 256 output clocks.

The LED PWM controller has a 14-bit counter that counts up to 242 PC_-TIMER_DUTY_RES _ 1. lf the counting
value reaches 242DC_TIMER _DUTY_RES _ 1. the counter will overflow and restart counting from 0. The
counting value can be reset, suspended or read by software. A LEDC_TIMERx_OVF_INT interrupt can be
generated every time when the counter overflows or when it overflows for (LEDC_OVF_NUM_CH)h + 1) times.
The interrupt configuration is as follows:

1. Set LEDC_OVF_CNT_EN_CHn

2. Configure LEDC_OVF_NUM_CHh with the times of overflow minus 1

Espressif Systems 239 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

 

8. Set LEDC_OVF_CNT_CHn_INT_ENA
4. Set LEDC_TIMERx_DUTY_RES to enable the timer and wait for a LEDC_OVF_CNT_CHn_INT interrupt

The frequency of a PWM generator output signal, sig_outn, depends on both the divisor of the divider, as well as
the range of the counter:

_ fine clk
fi sig_out ~~ LEDC_CLK_DIVx . 2LEDC_TIMER:_DUTY_RES

 

To change the divisor and times of overflow, you should configure LEDC_CLK_DIV_TIMERx and
LEDC_TIMERx_DUTY_RES respectively, and then set LEDC_TIMERx_PARA_UP; otherwise this change is not
valid. The newly configured value is updated upon next overflow of the counter.

9.3.3 PWM Generators

As shown in figure 9-2, each PWM generator has a high/low level comparator and two selectors. A PWM
generator takes the 14-bit counting value of the selected timer, compares it to values of the comparator Hpoint?
and Lpointn, and therefore control the level of PWM signals.

® If Timerx_cnt == Hpointn, sig_outn is 1.
® If Timerx_cnt == Lpointn, sig_outn is 0.

Hpointn is updated by LEDC_HPOINT_CH” when the counter overflows. The initial value of Lpoint? is the sum of
LEDC_DUTY_CH[18..4] and LEDC_HPOINT_CHn when the counter overflows. By configuring these two fields,
the relative phase and the duty cycle of the PWM output can be set.

Figure 9-4 illustrates PWM’s waveform when the duty cycle is fixed.

 

timer_ent[13:0]
overflow
Tot ee ee

point
o ial

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

‘sig_out

 

 

Figure 9-4, LED PWM Output Signal Diagram

LEDC_DUTY_CH) is a fixed-point register with four fractional bits. LEDC_DUTY_CHn[18..4] is the integral part
used directly for PWM calculation. LEDC_DUTY_CH)n[S8..0] is the fractional part used to dither the output. If
LEDC_DUTY_CH)[8..0] is non-zero, then among every 16 cycles of sig_outn, LEDC_DUTY_CH)[8..0] have PWM
pulses with width one timer cycle longer than that of (16-LEDC_DUTY_CH)nJ8..0)]). This feature effectively
increases the resolution of the PWM generator to 18 bits.

9.3.4 Duty Cycle Fading

The PWM generators is able to fade the duty cycle, that is to gradually change the duty cycle from one value to
another. This is achieved by configuring LEDC_DUTY_CHn, LEDC_DUTY_START_CHn, LEDC_DUTY_INC_CHh,
LEDC_DUTY_NUM_CHn and LEDC_DUTY_ SCALE _CHhn.

LEDC_DUTY_START_CH) is used to update the value of Lpointn. When this bit is set and the counter overflows,
Lpointn increments or decrements automatically, depending on whether the bit LEDC_DUTY_INC_CH) is set or
cleared.

Espressif Systems 240 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

 

The duty cycle of sig_outn changes every LEDC_DUTY_CYCLE_CHn PWM pulse cycles by adding or
subtracting the value of LEDC_DUTY_SCALE_CH)n.

Figure 9-5 is a diagram of fading duty cycle. Upon reaching LEDC_DUTY_NUM_CH), the fade stops and

a

LEDC_DUTY_CHNG_END_CH)_INT interrupt is generated. When configured like this, the duty cycle of sig_outn
increases by LEDC_DUTY_SCALE_CHn every LEDC_DUTY_CYCLE_CHn PWM pulse cycles.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

timer_ertt{13:0]
RN | cece _
ort ee ft tee |e
hpoint = { ; ! { !
or : it i i i i ral
: [b-al-LEDC_DUTY_SCALE_CH! |e-b]-LEDC_DUTY_SCALE_CH: ' '
none ld b b c c |
~<a <a >
cycle_cnt: 1 2 .. LEDC_DUTY_CYCLE_CHi 1 2 ... LEDG_DUTY_CYCLE_CH: 1 2 os
num_ent:1 2 3... LEDC_DUTY_NUM_CH

 

 

 

Figure 9-5. Output Signal Diagram of Fading Duty Cycle

LEDC_SIG_OUT_EN_CH)h used to enable PWM waveform output. When LEDC_SIG_OUT_EN_CH) is 0, the
level of sig_outn is constant as specified in LEDC_IDLE_LV_CHn.

lf LEDC_HPOINT_CHn, LEDC_DUTY_START_CHn, LEDC_SIG_OUT_EN_CHn, LEDC_TIMER_SEL_CHn,
LEDC_DUTY_NUM_CHn, LEDC_DUTY_CYCLE_CHn, LEDC_DUTY_SCALE_CHn, LEDC_DUTY_INC_CHn
and

LEDC_OVF_CNT_EN_CH)h are reconfigured, LEDC_PARA_UP_CH)n should be set to apply the new
configuration.

9.3.5 Interrupts
e LEDC_OVF_CNT_CH?»_INT: Triggered when the timer counter overflows for (LEDC_OVF_NUM_CH)n + 1)
times and register LEDC_OVF_CNT_EN_CHh is set to 1.

e LEDC_DUTY_CHNG_END_CH?»_INT: Triggered when a fade on a LED PWM generator has finished.

e LEDC_TIMERx_OVF_INT: Triggered when a LED PWM timer has reached its maximum counter value.

9.4 Base Address

Users can access the LED PWM controller with two base addresses, which can be seen in the following table.
For more information about accessing peripherals from different buses please see Chapter 1 System and
Memory.

Table 40: LED_PWM Base Address

 

 

 

 

 

 

 

Bus to Access Peripheral Base Address
PeriBUS1 Ox8F419000
PeriBUS2 0x60019000
Espressif Systems 241 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
9. LED PWM Controller

 

9.5 Register Summary

The addresses in the following table are relative to the LED PWM controller base addresses provided in Section

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

9.4.
Name | Description Address | Access
Configuration Register
LEDC_CHO_CONFO_REG Configuration register O for channel O Ox0000_ ‘| varies
LEDC_CHO_CONF1_REG Configuration register 1 for channel 0 Ox000C | RAV
LEDC_CH1_CONFO_REG Configuration register O for channel 1 0x0014 | varies
LEDC_CH1_CONF1_REG Configuration register 1 for channel 1 0x0020 | RAV
LEDC_CH2_CONFO_REG Configuration register O for channel 2 0x0028 =| varies
LEDC_CH2_CONF1_REG Configuration register 1 for channel 2 0x0034 | RAV
LEDC_CH3_CONFO_REG Configuration register O for channel 3 Ox003C_ | varies
LEDC_CH3_CONF1_REG Configuration register 1 for channel 3 0x0048 | RAV
LEDC_CH4_CONFO_REG Configuration register O for channel 4 0x0050_ ‘| varies
LEDC_CH4_CONF1_REG Configuration register 1 for channel 4 Ox005C_ | RAV
LEDC_CH5_CONFO_REG Configuration register O for channel 5 0x0064 | varies
LEDC_CH5_CONF1_REG Configuration register 1 for channel 5 0x0070 | RAV
LEDC_CH6_CONFO_REG Configuration register O for channel 6 0x0078 | varies
LEDC_CH6_CONF1_REG Configuration register 1 for channel 6 0x0084 | RAV
LEDC_CH7_CONFO_REG Configuration register O for channel 7 Ox008C_ | varies
LEDC_CH7_CONF1_REG Configuration register 1 for channel 7 Ox0098 | RAV
LEDC_CONF_REG Global ledc configuration register OxOO0DO | RAV
Hpoint Register
LEDC_CHO_HPOINT_REG High point register for channel 0 O0x0004 | RAV
LEDC_CH1_HPOINT_REG High point register for channel 1 0x0018 | RAV
LEDC_CH2_HPOINT_REG High point register for channel 2 Ox002C | RAV
LEDC_CH3_HPOINT_REG High point register for channel 3 0x0040 | RAV
LEDC_CH4_HPOINT_REG High point register for channel 4 0x0054 | RAV
LEDC_CH5_HPOINT_REG High point register for channel 5 Ox0068 | RAV
LEDC_CH6_HPOINT_REG High point register for channel 6 Ox007C | RAV
LEDC_CH7_HPOINT_REG High point register for channel 7 Ox0090 | RAV
Duty Cycle Register
LEDC_CHO_DUTY_REG Initial duty cycle for channel O Ox0008 | RAV
LEDC_CHO_DUTY_R_REG Current duty cycle for channel 0 0x0010 | RO
LEDC_CH1_DUTY_REG Initial duty cycle for channel 1 Ox001C | RAV
LEDC_CH1_DUTY_R_REG Current duty cycle for channel 1 0x0024 | RO
LEDC_CH2_DUTY_REG Initial duty cycle for channel 2 Ox0030 | RAV
LEDC_CH2_DUTY_R_REG Current duty cycle for channel 2 0x0038 | RO
LEDC_CH3_DUTY_REG Initial duty cycle for channel 3 0x0044 | RAV
LEDC_CH3_DUTY_R_REG Current duty cycle for channel 3 0x004C | RO
LEDC_CH4_DUTY_REG Initial duty cycle for channel 4 O0x0058 | RAV
LEDC_CH4_DUTY_R_REG Current duty cycle for channel 4 Ox0060 | RO
LEDC_CH5_DUTY_REG Initial duty cycle for channel 5 Ox006C_ | RAV
LEDC_CH5_DUTY_R_REG Current duty cycle for channel 5 0x0074 | RO

Espressif Systems 242 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
9. LED PWM Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
LEDC_CH6_DUTY_REG Initial duty cycle for channel 6 Ox0080 | RAV
LEDC_CH6_DUTY_R_REG Current duty cycle for channel 6 0x0088 | RO
LEDC_CH7_DUTY_REG Initial duty cycle for channel 7 0x0094 | RAV
LEDC_CH7_DUTY_R_REG Current duty cycle for channel 7 Ox009C | RO
Timer Register

LEDC_TIMERO_CONF_REG Timer 0 configuration OxO0A0 | varies
LEDC_TIMERO_VALUE_REG Timer 0 current counter value Ox00A4 | RO
LEDC_TIMER1_CONF_REG Timer 1 configuration OxO0A8 | varies
LEDC_TIMER1_VALUE_REG Timer 1 current counter value OxO0AC | RO
LEDC_TIMER2_CONF_REG Timer 2 configuration Ox00BO | varies
LEDC_TIMER2_VALUE_REG Timer 2 current counter value Ox00B4 | RO
LEDC_TIMERS_CONF_REG Timer 3 configuration Ox00B8 | varies
LEDC_TIMERS_VALUE_REG Timer 3 current counter value OxOO0BC | RO
Interrupt Register

LEDC_INT_RAW_REG Raw interrupt status Ox00CO | RO
LEDC_INT_ST_REG Masked interrupt status Ox00C4 | RO
LEDC_INT_ENA_REG Interrupt enable bits Ox00C8 | RAV
LEDC_INT_CLR_REG Interrupt clear bits Ox00CC | WO
Version Register

LEDC_DATE_REG Version control register OxOOFC | RAV

 

Espressif Systems

243

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
9. LED PWM Controller

 

9.6 Registers

Register 9.1: LEDC_CH»_CONFO_REG (: 0-7) (0x0000+20*7)

 

 

 

ss
o oS &
PCS oe ws ~~? 9
See’ sy Ra
> SEO & SMS
ss O%07%0)7 Ov O%Z07%07 0”
é SEE g SSS §
[a1 we] ar | 6 [os | slefeleh: o|
fo 0 9 0 0 0 000 0 0 0 0 ofofofo] xO [o]o[o] 00 reset

 

LEDC_TIMER_SEL_CH)» This field is used to select one of timers for channel. O: select timerO 1:
select timer1 2: select timer2 3: select timer3 (RAV)

LEDC_SIG_OUT_EN_ CH» Set this bit to enable signal outout on channel 7. (RAV)
LEDC_IDLE _LV_CH» This bit is used to control the output value when channel 7 is inactive. (R/W)

LEDC_PARA_UP_CH” This bit is used to update register LEDC_CH>o_HPOINT = and
LEDC_CHn_DUTY for channel. (WO)

LEDC_OVF_NUM_CH)» This register is used to configure the maximum times of overflow minus
1. The LEDC_OVF_CNT_CHr_INT interrupt will be triggered when channel 7 overflows for
(LEDC_OVF_NUM_CH)h + 1) times. (RAV)

LEDC_OVF_CNT_EN_ CH This bit is used to enable the ovf_cnt of channel n. (RAM)
LEDC_OVF_CNT_RESET_CH Set this bit to reset the ovf_cnt of channel 7. (WO)

LEDC_OVF_CNT_RESET_ST_CHn This is the status bit of LEDC_OVF_CNT_RESET_CH). (RO)

Espressif Systems 244 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

Register 9.2: LEDC_CHn_CONF1_REG (7: 0-7) (0x000C+20*7)

 

 

 

x x x
&? x xs wv VY
a oe oe gf
AMG 7 7 7 7
oo as a a
OS gS ¥ Ss
[ st | 20 [2 219 1o[» o|
fo]s| Ox0 | OxO | Oxo |Reset

 

LEDC_DUTY_ SCALE CH» Thisregister is used to configure the changing step scale of duty on chan-
nel.n. (RAN)

LEDC_DUTY_ CYCLE CH” The duty will change every LEDC_DUTY_CYCLE_CH)h on channel
(RAV)

LEDC_DUTY_NUM_CH)? This register is used to control the number of times the duty cycle will be
changed. (RAW)

LEDC_DUTY_INC_CH» This register is used to increase or decrease the duty of output signal on
channel. 1: Increase; 0: Decrease. (RAV)

LEDC_DUTY_START_CH? Other configured fields in LEDC_CHn_CONF1_REG will start to take ef-
fect when this bit is set to 1. (RAV)

Register 9.3: LEDC_CONF_REG (0x00D0)

gy

$

Ss a
on S rs

7 gf Ro

S y

| 31 | 20 afi o|

[ofo 0 0 0 9090090000000 09 000000 090 00 0 0 Of O06 Reset

LEDC_APB_CLK_SEL This bit is used to select clock source for the 4 timers. 2’d1: APB_CLK 2’d2:
RTC8M_CLK 2’03: XTAL_CLK (RAW)

LEDC_CLK_EN This bit is used to control clock. 1’61: Force clock on for register. 17hO: Support
clock only when application writes registers. (R/W)

Espressif Systems 245 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

 

Register 9.4: LEDC_CH»_HPOINT_REG (»: 0-7) (0x0004420*7)

 

 

 

x
Kg&/
Ss
S x
ss o>
Q@
& S
[1 w]e o|
fo 0 9 0 9 000009 00000 0 9] ox00 |Reset

 

LEDC_HPOINT_CH” The output value changes to high when the selected timers has reached the
value specified by this register. (R/W)

Register 9.5: LEDC_CHn_DUTY_REG (7: 0-7) (0x0008+20*»)

 

 

 

x
ae
SS >
& sv
& v
[1 |e o|
[o 00000000000 | 0x000 |Reset

 

LEDC_DUTY_CH» This register is used to change the output duty by controlling the Lpoint. The
output value turns to low when the selected timers has reached the Lpoint. (RAV)

Register 9.6: LEDC_CHn_DUTY_R_REG (: 0-7) (0x00104+20*7)

 

 

 

xs
Qv
S Ss
& Ss
[1 [18 o|
[o 00000000000 o| 0x000 |Reset

 

LEDC_DUTY_R_CH” This register stores the current duty of output signal on channel 7. (RO)

Espressif Systems 246 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

 

Register 9.7: LEDC_TIMERx_CONF_REG (x: 0-3) (0x00A0+8*»)

 

 

 

S
ot SS & oe
Kon SK Sw’ >
& SELES ae Se
E PEPEE E43
[0 0 0 0 0 ofofolifo] 0x000 | xO |Reset

 

LEDC_TIMERx_DUTY_RES This register is used to control the range of the counter in timer x. (RAM)

LEDC_CLK_DIV_TIMER« This register is used to configure the divisor for the divider in timer x. The
least significant eight bits represent the fractional part. (RAV)

LEDC_TIMERx_PAUSE This bit is used to suspend the counter in timer «. (R/V)
LEDC_TIMERx_RST This bit is used to reset timer x. The counter will show 0 after reset. (R/W)

LEDC_TICK_SEL_TIMER« This bit is used to select clock for timer x. When this bit is set to 1
LEDC_APB_CLK_SEL[1:0] should be 1, otherwise the timer clock may be not accurate. 1’hO:
SLOW_CLK 1’h1: REF_TICK (RAW)

LEDC_TIMERx_PARA_UP Set this bit to update LEDC _CLK_DIV_TIMER and
LEDC_TIMERx_DUTY_RES. (WO)

Register 9.8: LEDC_TIMERx_VALUE_REG (x: 0-3) (0x00A4+8*x)

 

 

 

 

&
eS
Seas Lf
& ws
s ov
& S
| 31 14 | 13 o |
[oo 0 0000990000000 090 0 9 x00 |Reset
LEDC_TIMERx_CNT This register stores the current counter value of timer x. (RO)
Espressif Systems 247 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
9. LED PWM Controller

 

Register 9.9: LEDC_INT_RAW_REG (0x00C0)

 

FMM HMM KR RA AAS
SEES ES ESI OO LODO IIIS
AP OZ 07 %7,B7, V7 0707 F_ OD SOP VTS
LORE NR POLO LOLOL OE LILI
SSS EEE PEEK Keyra’
RIS FSS FEIN EEE
KK AK AK AK AK ZK KZ
é £6 Spo oe oon oe Oe Oe Oe Se TENG
QO
& PLE IELEEEEEESCEEEEEEESEES
[a1 a] fas far] fs] | sf [uo] 2 8 7 6 5 4 3 2 1

 

 

le{-[e[s][e le]
[0 000000000 0 ofofofo]o]fofofofofofo]o]ofofojofofofo]o

 

LEDC_TIMERx_OVF_INT_RAW Triggered when the timerx has reached its maximum counter value.
(RO)

LEDC_DUTY_CHNG_END_CH»_INT_RAW Interrupt raw bit for channel n. Triggered when the grad-
ual change of duty has finished. (RO)

LEDC_OVF_CNT_CH”_INT_RAW Interrupt raw bit for channel 9. Triggered when the ovf_cnt has
reached the value specified by LEDC_OVF_NUM_CH)n. (RO)

Register 9.10: LEDC_INT_ST_REG (0x00C4)

9593930797979
SOND On Sooo See SIS

 

 

 

LEDC_TIMERx_OVF_INT_ST This is the masked interrupt status bit for the LEDC_TIMERx_OVF_INT
interrupt when LEDC_TIMERx_OVF_INT_ENA is set to 1. (RO)

LEDC_DUTY_CHNG_END_CHr_INT_ST This is the masked interrupt status bit for the
LEDC_DUTY_CHNG_END_CH)_INT interrupt when LEDC_DUTY_CHNG_END_CHn_INT_ENAis
set to 1. (RO)

LEDC_OVF_CNT_CH”_INT_ST This’ is the masked interrupt status bit for the
LEDC_OVF_CNT_CH_INT interrupt when LEDC_OVF_CNT_CHn_INT_ENA is set to 1. (RO)

Espressif Systems 248 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

 

Register 9.11: LEDC_INT_ENA REG (0x00C8)

wr ww wr ww, wT ww, wT w
PS SS ) o> > ”» > » ~> o>
LEIPZIG ST

©
ASRS ARIARS ARIAS AI RI WS SS
SPOS S OSS NON Ne Novo Ne Ne)

 

O1O O° O°?
O49 %.0%.0 4.0 %.0 4.040 4.0%.0 704.094.0040 4.0%040407
E SEP OPEC PEPE ESOEEEESE SSF
[1 20] 19 18 17 16 | 1s 14 w[elulo]s 8 7 6 5 4 3 2 fo]

 

 

 

LEDC_TIMERx_OVF_INT_ENA The interrupt enable bit for the LEDC_TIMERx_OVF_INT interrupt.
(RAV)

LEDC_DUTY_CHNG_END_CHr_INT_ENA The interrupt enable bit for the
LEDC_DUTY_CHNG_END_CH)_INT interrupt. (RAW)

LEDC_OVF_CNT_CH”_INT_ENA The interrupt enable bit for the LEDC_OVF_CNT_CHn_INT inter-
rupt. (R/V)

Register 9.12: LEDC_INT_CLR_REG (0x00CC)

 

 

 

LEDC_TIMER«_OVF_INT_CLR_ Set this bit to clear the LEDC_TIMER«_OVF_INT interrupt. (WO)

LEDC_DUTY_CHNG_END_CH7_INT_CLR Set this bit to Clear the
LEDC_DUTY_CHNG_END_CH)_INT interrupt. (WO)

LEDC_OVF_CNT_CHn_INT_CLR Set this bit to clear the LEDC_OVF_CNT_CH_INT interrupt. (WO)

Espressif Systems 249 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
9. LED PWM Controller

 

Register 9.13: LEDC_DATE_REG (0x00FC)

x
x

C7
S
y

 

31

 

 

0x19072601

Reset

 

 

LEDC_DATE This is the version control register. (R/W)

Espressif Systems

250
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
10. Remote Control Peripheral

 

10. Remote Control Peripheral

10.1 Introduction

The RMT (Remote Control) module is designed to send/receive infrared remote control signals that support for a
variety of remote control protocols. The RMT module converts pulse codes stored in the module’s built-in RAM
into output signals, or converts input signals into pulse codes and stores them back in RAM. In addition, the RMT
module optionally modulates its output signals with a carrier wave, or optionally filters its input signals.

The RMT module has four channels, numbered from zero to three. Each channel has the same functionality
controlled by dedicated set of registers and is able to independently transmit or receive data. Registers in each
channel are indicated by 7 which is used as a placeholder for the channel number.

10.2 Functional Description
10.2.1. RMT Architecture

-———+ CHO |

 

 

 

 

 

 

CH1 |
RMT uM orn CH
RMT_ ue
Clock RMT_CARRIER_HIGH_CH: Transmitter

FIMT_REF_CNT_AST_CH RMT_CARRIE? IMT_CARRIER_EN_CH:
RMT_DIV.

R_LOW CH
 GNT_Chi RMT_CARRIER_OUT LV CH’

    
 
  
  

REF_TICK,
I =“)
@ bits)
APB_CLK 1

RMT_REF_ALWAYS_ON_CH’

— ey,

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

RAM
blocko *
memd mon ‘Counter -—!
block! FSM cn
mem_wr a
block men Recsiver |
FIMT_CARRIER_EN_CHi RMT_RX FILTER_THRES_CHn |
blocks mam_wedsta AIMT_FX FILTER_EN_CH

 

 

 

 

 

 

sig

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

I g FIMT_CARRIER_HIGH_THRES_CH
RIMT_CARRIER_LOW_THRES_CH:
MT_MEM_PD FIMT_CARRIER_OUT_LV_CH’
IMT_MEM_SIZE_CH
FIMT_MEM_RD_FST_CH!
AMT_MEM_WR_RST_CH:
FIMT_MEM_OWNER_CH:

Figure 10-1. RMT Architecture

The RMT module contains four independent channels. Each channel has a clock divider, a counter, a transmitter
and a receiver. As for the transmitter and the receiver of a single channel, only one of them can be active. The
four channels share a 256 x 32-bit RAM.

Espressif Systems 251 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

10.2.2 RMT RAM

 

 

 

 

 

 

 

 

[31] [30:16] [15] [14:0]

level period level period
addrO

[31] [30:16] . [15] [14:0]

level period level period
addrn

 

 

 

 

 

 

Figure 10-2. Format of Pulse Code in RAM

The format of pulse code in RAM is shown in Figure 10-2. Each pulse code contains a 16-bit entry with two
fields, level and period. Level (0 or 1) indicates a high-/ow-level value was received or is going to be sent, while
*period” points out the clock cycles (see Figure 10-1 clk_div) for which the level lasts. A zero period is interpreted
as a transmission end-marker.

The RAM is divided into four 64 x 32-bit blocks. By default, each channel uses one block (block zero for channel
zero, block one for channel one, and so on). Usually, only one block of 64 x 32-bit worth of data can be sent or
received in channel /. If the data size is larger than this block size, users can configure the channel to enable
wrap mode or to use more blocks by setting RMT_MEM_SIZE_CHn. Setting RMT_MEM_SIZE_CH)h > 1 will
prompt channel 7 to use the memory of subsequent channels, block (7) ~ block (9 + RMT_MEM_SIZE_CH)h -1). If
so, the subsequent channels 7 +1 ~ 7 + RMT_MEM_SIZE_CHh - 1 cannot be used once their RAM blocks are
occupied. Note that the RAM used by each channel is mapped from low address to high address. In such mode,
channel 0 is able to use the RAM blocks for channels 1, 2 and 3 by setting RMT_MEM_SIZE_CH)n, but channel 3
cannot use the blocks for channels 0, 1, or 2.

The RMT RAM can be accessed via APB bus, or read by the transmitter and written by the receiver. To protect a
receiver from overwriting the blocks a transmitter is about to transmit, RMT_MEM_OWNER_CH)n can be
configured to designate the block’s owner, be it a transmitter or receiver. This way, if this ownership is violated, an
RMT_MEM_OWNER_ERR_CH?n flag will be generated.

When the RMT module is inactive, the RAM can be put into low-power mode by setting
RMT_MEM_FORCE_PD.

10.2.3 Clock

The drive clock of a divider is generated by taking either the APB_CLK or REF_TICK according to the state of
RMT_REF_ALWAYS_ON_CH)h. (For more information on clock sources, please see Chapter Reset and Clock).
Divider value is normally equal to the value of RMT_DIV_CNT_CH)h, except value 0 that represents divider 256.
The clock divider can be reset to zero by clearing RMT_REF_CNT_RST_CH)». The clock generated from the
divider can be used by the clock counter (see Figure 10-2).

10.2.4 Transmitter

When RMT_TX_START_CH)h is set to 1, the transmitter of channel /” will start reading and sending pulse codes
from the starting address of its RAM block. The codes are sent starting from low-address entry. The transmitter
will stop the transmission, return to idle state and generate an RMT_CHn_TX_END_INT interrupt, when an
end-marker (a zero period) is encountered. Also, setting RMT_TX_STOP_CH)n to 1 stops the transmission and
immediately sets the transmitter back to idle. The output level of a transmitter in idle state is determined by the
“level” field of the end-marker or by the content of RMT_IDLE_OUT_LV_CHn, depending on the configuration of

Espressif Systems 252 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

RMT_IDLE_OUT_EN_CH)n.

To transmit more pulse codes than can be fitted in the channel’s RAM, users can enable wrap mode by
configuring RMT_MEM_TX_WRAP_EN. In this mode, when the transmitter has reached the end-marker in the
channel’s memory, it will loop back to the first byte. For example, if RMT_MEM_SIZE_CH) is set to 1, the
transmitter will start sending data from the address 64 * n, and then the data from higher RAM address. Once the
transmitter finishes sending the data from (64 * (7 +1) - 1), it will continue sending data from 64 * 7 till encounters
an end-marker. Wrap mode is also applicable for RMT_MEM_SIZE_CHn > 1.

An RMT_CHn_TX_THR_EVENT_INT interrupt will be generated whenever the size of transmitted pulse codes is
larger than or equal to the value set by RMT_TX_LIM_CHn. In wrap mode, RMT_TX_LIM_CHn can be set toa
half or a fraction of the size of the channel’s RAM block. When an RMT_CHn_TX_THR_EVENT_INT interrupt is
detected, the already used RAM region should be updated by subsequent user defined events. Therefore, when
the wrap mode happens the transmitter will seamlessly continue sending the new events.

The output of the transmitter can be modulated using a carrier wave by setting RMT_CARRIER_EN_CHn. The
carrier waveform is configurable. In a carrier cycle, the high level lasts for (RMT_CARRIER_HIGH_CH» +1) clock
cycles of APB_CLK or REF_TICK, while the low level lasts for (RMT_CARRIER_LOW_CH)» +1) clock cycles of
APB_CLK or REF_TICK. When RMT_CARRIER_OUT_LV_CH)h is set to 1, carrier wave will be added on high-level
output signals; while RMT_CARRIER_OUT_LV_CH) is set to 0, carrier wave will be added on low-level output
signals. Carrier wave can be added on output signals during modulation, or just added on valid pulse codes (the
data stored in RAM), which can be set by configuring RMT_CARRIER_EFF_EN_CH)n.

The continuous transmission of the transmitter can be enabled by setting RMT_TX_CONTI_MODE_CH”. When
this register is set, the transmitter will send the pulse codes from RAM in loops. If RMT_TX_LOOP_CNT_EN_CHn
is set to 1, the transmitter will start counting loop times. Once the counting reaches the value of register
RMT_TX_LOOP_NUM_CHn, an RMT_CHn_TX_LOOP_INT interrupt will be generated.

Setting RMT_TX_SIM_EN to 1 will enable multiple channels to start sending data simultaneously.
RMT_TX_SIM_CH)h will choose which multiple channels are enabled to send data simultaneously.

10.2.5 Receiver

When RMT_RX_EN_CHn is set to 1, the receiver in channel 7 becomes active, detecting signal levels and
measuring clock cycles the signals lasts for. These data will be written in RAM in the form of pulse codes.
Receiving ends, when the receiver detects no change in a signal level for a number of clock cycles more than the
value set by RMT_IDLE_THRES_CH)». The receiver will return to idle state and generate an
RMT_CHn_RX_END_INT interrupt.

The receiver has an input signal filter which can be enabled by configuring RMT_RX_FILTER_EN_CHn. The filter
samples input signals continuously, and will detect the signals which remain unchanged for a continuous
RMT_RX_FILTER_THRES_CHn APB clock cycles as valid, otherwise, the signals will be detected as invalid. Only
the valid signals can pass through this filter. The filter will remove pulses with a length of less than
RMT_RX_FILTER_THRES_CH?n APB clock cycles.

10.2.6 Interrupts
*® RMT_CHn_ERR_INT: Triggered when channel” does not read or write data correctly. For example, if the
transmitter still tries to read data from RAM when the RAM is empty, or the receiver still tries to write data
into RAM when the RAM is full, this interrupt will be triggered.

© RMT_CHn_TX_THR_EVENT_INT: Triggered when the amount of data the transmitter has sent matches the

Espressif Systems 253 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

value of RMT_TX_LIM_CHhn.
e® RMT_CHn_TX_END_INT: Triggered when the transmitter has finished transmitting signals.
® RMT_CHn_RX_END_INT: Triggered when the receiver has finished receiving signals.

® RMT_CHn_TX_LOOP_INT: Triggered when the loop counting reaches the value set by
RMT_TX_LOOP_NUM_CHh.

10.3 Base Address

Users can access RMT with two base addresses, which can be seen in the following table. For more information
about accessing peripherals from different buses please see Chapter 1 System and Memory.

Table 42: RMT Base Address

 

 

 

 

Bus to Access Peripheral Base Address
PeriBUS1 Ox3F416000
PeriBUS2 0x60016000

 

 

 

10.4 Register Summary

The addresses in the following table are relative to RMT base addresses provided in Section 10.3.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Submit Documentation Feedback

Name | Description Address Access
Configuration registers
RMT_CHOCONFO_REG Channel 0 configuration register O 0x0010 RAW
RMT_CHOCONF1_REG Channel 0 configuration register 1 O0x001 4 varies
RMT_CH1CONFO_REG Channel 1 configuration register O 0x0018 RAW
RMT_CH1CONF1_REG Channel 1 configuration register 1 0x001C varies
RMT_CH2CONFO_REG Channel 2 configuration register 0 0x0020 RAW
RMT_CH2CONF1_REG Channel 2 configuration register 1 0x0024 varies
RMT_CH38CONFO_REG Channel 3 configuration register 0 0x0028 RAW
RMT_CH3CONF1_REG Channel 3 configuration register 1 0x002C varies
RMT_APB_CONF_REG RMT APB configuration register O0x0080 RAW
RMT_REF_CNT_RST_REG RMT clock divider reset register 0x0088 RAW
RMT_CHO_RX_CARRIER_RM_REG | Channel 0 carrier remove register Ox008C RAW
RMT_CH1_RX_CARRIER_RM_REG | Channel 1 carrier remove register O0x0090 RAW
RMT_CH2_RX_CARRIER_RM_REG | Channel 2 carrier remove register 0x0094 RAW
RMT_CH3_RX_CARRIER_RM_REG | Channel 3 carrier remove register O0x0098 RAW
Carrier wave duty cycle registers
RMT_CHOCARRIER_DUTY_REG Channel 0 duty cycle configuration register Ox0060 RAW
RMT_CH1CARRIER_DUTY_REG Channel 1 duty cycle configuration register O0x0064 RAW
RMT_CH2CARRIER_DUTY_REG Channel 2 duty cycle configuration register O0x0068 RAW
RMT_CH8CARRIER_DUTY_REG Channel 3 duty cycle configuration register Ox006C RAW
Tx event configuration registers
RMT_CHO_TX_LIM_REG Channel 0 Tx event configuration register 0x0070 varies
RMT_CH1_TX_LIM_REG Channel 1 Tx event configuration register O0x0074 varies
RMT_CH2_TX_LIM_REG Channel 2 Tx event configuration register 0x0078 varies
Espressif Systems 254 ESP32-S2 TRM (Preliminary V0.4)
10. Remote Control Peripheral

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Submit Documentation Feedback

Name Description Address Access
RMT_CH3_TX_LIM_REG Channel 3 Tx event configuration register 0x007C varies
RMT_TX_SIM_REG Enable RMT simultaneous transmission 0x0084 RAW
Status registers
RMT_CHOSTATUS_REG Channel 0 status register 0x0030 RO
RMT_CH1STATUS_REG Channel 1 status register 0x0034 RO
RMT_CH2STATUS_REG Channel 2 status register 0x0038 RO
RMT_CHS8STATUS_REG Channel 3 status register O0x003C RO
RMT_CHOADDR_REG Channel 0 address register 0x0040 RO
RMT_CH1ADDR_REG Channel 1 address register 0x0044 RO
RMT_CH2ADDR_REG Channel 2 address register 0x0048 RO
RMT_CH3ADDR_REG Channel 3 address register 0x004C RO
Version register
RMT_DATE_REG Version control register OxOOFC RAW
FIFO R/W registers
RMT_CHODATA_REG Read and write data for channel 0 via APB FIFO | Ox0000 RO
RMT_CH1DATA_REG Read and write data for channel 1 via APB FIFO | 0x0004 RO
RMT_CH2DATA_REG Read and write data for channel 2 via APB FIFO | Ox0008 RO
RMT_CHS3DATA_REG Read and write data for channel 3 via APB FIFO | OxO00C RO
Interrupt registers
RMT_INT_RAW_REG Raw interrupt status register O0x0050 RO
RMT_INT_ST_REG Masked interrupt status register O0x0054 RO
RMT_INT_ENA_REG Interrupt enable register 0x0058 RAW
RMT_INT_CLR_REG Interrupt clear register Ox005C WO
Espressif Systems 255 ESP32-S2 TRM (Preliminary V0.4)

 
10. Remote Control Peripheral

 

10.5 Registers

Register 10.1: RMT_CHnCONFO_REG (”: 0-3) (0x0010+8*n)

 

 

 

[ | = ||
[o ofa fa ft] oxt | 0x1000 | Ox2 |Reset

 

RMT_DIV_CNT_CH This field is used to configure clock divider for channel 7. (RAW)

RMT_IDLE_THRES CH Receiving ends when no edge is detected on input signals for continuous
clock cycles larger than this register value. (RAW)

RMT_MEM_ SIZE CH This field is used to configure the maximum blocks allocated to channel
The valid range is from 1 ~ 4-7. (RAW)

RMT_CARRIER_EFF_EN CH 1: Add carrier modulation on output signals only at data sending
state for channel 7. O: Add carrier modulation on signals at all states for channel 7. States here
include idle state(ST_IDLE), reacing data from RAM (ST_RD_MEM), and sending data stored in
RAM (ST_SEND). Only valid when RMT_CARRIER_EN_CH)/ is set to 1. (RAV)

RMT_CARRIER_EN_CH» This bit is used to enable carrier modulation for channel 7. 1: Add carrier
modulation on output signals. 0: No carrier modulation is added on output signals. (RAM)

RMT_CARRIER_OUT_LV_CHn This bit is used to configure the position of carrier wave for channel
. 1hO: Add carrier wave on low-level output signals. 1’h1: Add carrier wave on high-level output

signals. (RAV)

Espressif Systems 256 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

Register 10.2: RMT_CHnCONF1_REG (: 0-3) (0x0014+8*n)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

x
RO" ¥ x
PR AS’ cae SVE SRS
go 2078 xX Se QD EAS’ oS
NEYO Qy QR end S WK
LAS5 > & LE LS OO? RAE
Me eS ws WY MY Paw 2 SOS
Ss Ae, CVE IAN a ARO LOO?
ge Ks Ke Sa$ 7 «S Se aK) KS K/
¢ SESES & SESSEEES
31 21) 20 19 18 17 16 | 15 8 7 6 5 4 3 2 1 0
0 000 00 00 0 0 ofolofololfo Oxf o}oli]olo]o]o]o |reset
RMT_TX_START_CH» Set this bit to start sending data on channel n. (RAV)
RMT_RX_EN_CH» Set this bit to enable receiver to receive data on channel n. (RAV)
RMT_MEM_WR_RST_CH Setthis bit to reset RAM write address accessed by the receiver for chan-
nel n. (WO)
RMT_MEM_RD_RST_CH Set this bit to reset RAM read address accessed by the transmitter for
channel 7. (WO)
RMT_MEM_OWNER_CH)” This bit marks the ownership of channel n’s RAM block. 1’h1: Receiver
is using the RAM. 1’hO: Transmitter is using the RAM. (RAV)
RMT_TX_CONTIMODE_CH” Set this bit to restart transmission in continuous mode from the first
data in channel n. (RAN)
RMT_RX_FILTER_EN CH Set this bit to enable the receiver's filter for channel n. (RAW)
RMT_RX_FILTER_THRES_CH” Set this field to ignore the input pulse when its wicth is less than
RMT_RX_FILTER_THRES_CH» APB clock cycles in receive mode. (R/W)
RMT_CHK_RX_CARRIER_EN CH Set this bit to enable memory loop read mode when carrier
modulation is enabled for channel n. (RAV)
RMT_REF_ALWAYS_ON_CHn Set this bit to select a base clock for channel 7. 1’h1: APB_CLKk;
1’hO: REF_TICK (RAW)
RMT_IDLE_OUT_LV_CH» This bit configures the level of output signals in channel 7 when the trans-
mitter is in idle state. (RW)
RMT_IDLE_OUT_EN_CHn This is the output enable bit for channel 7 in idle state. (RAV)
RMT_TX_STOP_CHn Set this bit to stop the transmitter of channel 7 sending data out. (R/W)
Espressif Systems 257 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
10. Remote Control Peripheral

 

Register 10.3: RMT_APB_CONF_REG (0x0080)

 

 

 

Sa
S 2 SEF axe
QIN LS S
SEEES
S SOLE
al & GEOL’
WS s A> KO KOKI AD
& & Wor aa
[= ‘Te]s}e] +] 2]
[ofo 0 0 0 9 090000000000 00 00 00 0 0 ofofol[i]o]o reset

 

RMT_APB_FIFO_MASK_ 1’h1: Access memory directly; 1’hO: Access memory via APB FIFO. (R/W)
RMT_MEM_TX_WRAP_EN Set this bit to enable wrap mode. (RAV)

RMT_MEM_CLK_FORCE_ON Set this bit to enable the clock for RAM when RMT module starts
working; disable this clock when RMT stops working, to achieve low-power scheme. (R/W)

RMT_MEM_FORCE_PD Set this bit to power down RMT memory. (RAV)

RMT_MEM_FORCE_PU_ 1: Disable RAM’s Light-sleep power down function. 0: power down RMT
RAM when RMT is in Light-sleep mode. (R/W)

RMT_CLK_EN Clock gating enable bit for RMT registers to achieve low-power scheme. 1: Power up
drive clock for RMT registers. 0: Power down drive clock for RMT registers. (RAW)

Register 10.4: RMT_REF_CNT_RST_REG (0x0088)

 

 

 

 

KX
ATARATASTER
SESE
SESS
& EE EE
e SEES
€ &
[1 elsfe]s[o]
joo 0 0 0000000000000 00000 00 0 0 0 ofofo[o][o IReset
RMT_REF_CNT_RST_CH” This bit is used to reset the clock divider of channel 7. (RAW)
Espressif Systems 258 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
10. Remote Control Peripheral

 

Register 10.5: RMT_CHn_RX_CARRIER_RM_REG (7: 0-3) (0x008C+4*/)

 

 

 

| x00 | x00 | Reset

 

RMT_CARRIER_LOW_THRES_ CH” The low level period in carrier modulation mode is
(RMT_CARRIER_LOW_THRES_CH)» + 1) clock cycles for channel. (RAM)

RMT_CARRIER_HIGH_THRES_CH” The high level period in carrier modulation mode is
(RMT_CARRIER_HIGH_THRES_CH? + 1) clock cycles for channel n. (RAV)

Register 10.6: RMT_CH7CARRIER_DUTY_REG (7: 0-3) (0x0060+4*/)

 

 

 

oF $
we oe
& e&
< s
K7 ww
S S
| 31 16 | 15 o |
| Ox40 | 0x40 |Reset

 

RMT_CARRIER_LOW_CHn This field is used to configure the clock cycles of carrier wave at low level
for channel 7. (RAV)

RMT_CARRIER_HIGH_CH” This field is used to configure the clock cycles of carrier wave at high
level for channel 7. (RAW)

Espressif Systems 259 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

Register 10.7: RMT_CHn_TX_LIM_REG (7: 0-3) (0x0070+4*n)

 

 

 

ss
Oo
78
Es eS
LS
oe Ss
Se? g> eS
ee Sv ey
eS ay a ay
NG ee € <
[a1 a1] 20 [19 | os o|
fo 0 9 9 0 0 0 0 0 0 ofofo] Ox0 | oxe0 |Reset

 

RMT_TX_LIM_CH” This field is used to configure the maximum entries channel 7 can send out.
When RMT_MEM_SIZE_CHh = 1, this field can be set to any value among 0 ~ 128 (64 * 32/16
= 128); when RMT_MEM_SIZE_CHh > 1, this field can be set to any value among (0 ~ 128) *
RMT_MEM_SIZE_CHn. (R/W)

RMT_TX_LOOP_NUM_CH” This field is used to configure the maximum loop times when continuous
transmission mode is enabled. (R/WV)

RMT_TX_LOOP_CNT_EN_ CH This bit is used to enable loop counting. (R/W)

RMT_LOOP_COUNT_RESET_CH” This bit is used to reset loop counting when continuous trans-
mission mode is valid. (WO)

Register 10.8: RMT_TX_SIM_REG (0x0084)

S Sgro

 

 

 

& IMIR
[a1 slefe[e[ife]
jo9 0000000000000 00 000 00 00 0 0 ofofo[o]o]o IReset

 

RMT_TX_SIM_CH” Set this bit to enable channel - to start sending data simultaneously with other
enabled channels. (RAW)

RMT_TX_SIM_EN This bit is used to enable multiple channels to start sending data simultaneously.
(RAV)

Espressif Systems 260 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

Register 10.9: RMT_CHnSTATUS_REG (7: 0-3) (0x0030+4*7)

 

 

 

ESS SF so #
OG ER 7 Lv
gesier © eS & &
& PLEO’ & & eS ° & er
E& &&SK SK & & &
ESP EEE PE LT J
[o 0 0 ofofofofofo| x0 [o] x0 [o] x0 |Reset

 

RMT_MEM_WADDR_EX_ CH)? This field records the memory address offset when receiver of channel
is using the RAM. (RO)

RMT_MEM_RADDR_EX_CH” This field records the memory address offset when transmitter of
channel” is using the RAM. (RO)

RMT_STATE_CH” This field records the FSM status of channel 7. (RO)

RMT_MEM_OWNER_ERR_CH? This status bit will be set when the ownership of memory block is
violated. (RO)

RMT_MEM_FULL_CHn This status bit will be set if the receiver receives more data than the memory
allows. (RO)

RMT_MEM_EMPTY_CH? This status bit will be set when the cata to be sent is more than the memory
allows and the wrap mode is disabled. (RO)

RMT_APB_MEM WR_ERR_CH)? This status bit will be set if the offset address is out of memory size
when channel? writes RAM via APB bus. (RO)

RMT_APB_ MEM _RD_ERR_CH? This status bit will be set if the offset address is out of memory size
when channel 7 reads RAM via APB bus. (RO)

Register 10.10: RMT_CH»ADDR_REG (n: 0-3) (0x0040+4*»)

 

 

 

& Ss
xv se
Se Ss
w w
& & & &
@ Ka? S Kg?
é & J é &
| 31 1g | 18 10 | 9 | 8 o |
[o 00000000000 o| Oxo [o] OxO |Reset

 

RMT_APB_MEM WADDR_CH)n This field records the memory address offset when channel 2 writes
RAM via APB bus. (RO)

RMT_APB_MEM_RADDR_CH)n This field records the memory address offset when channel 7 reads
RAM via APB bus. (RO)

Espressif Systems 261 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

Register 10.11: RMT_DATE_REG (Ox00FC)

&
€
[2 |

| 0x19072601 | Reset

 

 

 

RMT_DATE Version control register. (RAV)

Register 10.12: RMT_CHnDATA_REG (: 0-3) (0x0000+4*")

 

[2 |

| 0x000000 | Reset

 

 

RMT_CHn_DATA_REG This register is used to read and write data for channel 7 via APB FIFO. (RO)

Register 10.13: RMT_INT_RAW_REG (0x0050)

 

 

 

 

RMT_CHn_TX_END_INT_RAW Theinterrupt raw bit for channel. Triggered when transmitting ends.
(RO)

RMT_CHn_RX_END_INT_RAW The interrupt raw bit for channel 7. Triggered when receiving ends.
(RO)

RMT_CHn_ERR_INT_RAW The interrupt raw bit for channel n. Triggered when error occurs. (RO)

RMT_CHn_TX_THR_EVENT_INT_RAW The interrupt raw bit for channel 7. Triggered when trans-
mitter sends more data than configured value. (RO)

RMT_CHn_TX_LOOP_INT_RAW The interrupt raw bit for channel 7. Triggered when loop counting
reaches the configured threshold value. (RO)

Espressif Systems 262 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

 

Register 10.14: RMT_INT_ST_REG (0x0054)

g ¥ 7 7 7 7 KO aX POD RIOT OOK
SPF FELL SOUS SES SES
TAT AALS SN SE AE ELST
& RRP HMR KKM PMV RRR MMF
PSP BSP PM SP SP SPS S

[a1 20 | 19

 

18 wf lsu] el ufo] [es

| » | [| [s[2]+][°|
foo 0 0 0 0 0 0 0 0 0 ofofofofofofojofofofofofo]ofo][ofo]o]ofo]o ]reset

 

 

 

RMT_CHn_TX_END_INT_ST The masked interrupt status bit for RMT_CHn_TX_END_INT. (RO)
RMT_CHn_RX_END_INT_ST The masked interrupt status bit for RMT_CHn_RX_END_INT. (RO)
RMT_CHn_ERR_INT_ST The masked interrupt status bit for RMT_CHn_ERR_INT. (RO)

RMT_CHn_TX_THR_EVENT_INT_ST The masked interrupt status bit for
RMT_CHn_TX_THR_EVENT_INT. (RO)

RMT_CHn_TX_LOOP_INT_ST The masked interrupt status bit for RMT_CHn_TX_LOOP_INT. (RO)

Register 10.15: RMT_INT_ENA_ REG (0x0058)

Sd WWW AOLOQUYLAD AK 2% 7 O04 WM, MLAWLLALO’ Oo”
wa Pa Ga Ge Pe Pa Fa Ga Ge Gog Pe Fa Fe Sa Fee Pg Fog Fe Ga F

 

 

 

RMT_CHn_TX_END_INT_ENA Interrupt enable bit for RMT_CHn_TX_END_INT. (RAW)
RMT_CHn_RX_END_INT_ENA Interrupt enable bit for RMT_CHn_RX_END_INT. (RAV)
RMT_CHn_ERR_INT_ENA Interrupt enable bit for RMT_CHn_ERR_INT. (RAM)

RMT_CH_TX_THR_EVENT_INT_ENA Interrupt enable bit for RMT_CHn_TX_THR_EVENT_INT.
(RAW)

RMT_CHn_TX_LOOP_INT_ENA Interrupt enable bit for RMT_CHn_TX_LOOP_INT. (RAV)

Espressif Systems 263 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
10. Remote Control Peripheral

Register 10.16: RMT_INT_CLR_REG (0x005C)

Ss
SATAN ANA NZ O77 7 7 Y7% Y7% YY NZ INZ NZ OZ OZ OZ
& SEPT EOE EEE OOOO SOOO
BSP EE SPM E SPT ES ST IS S Oe © Q
3 1

31 20] 19 | 1g | 17 | 16 | 15 | 14] 13] 12] 11) 1] 9 | @ | 7 J oe] 5 4

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

oO
oO
oO
oO
oO

000000 00 0 0 0 ofofolofo}lolololololololo]o]o]o Reset

 

 

 

RMT_CHn_TX_END_INT_CLR_ Set this bit to clear RMT_CHn_TX_END_INT interrupt. (WO)
RMT_CHn_RX_END_INT_CLR Set this bit to clear RMT_CHn_RX_END_INT interrupt. (WO)
RMT_CHn_ERR_INT_CLR Set this bit to clear RMT_CHn_ERR_INT interrupt. (WO)

RMT_CHn_TX_THR_EVENT_INT_CLR Set this bit to clear RMT_CHn_TX_THR_EVENT_INT inter-
rupt. (WO)

RMT_CHn_TX_LOOP_INT_CLR_ Set this bit to clear RMT_CHn_TX_LOOP_INT interrupt. (WO)

Espressif Systems 264 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

 

11.

Pulse Count Controller

The pulse count controller (PCNT) is designed to count input pulses and generate interrupts. It can increment or

decrement a pulse counter value by keeping track of rising (positive) or falling (negative) edges of the input pulse

signal. The PCNT has four independent pulse counters, called units which have their groups of registers. In this

chapter, 7 denotes the number of a unit from 0 ~ 3.

Each unit includes two channels (chO and ch1) which can independently increment or decrement its pulse

counter value. The remainder of the chapter will mostly focus on channel O (ch0) as the functionality of the two

channels is identical.

As shown in Figure 11-1, each channel has two input signals:

1. One control signal (e.g. ctrl_chO_un, the control signal for chO of unit n)

2. One input pulse signal (e.g. sig_chO_un, the input pulse signal for chO unit n)

Input pulse
Control

Input pulse
Control

JUL Input pulse
Control

Input pulse
Control

JUL Input pulse
Control

Input pulse
Control

JUUL Input pulse
Control

Input pulse
Control

Figure 11-1.

11.1 Features
A PCNT has the following features:

Four independent pulse counters (units)

 

—>
—>

CHO

 

—>
—>

CH1

Unito

 

 

— |
——>|

CHO

 

—>
—>

CH1

Unit1

 

 

— |
——>|

CHO

 

|
|

CH1

Unit2

 

 

— |
——>|

CHO

 

—>|
——>|

 

CH1

 

Unit3

 

 

PCNT Block Diagram

Each unit consists of two independent channels sharing one pulse counter

All channels have input pulse signals (e.g. sig_chO_un) with their corresponding control signals (e.g.

ctrl_chO_un)

Independent filtering of input pulse signals (sig_chO_un and sig_ch1_un) and control signals (ctrl_chO_un

and ctrl_ch1_un) on each unit

Each channel has the following parameters:

1. Selection between counting on positive or negative edges of the input pulse signal

Espressif Systems

265

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
11. Pulse Count Controller

2. Configuration to Increment, Decrement, or Disable counter mode for control signal’s high and low
states

11.2 Functional Description

 

 

 

 

 

 

 

 

 

PCNT_CHO_LCTRL_MODE_U
PCNT_THR_L_LIM_EN_Un [EN PGNT_GHO_HCTRI_MODE_Un PCNT-FILTER_EN_U cho
SEEN PCNT_GHO_POS_MODE_U PCNT_FILTER_THRES_U
PONT_CNT_L_LUIM_U: comparator —,
PCNT_CNT_L.LIM_Un |
1 rl chO_u

PCNT_THR_H_LIM_EN_Un [EN Le! Lo
T_T .
PCNT_CNT_H_LIM_Un _ | Comparator inc_dec
So

PL ' sig_ch0_u

 

 

 

 

 

 

cLR

 

 

adder

 

 

 

 

 

 

pulse_cni| 1
<~—_—4

rl chi_u
PCNT_THR_THRESO_EN_Un |EN t 5
|

PCNT_CNT_PAUSE_Un ——] inc_dec

PCNT_PLUS_CNT_RST_U! ]
1 Ig_ch1_u:

PCNT_CH1_LCTRL_MODE_U!
PCNT_CH1_HCTRL_MODE_U
PONT GH1_POS. MODE_U

PGNT_CH1_NEG_MODE_U: chi

 

   
   

PGNT_GNT_THRESO_Un, | Comparator
—enesceeo»

 

 

 

 

 

 

 

wag

 

PCNT_THR_THRES1_EN_Un |EN
a

PONT_CNT_THRES1_Un, | Comparator
oo

 

 

 

 

 

PCNT_THR_ZERO_EN_U: EN
|

 

0 comparator
Sel

 

 

 

thr_event

 

 

 

 

 

Figure 11-2. PCNT Unit Architecture

Figure 11-2 shows PCNT’s architecture. As stated above, ctrl_chO_un is the control signal for chO of unit n. Its
high and low states can be assigned different counter modes and used for pulse counting of the channel's input
pulse signal sig_chO_un on negative or positive edges. The available counter modes are as follows:

® Increment mode: When a channel detects an active edge of sig_chO_un (the one configured for counting),
the counter value pulse_cnt increases by 1. Upon reaching PCNT_CNT_H_LIM_Un, pulse_cnt is cleared. If
the channel’s counter mode is changed or if PCNT_CNT_PAUSE_Un is set before pulse_cnt reaches
PCNT_CNT_H_LIM_Un, then pulse_cnt freezes and its counter mode changes.

* Decrement mode: When a channel detects an active edge of sig_chO_un (the one configured for counting),
the counter value pulse_cnt decreases by 1. Upon reaching PCNT_CNT_L_LIM_Un, pulse_cnt is cleared. If
the channel’s counter mode is changed or if PCNT_CNT_PAUSE_Un is set before pulse_cnt reaches
PCNT_CNT_H_LIM_Un, then pulse_cnt freezes and its counter mode changes.

* Disable mode: Counting is disabled, and the counter value pulse_cnt freezes.
Table 44 to Table 47 provide information on how to configure the counter mode for channel 0.

Each unit has one filter for all its control and input pulse signals. A filter can be enabled with the bit

PCNT_FILTER_EN_Un. The filter monitors the signals and ignores all the noise, i.e. the glitches with pulse widths
shorter than

PCNT_FILTER_THRES_Un APB clock cycles in length.

As previously mentioned, each unit has two channels which process different input pulse signals and increase or
decrease values via their respective inc_dec modules, then the two channels send these values to the adder

Espressif Systems 266 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

 

Table 44: Counter Mode. Positive Edge of Input Pulse Signal. Control Signal in Low State

 

PCNT_CHO_POS_MODE_U

PCNT_CHO_LCTRL_MODE_U

Counter Mode

 

 

 

 

 

 

 

 

0 Increment
q q Decrement

Others Disable

0 Decrement
2 q Increment

Others Disable
Others N/A Disable

 

 

 

Table 45: Counter Mode. Positive Edge of Input Pulse Signal. Control Signal in High State

 

PCNT_CHO_POS_MODE_U

PCNT_CHO_HCTRL_MODE_U

Counter Mode

 

 

 

 

 

 

 

 

0 Increment
q q Decrement

Others Disable

0 Decrement
2 q Increment

Others Disable
Others N/A Disable

 

 

 

Table 46: Counter Mode. Negative Edge of Input Pulse Signal. Control Signal in Low State

 

PCNT_CHO_NEG_MODE_U

PCNT_CHO_LCTRL_MODE_U

Counter Mode

 

 

 

 

 

 

 

 

 

 

0 Increment
q q Decrement

Others Disable

0 Decrement
2 q Increment

Others Disable
Others N/A Disable

 

Table 47: Counter Mode. Negative Edge of Input Pulse Signal. Control Signal in High State

 

PCNT_CHO_NEG_MODE_U

PCNT_CHO_HCTRL_MODE_U

Counter Mode

 

 

 

 

 

 

 

 

 

 

 

0 Increment
q q Decrement

Others Disable

0 Decrement
2 q Increment

Others Disable
Others N/A Disable

267

Espressif Systems

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 

 

 

 
11. Pulse Count Controller

 

module that is 16-bit wide with a sign bit. This adder can be suspended by setting PCNT_CNT_PAUSE_Un, and
cleared by setting PCNT_PULSE_CNT_RST_Un.

The PCNT has five watchpoints that share one interrupt. The interrupt can be enabled or disabled by interrupt
enable signals of each individual watchpoint.

* Maximum count value: When pulse_cnt reaches PCNT_CNT_H_LIM_U), an interrupt is triggered and
PCNT_CNT_THR_H_LIM_LAT_Up is high.

* Minimum count value: When pulse_cnt reaches PCNT_CNT_L_LIM_Upn, an interrupt is triggered and
PCNT_CNT_THR_L_LIM_LAT_Un is high.

* Two threshold values: When pulse_cnt equals either PCNT_CNT_THRESO_Un or
PCNT_CNT_THRES1_U), an interrupt is triggered and either PCNT_CNT_THR_THRESO_LAT_Un or
PCNT_CNT_THR_THRES1_LAT_Un is high respectively.

* Zero: When pulse_cnt is 0, an interrupt is triggered and PCNT_CNT_THR_ZERO_LAT_U)n is valid.

11.3. Applications

In each unit, channel O and channel 1 can be configured to work independently or together. The three
subsections below provide details of channel 0 incrementing independently, channel 0 decrementing
independently, and channel 0 and channel 1 incrementing together. For other working modes not elaborated in
this section (e.g. channel 1 incrementing/decremeting independently, or one channel incrementing while the
other decrementing), reference can be made to these three subsections.

11.3.1. Channel 0 Incrementing Independently

 

 

¢tr_chO_u

 

 

 

 

 

 

   
  

sig_chO_ur

5 PCNT_THR_H_LIM_U:

Plus_cnt

4
3
2
1
0

 

 

 

Figure 11-3. Channel 0 Up Counting Diagram

Figure 11-3 illustrates how channel 0 is configured to increment independently on the positive edge of
sig_chO_un while channel 1 is disabled (see subsection 11.2 for how to disable channel 1). The configuration of
channel 0 is shown below.

* PCNT_CHO_LCTRL_MODE_Un=0: When ctri_chO_un is low, the counter mode specified for the low state
turns on, in this case it is Increment mode.

PCNT_CHO_HCTRL_MODE_Un=2: When ctrl_chO_un is high, the counter moce specified for the low state
turns on, in this case it is Disable mode.

PCNT_CHO_POS_MODE_Un=1: The counter increments on the positive edge of sig_chO_un.

PCNT_CHO_NEG_MODE_Un=0: The counter idles on the negative edge of sig_chO_un.

PCNT_CNT_H_LIM_Un=5: When pulse_cnt counts up to PCNT_CNT_H_LIM_U), it is cleared.

Espressif Systems 268 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

 

11.3.2 Channel 0 Decrementing Independently

 

 

etr_chO_u’

 

 

 

 

 

sig_ch_ui

plus_ent

miko wad

 

 

 

 

Figure 11-4. Channel 0 Down Counting Diagram

Figure 11-4 illustrates how channel 0 is configured to decrement independently on the positive edge of
sig_chO_un while channel 1 is disabled. The configuration of channel 0 in this case differs from that in Figure 11-3
in the following aspects:

e PCNT_CHO_POS_MODE_Un=2: the counter decrements on the positive edge of sig_chO_un.

® PCNT_CNT_L_LIM_Un=-5: when pulse_cnt counts down to PCENT_CNT_L_LIM_U), it is cleared.

11.3.3. Channel 0 and Channel 1 Incrementing Together

 

   
 
 
  
  
  
  

ctri_chO_ui
ctr_cht_ui

sig_chO_u
sig_ch1_u
PCNT_THR_H_LIM_U:

8
plus_ent ¢

ON

 

 

 

Figure 11-5. Two Channels Up Counting Diagram

Figure 11-5 illustrates how channel 0 and channel 1 are configured to increment on the positive edge of
sig_chO_un and sig_ch1_un respectively at the same time. It can be seen in Figure 11-5 that control signal
ctrl_chO_un and ctrl_ch1_un have the same waveform, so as input pulse signal sig_chO_un and sig_ch1_un. The
configuration procedure is shown below.

© For channel 0:

PCNT_CHO_LCTRL_MODE_Un=0: When ctrl_chO_un is low, the counter mode specified for the low
state turns on, in this case it is Increment mode.

PCNT_CHO_HCTRL_MODE_Un=2: When ctrl_ch0_un is high, the counter mode specified for the low
state turns on, in this case it is Disable mode.

PCNT_CHO_POS_MODE_Un=1: The counter increments on the positive edge of sig_chO_un.
-— PCNT_CHO_NEG_MODE_Un=0: The counter idles on the negative edge of sig_chO_un.

© For channel 1:

Espressif Systems 269 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

 

state turns on, in this case it is Disable mode.

PCNT_CH1_POS_MODE_Un=1: The counter increments on the positive edge of sig_ch1_un.

-— PCNT_CH1_NEG_MODE_Un=0: The counter idles on the negative edge of sig_ch1_un.

* PCNT_CNT_H_LIM_Un=10: When pulse_cnt counts up to PCENT_CNT_H_LIM_U), it is cleared.

11.4 Base Address

PCNT_CH1_LCTRL_MODE_Un=0: When ctrl_ch1_un is low, the counter mode specified for the low
state turns on, in this case it is Increment mode.

PCNT_CH1_HCTRL_MODE_Un=2: When ctrl_ch1_un is high, the counter mode specified for the low

Users can access the PCNT registers with two base addresses, which can be seen in the following table. For

more information about accessing peripherals from different buses please see Chapter 1 System and

Memory.

Table 48: PCNT Base Address

 

 

 

 

Bus to Access Peripheral Base Address
PeriBUS1 Ox8F 417000
PeriBUS2 0x60017000

 

 

 

11.5 Register Summary

The addresses in the following table are relative to the PCNT base addresses provided in Section 11.4.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access
Configuration Register

PCNT_UO_CONFO_REG Configuration register O for unit O Ox0000 | RAV
PCNT_UO_CONF1_REG Configuration register 1 for unit O O0x0004 | RAV
PCNT_UOQ_CONF2_REG Configuration register 2 for unit O Ox0008 | RAV
PCNT_U1_CONFO_REG Configuration register O for unit 1 Ox000C | RAV
PCNT_U1_CONF1_REG Configuration register 1 for unit 1 O0x0010 | RAV
PCNT_U1_CONF2_REG Configuration register 2 for unit 1 0x0014 | RAV
PCNT_U2_ CONFO_REG Configuration register O for unit 2 0x0018 | RAV
PCNT_U2_CONF1_REG Configuration register 1 for unit 2 Ox001C | RAV
PCNT_U2_CONF2_REG Configuration register 2 for unit 2 0x0020 | RAV
PCNT_US_CONFO_REG Configuration register O for unit 3 0x0024 | RAV
PCNT_US_CONF1_REG Configuration register 1 for unit 3 0x0028 | RAV
PCNT_US_CONF2_REG Configuration register 2 for unit 3 Ox002C | RAV
PCNT_CTRL_REG Control register for all counters Ox0060 | RAV
Status Register

PCNT_UO_CNT_REG Counter value for unit 0 0x0030 | RO
PCNT_U1_CNT_REG Counter value for unit 1 0x0034 | RO
PCNT_U2_CNT_REG Counter value for unit 2 0x0038 | RO
PCNT_US_CNT_REG Counter value for unit 3 Ox0038C | RO
PCNT_UO_STATUS_REG PNCT unitO status register 0x0050 | RO

 

Espressif Systems

270

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
11. Pulse Count Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
PCNT_U1_STATUS_REG PNCT unit1 status register 0x0054 | RO
PCNT_U2_STATUS_REG PNCT unit2 status register 0x0058 | RO
PCNT_US_ STATUS REG PNCT unit3 status register Ox005C | RO
Interrupt Register

PCNT_INT_RAW_REG Interrupt raw status register 0x0040 | RO
PCNT_INT_ST_REG Interrupt status register 0x0044 | RO
PCNT_INT_ENA_REG Interrupt enable register 0x0048 | RAV
PCNT_INT_CLR_REG Interrupt clear register O0x004C | WO
Version Register

PCNT_DATE_REG PCNT version control register OxOOFC | RAV

 

Espressif Systems

271

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
11. Pulse Count Controller

 

11.6 Registers

Register 11.1: PCNT_Un_CONFO_REG (: 0-3) (0x0000+12*7)

 

 

 

S P 6 © S P 6 © ©
7 7 y »S / »S »
Ro * oS SS & LoS ISS Ss S S &
»s SY SN SY AMoX SOD 7
CM SS kL SS oY GOSSOR” &
SS PDN DS LEE SO S
AY NX 7 S N\7 oY O7 O7 0% QW’ Qv YOM S
OR RR KSEE So
L L L L L L L L L L L L L L L
[1 30] 29 227 2s [25 x |2s 2221 219 a[ar w[s[ule]e] uf o]s o|
[| oo | oo [ oo | 00 | oo | oo | oo | oo fofofifi [i]s] Ox10 |Reset

 

PCNT_FILTER_THRES Un This sets the maximum threshold, in APB_CLK cycles, for the filter. Any
pulses with width less than this will be ignored when the filter is enabled. (RAM)

PCNT_FILTER_EN Un This is the enable bit for unit ’s input filter. (RAV)
PCNT_THR_ZERO_EN_Un This is the enable bit for unit n’s zero comparator. (R/W)
PCNT_THR_H_LIM_EN_Un This is the enable bit for unit n’s thr_h_lim comparator. (RAV)
PCNT_THR_L_LIM_EN_Un This is the enable bit for unit o’s thr_l_lim comparator. (R/W)
PCNT_THR_THRESO EN _U This is the enable bit for unit n’s thresO comparator. (R/W)
PCNT_THR_THRES1_EN_U This is the enable bit for unit n’s thres1 comparator. (R/W)

PCNT_CHO_NEG MODE _Un This register sets the behavior when the signal input of channel 0 de-
tects anegative edge. 1: Increase the counter; 2: Decrease the counter; 0, 3: No effect on counter

(RW)

PCNT_CHO_POS_MODE_Un This register sets the behavior when the signal input of channel 0 de-
tects a positive edge. 1: Increase the counter; 2: Decrease the counter; 0, 3: No effect on counter

(RW)

PCNT_CHO_HCTRL_MODE_Un This register configures how the
CHn_POS_MODE/CHn_NEG_MODE settings will be modified when the control signal is
high. O: No modification; 1: Invert behavior (increase -> decrease, decrease -> increase); 2, 3:
Inhibit counter modification (RW)

PCNT_CHO_LCTRL_ MODE _Un This register configures how the
CHn_POS_MODE/CHn_NEG_MODE settings will be modified when the control signal is
low. 0: No modification; 1: Invert behavior (increase -> decrease, decrease -> increase); 2, 3:
Inhibit counter modification (RW)

PCNT_CH1_NEG MODE _Un This register sets the behavior when the signal input of channel 1 de-
tects a negative edge. 1: Increment the counter; 2: Decrement the counter; 0, 3: No effect on

counter (RAW)

PCNT_CH1_POS MODE_Un This register sets the behavior when the signal input of channel 1 de-
tects a positive edge. 1: Increment the counter; 2: Decrement the counter; 0, 3: No effect on
counter (RAW)

Continued on the next page...

Espressif Systems 212 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

 

Register 11.1: PCNT_Un_CONFO_REG (: 0-3) (0x0000+12*7)

Continued from the previous page ...

PCNT_CH1_HCTRL_MODE_Un This register configures how the
CHn_POS_MODE/CHn_NEG_MODE settings will be modified when the control signal is
high. O: No modification; 1: Invert behavior (increase -> decrease, decrease -> increase); 2, 3:
Inhibit counter modification (RW)

PCNT_CH1_LCTRL_ MODE _Un This register configures how the
CHn_POS_MODE/CHn_NEG_MODE settings will be modified when the control signal is
low. 0: No modification; 1: Invert behavior (increase -> decrease, decrease -> increase); 2, 3:
Inhibit counter modification (RW)

Register 11.2: PCNT_Un_CONF1_REG (”: 0-3) (0x0004+12*7)

 

 

& &
NZ 9/7
E P
& SO
ow ov
~ x
£ £
31 16] 15 oO
0x00 0x00 Reset

 

 

 

 

PCNT_CNT_THRESO Un This register is used to configure the thresO value for unit 7. (RAV)

PCNT_CNT_THRES1_Un This register is used to configure the thres1 value for unit 7. (RAW)

Register 11.3: PCNT_Un_CONF2_REG (”: 0-3) (0x0008+12*7)

 

 

 

Ss Ss
SY sw
y Y
os 7 os 7
& <
& &
| 31 16 | 15 0 |
Ox00 | 0x00 |Reset

 

PCNT_CNT_H_LIM Un This register is used to configure the thr_h_lim value for unit 7. (RAM)

PCNT_CNT_L_LIM_U This register is used to configure the thr_|_lim value for unit n. (RAM)

Espressif Systems 273 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

 

Register 11.4: PCNT_CTRL_REG (0x0060)

&
Q
& & & g

[a1 7] 16 [a 8

 

 

[7 Tels {+]s]e[:|
fo.0 9 00 0000000 0 0 ofofo 0 0 0 0 0 0 ofoftfo]ifol[1]o] 1 Ireset

 

PCNT_ PULSE CNT_RST_U” Set this bit to clear unit n’s counter. (RW)
PCNT_CNT_ PAUSE Un Set this bit to freeze unit n’s counter. (R/W)

PCNT_CLK_EN The registers clock gate enable signal of PCNT module. 1: the registers can be read
and written by application. 0: the registers can not be read or written by application (R/W)

Register 11.5: PCNT_DATE_REG (0x00FC)

K&»
ss
&

 

 

| 0x19072601 | Reset

 

PCNT_DATE This is the PCNT version control register. (RAV)

Register 11.6: PCNT_Un_CNT_REG (: 0-3) (0x0030+4*")

 

 

Oo
oa
x’
S o”
s eS
S oe
x g
31 16} 15 o
0000000000000 00 0 x00 Reset

 

 

 

 

PCNT_PULSE_CNT_Un This register stores the current pulse count value for unit 7. (RO)

Espressif Systems 274 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

 

Register 11.7: PCNT_Un_STATUS_REG (7: 0-3) (0x0050+4*n)

 

 

 

PCNT_CNT_THR_ZERO_MODE_U” The pulse counter status of PCNT_Un corresponding to 0. 0:
pulse counter decreases from positive to 0. 1: pulse counter increases from negative to 0. 2:
pulse counter is negative. 3: pulse counter is positive. (RO)

PCNT_CNT_THR_THRES1 LAT Un The latched value of thres1 event of PCNT_Un when threshold
event interrupt is valid. 1: the current pulse counter equals to thres1 and thres1 event is valid. 0:
others (RO)

PCNT_CNT_THR_THRESO LAT Un The latched value of thresO event of PCNT_Un when threshold
event interrupt is valid. 1: the current pulse counter equals to thresO and thresO event is valid. 0:
others (RO)

PCNT_CNT_THR_L_LIM_LAT Un The latched value of low limit event of PCNT_Un when threshold
event interrupt is valid. 1: the current pulse counter equals to thr_|_lim and low limit event is valid.
0: others (RO)

PCNT_CNT_THR_H_LIM_LAT Un The latched value of high limit event of PCNT_Un when threshold
event interrupt is valid. 1: the current pulse counter equals to thr_h_lim and high limit event is valid.
0: others (RO)

PCNT_CNT_THR_ZERO_LAT Un The latched value of zero threshold event of PCNT_Un when
threshold event interrupt is valid. 1: the current pulse counter equals to 0 and zero threshold
event is valid. 0: others (RO)

Espressif Systems 275 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
11. Pulse Count Controller

Register 11.8: PCNT_INT_RAW_REG (0x0040)

ASRS AS RI
SESE
LLL’
& SEES
& SAE ZE AL
€ CLE ES

 

[1 elsfe]s[o]

joo 0 0 0000000000000 00000 00 0 0 0 ofofo[o][o IReset

 

PCNT_CNT_THR_EVENT_Un_INT_RAW The raw interrupt
PCNT_CNT_THR_EVENT_U_INT interrupt. (RO)

status bit for the

Register 11.9: PCNT_INT_ST_REG (0x0044)

 

 

 

 

RA BKA
DOO S
SIT
SSS
LLLL
LLC’
p SEES
ra OL LALZ
& CELL
[1 elefe]i fo]
[jo 0 0 0 0000000000000 000 00 00 0 0 0 ofolo]o]o Reset
PCNT_CNT_THR_EVENT_Un_INT_ST The masked interrupt status bit for — the
PCNT_CNT_THR_EVENT_Ur_INT interrupt. (RO)
Register 11.10: PCNT_INT_ENA_REG (0x0048)
We
SE

[1 elsfe]s[o]

joo 0 0 0000000000000 00000 00 0 0 0 ofofo[o][o IReset

PCNT_CNT_THR_EVENT_Un_INT_ENA The interrupt
PCNT_CNT_THR_EVENT_U_INT interrupt. (R/W)

enable bit for the

Espressif Systems 276 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
11. Pulse Count Controller

 

Register 11.11: PCNT_INT_CLR_REG (0x004C)

 

 

 

PCNT_CNT_THR_EVENT_Un_INT_CLR Set this bit to clear the PCNT_CNT_THR_EVENT_Un_INT
interrupt. (WO)

Espressif Systems ate ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

12. 64-bit Timers

12.1 Overview

General purpose timers can be used to precisely time an interval, trigger an interrupt after a particular interval
(periodically and aperiodically), or act as a hardware clock. As shown in Figure 12-1, the ESP32-S2 chip contains
two timer groups, namely timer group O and timer group 1. Each timer group consists of two general purpose
timers referred to as Tx (where ~ is O or 1) and one Main System Watchdog Timer. All general purpose timers are
based on 16-bit prescalers and 64-bit auto-reload-capable up/down counters.

 

 

 

 

 

 

 

 

 

 

 

 

 

Timer Group 0
Timer 0 Timer 1 Watchdog
(To) (71) nimer
(WDT)
Timer Group 1
Timer 0 Timer 1 Watchdog
(To) (11) Timer
(WDT)

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 12-1. Timer Units within Groups

Note that while the Main System Watchdog Timer registers are described in this chapter, their functional
description is included in the Chapter 13: Watchdog Timers. Therefore, the term ‘timers’ within this chapter refers
to the general purpose timers.

The timers’ features are summarized as follows:
* A 16-bit clock prescaler, from 1 to 65536
* A 64-bit time-base counter programmable to be incrementing or decrementing
* Able to read real-time value of the time-base counter
* Halting and resuming the time-base counter
* Programmable alarm generation
* Timer value reload (Auto-reload at alarm or software-controlled instant reload)

* Level and edge interrupt generation

Espressif Systems 278 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

12.2 Functional Description

12.2.1 16-bit Prescaler and Clock Selection

Each timer can select between the APB clock (APB_CLK) or external clock (XTAL_CLK) as its clock source by
setting the TIMG_Tx_USE_XTAL field of the TIMG_TxCONFIG_REG register. The clock is then divided by a 16-bit
prescaler to generate the time-base counter clock (TB_CLK) used by the time-base counter. The 16-bit prescaler
is configured by the TIMG_Tx_DIVIDER field and can take any value from 1 to 65536. Note that programming a
value of O in TIMG_Tx_DIVIDER will result in the divisor being 65536.

The timer must be disabled (i.e. TIMG_Tx_EN should be cleared) before modifying the 16-bit prescaler. Modifying
the 16-bit prescaler whilst the timer is enabled can lead to unpredictable results.

12.2.2 64-bit Time-based Counter

The 64-bit time-base counters are based on TB_CLK and can the configured to increment or decrement via the
TIMG_Tx_INCREASE field. The time-base counter can be enabled/disabled by setting/clearing the TIMG_Tx_EN
field. Whilst enabled, the time-base counter will increment/decrement on each cycle of TB_CLK. When disabled,
the time-base counter is essentially frozen. Note that the TIMG_Tx_INCREASE field can be changed whilst
TIMG_Tx_EN is set and will cause the time-base counter to change direction instantly.

To read the 64-bit current timer value of the time-base counter, the timer value must be latched to two registers
before being read by the CPU (due to the CPU being 32-bit). By writing any value to the TIMG_TxUPDATE_REG,
the current value of the 64-bit timer is instantly latched into the TIMG_TxLO_REG and TIMG_TxHI_REG registers
containing the lower and upper 32-bits respectively. TIMG_TxLO_REG and TIMG_TxHI_REG registers will remain
unchanged for the CPU to read in its own time until TIMG_TxUPDATE_REG is written to again.

12.2.3 Alarm Generation

A timer can be configured to trigger an alarm when the timer’s current value matches the alarm value. An alarm
will cause an interrupt to occur and (optionally) an automatic reload of the timer’s current value (see Section
12.2.4). The 64-bit alarm value is configured in the TIMG_TxALARMLO_REG and TIMG_TxALARMHI_REG
representing the lower and upper 32-bits of the alarm value respectively. However, the configured alarm value is
ineffective until the alarm is enabled by setting the TIMG_Tx_ALARM_EN field. In order to simply the scenario
where the alarm is enabled ‘too late’ (i.e. the timer value has already passed the alarm value when the alarm is
enabled), the alarm value will also trigger immediately if the current timer value is larger/smaller than the alarm
value for an up-counting/down-counting timer.

When an alarm occurs, the TIMG_Tx_ALARM_EN field is automatically cleared and no alarm will occur again until
the TIMG_Tx_ALARM_EN is set.

12.2.4 Timer Reload

A timer is reloaded when a timer’s current value is overwritten with a reload value stored in the
TIMG_Tx_LOAD_LO and TIMG_Tx_LOAD_HI registers that correspond to the lower and upper 32-bits of the
timer’s new value respectively. However, writing a reload value to TIMG_Tx_LOAD_LO and TIMG_Tx_LOAD_HI
will not cause the timer’s current value to change. Instead, the reload value is ignored by the timer until a reload
event occurs. A reload event can be triggered either by a software instant reload or an auto-reload at

alarm.

A software instant reload is triggered by the CPU writing any value to TIMG_TxLOAD_REG causing the timer’s
current value to be instantly reloaded. If TIMG_Tx_EN is set, the timer will continue incrementing/decrementing
from the new value. If TIMG_Tx_EN is cleared, the timer will remain frozen at the new value until counting is

Espressif Systems 279 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

re-enabled.

An auto-reload at alarm will cause a timer reload when an alarm occurs thus allowing the timer to continue
incrementing/decrementing from the reload value. This is generally useful for resetting the timer’s value when
using periodic alarms. To enable auto-reload at alarm, the TIMG_Tx_AUTORELOAD field should be set. If not
enabled, the timer’s value will continue to increment/decrement past the alarm value after an alarm.

12.2.5 Interrupts
Each timer has its own pair of interrupt lines (for edge and level interrupts) that can be routed to the CPU. Thus,
there are a total of six interrupt lines per timer group and they are named as follows:

© TIMG_WDT_LEVEL_INT: Level interrupt line for the watchdog timer in the group, generated when a
watchdog timer interrupt stage times out.

° TIMG_WDT_EDGE_INT: Edge interrupt line for the watchdog timer in the group, generated when a
watchdog timer interrupt stage times out.

TIMG_Tx_LEVEL_INT: Level interrupt for one of the general purpose timers, generated when an alarm event
happens.

TIMG_Tx_EDGE_INT: Edge interrupt for one of the general purpose timer, generated when an alarm event
happens.

Interrupts are triggered after an alarm (or stage timeout for watchdog timers) occurs. Level interrupt lines will be
held high after an alarm (or stage timeout) occurs, and will remain so until manually cleared. Conversely, edge
interrupts will generate a short pulse after an alarm (or stage timeout) occurs. To enable a timer’s level or edge
interrupt lines, the TIMG_Tx_LEVEL_INT_EN or TIMG_Tx_EDGE_INT_EN bits should be set respectively.

The interrupts of each timer group are governed by a set of registers. Each timer within the group will have a
corresponding bit in each of these registers:

° TIMG_Tx_INT_RAW: An alarm event sets it to 1. The bit will remain set until writing to the timer’s
corresponding bit in TIMG_Tx_INT_CLR.

° TIMG_WDT_INT_RAW : A stage time out will set the timer’s bit to 1. The bit will remain set until writing to
the timer’s corresponding bit in TIMG_WDT_INT_CLR.

TIMG_Tx_INT_ST : Reflects the status of each timer’s interrupt and is generated by masking the bits of
TIMG_Tx_INT_RAW with TIMG_Tx_INT_ENA. For level interrupts, these bits reflect the level on the
watchdog timer’s level interrupt line.

* TIMG_WDT_INT_ST : Reflects the status of each watchdog timer’s interrupt and is generated by masking
the bits of TIMG_WDT_INT_RAW with TIMG_WDT_INT_ENA. For level interrupts, these bits reflect the level
on the watchdog timer’s level interrupt line.

TIMG_Tx_INT_ENA : Used to enable or mask the interrupt status bits of timers within the group.

°¢ TIMG_WDT_INT_ENA: Used to enable or mask the interrupt status bits of watchdog timer within the group.

TIMG_Tx_INT_CLR : Used to clear a timer’s interrupt by setting its corresponding bit to 1. The timer’s
corresponding bit in TIMG_Tx_INT_RAW and TIMG_Tx_INT_ST will be cleared as a result. Note that a
timer’s interrupt must be cleared before the next interrupt occurs when using level interrupts.

°¢ TIMG_WDT_INT_CLR: Used to clear a timer’s interrupt by setting its corresponding bit to 1. The watchdog
timer’s corresponding bit in TIMG_WDT_INT_RAW and TIMG_WDT_INT_ST will be cleared as a result.

Espressif Systems 280 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Note that a wachdog timer’s interrupt must be cleared before the next interrupt occurs when using level
interrupts.

12.3. Configuration and Usage
12.3.1. Timer as a Simple Clock

1. Configure the time-base counter
® Select clock source by setting TIMG_Tx_USE_XTAL field.
* Configure the 16-bit prescaler by setting TIMG_T_DIVIDER.
* Configure the timer direction by setting/clearing TIMG_Tx_INCREASE.

® Set the timer’s starting value by writing the starting value to TIMG_Tx_LOAD_LO and
TIMG_Tx_LOAD_HI, then reloading it into the timer by writing any value to TIMG_TxLOAD_REG.

2. Start the timer by setting TIMG_Tx_EN.
3. Getting the timer’s current value.
° Write any value to TIMG_TxUPDATE_REG to latch the timer’s current value.

e Read the latched timer value from TIMG_TxLO_REG and TIMG_TxHI_REG.

12.3.2 Timer as One-shot Alarm
1. Configure the time-base counter following step 1 of Section 12.3.1.

2. Configure the alarm.
* Configure the alarm value by setting TIMG_TxALARMLO_REG and TIMG_TxALARMHI_ REG.

* Enable interrupt by setting TIMG_Tx_LEVEL_INT_EN or TIMG_Tx_EDGE_INT_EN for level or edge
interrupts respectively.

3. Disable auto reload by clearing TIMG_Tx_ AUTORELOAD.
4. Start the timer by setting TIMG_Tx_EN.
5. Handle the alarm interrupt.
* Clear the interrupt by setting the timer’s corresponding bit in TIMG_Tx_INT_CLR.

* Disable the timer by clearing TIMG_T_EN.

Espressif Systems 281 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

12.3.3 Timer as Periodic Alarm
1. Configure the time-base counter following step 1 of Section 12.3.1.

2. Configure the alarm following step 2 of Section 12.3.2.

8. Enable auto reload by setting TIMG_Tx_AUTORELOAD and setting the reload value in TIMG_Tx_LOAD_LO
and TIMG_Tx_LOAD_HI.

4. Start the timer by setting TIMG_Tx_EN.
5. Handle the alarm interrupt (repeat on each alarm iteration).
* Clear the interrupt by setting the timer’s corresponding bit in TIMG_Tx_INT_CLR.

® If the next alarm requires a new alarm value and reload value (i.e. different alarm interval per iteration),
then TIMG_TxALARMLO_REG, TIMG_TxALARMHI_REG, TIMG_Tx_LOAD_LO, and
TIMG_Tx_LOAD_HI should be reconfigured as needed. Otherwise, the aforementioned registers
should remain unchanged.

* Re-enable the alarm by setting TIMG_Tx_ALARM_EN.
6. Stopping the timer (on final alarm iteration).
* Clear the interrupt by setting the timer’s corresponding bit in TIMG_Tx_INT_CLR.

* Disable the timer by clearing TIMG_T_EN.

12.4 Base Address

Users can access the 64-bit Timer with four base addresses, which can be seen in the following table. For more
information about accessing peripherals from different buses please see Chapter 1 System and Memory.

Table 50: 64-bit Timers Base Address

 

 

 

 

 

Name Bus to Access Peripheral Base Address
PeriBUS1 OxSF41FO00
TIMGO -
PeriBUS2 0x6001FO000
PeriBUS1 Ox8F420000
TIMG1 -
PeriBUS2 0x60020000

 

 

 

 

 

12.5 Register Summary
The addresses in the following table are relative to the 64-bit Timer base addresses provided in Section
12.4,

 

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access

Configuration and Control Register for Timer 0

TIMG_TOCONFIG_REG Timer 0 configuration register Ox0000 | RAV

TIMG_TOLO_REG Timer 0 current value, low 32 bits 0x0004 | RO

TIMG_TOHI_REG Timer 0 current value, high 32 bits 0x0008 | RO

TIMG_TOUPDATE_REG Write to copy current timer value to | OxO000C | RAV

TIMG_TOLO_REG and TIMG_TOLO_REG

TIMG_TOALARMLO_REG Timer O alarm value, low 32 bits O0x0010 | RAV

Espressif Systems 282 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
12. 64-bit Timers

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
TIMG_TOALARMHI_REG Timer 0 alarm value, high bits 0x0014 | RAV
TIMG_TOLOADLO_REG Timer 0 reload value, low 32 bits 0x0018 | RAV
TIMG_TOLOADHI_REG Timer 0 reload value, high 32 bits Ox001C | RAV
TIMG_TOLOAD_REG Write to reload timer from | 0x0020 | WO
TIMG_TOLOADLO_REG and
TIMG_TOLOADHI_REG
Configuration and Control Register for Timer 1
TIMG_T1CONFIG_REG Timer 1 configuration register 0x0024 | RAV
TIMG_T1LO_REG Timer 1 current value, low 32 bits 0x0028 | RO
TIMG_T1HI_REG Timer 1 current value, high 32 bits O0x002C | RO
TIMG_T1UPDATE_REG Write to copy current timer value to | Ox0080 | RAV
TIMG_T1LO_REG and TIMG_T1LO_REG
TIMG_T1ALARMLO_REG Timer 1 alarm value, low 32 bits 0x0034 | RAV
TIMG_T1ALARMHI_REG Timer 1 alarm value, high bits 0x0038 | RAV
TIMG_T1LOADLO_REG Timer 1 reload value, low 32 bits Ox0038C_ | RAV
TIMG_T1LOADHI_LREG Timer 1 reload value, high 32 bits 0x0040 | RAV
TIMG_T1LOAD_REG Write to reload timer from | 0x0044 | WO
TIMG_TOLOADLO_REG and
TIMG_TOLOADHI_REG
Configuration and Control Register for WDT
TIMG_WDTCONFIGO_REG Watchdog timer configuration register 0x0048 | RAV
TIMG_WDTCONFIG1_REG Watchdog timer prescaler register Ox004C | RAV
TIMG_WDTCONFIG2_REG Watchdog timer stage 0 timeout value Ox0050 =| RAV
TIMG_WDTCONFIG3_REG Watchdog timer stage 1 timeout value 0x0054 | RAV
TIMG_WDTCONFIG4_REG Watchdog timer stage 2 timeout value O0x0058 | RAV
TIMG_WDTCONFIG5_REG Watchdog timer stage 3 timeout value Ox005C_ | RAV
TIMG_WDTFEED_REG Write to feed the watchdog timer Ox0060 | WO
TIMG_WDTWPROTECT_REG Watchdog write protect register Ox0064 | RAV
Configuration and Control Register for RTC CALI
TIMG_RTCCALICFG2_REG Timer group calibration register OxO0A8 | varies
Interrupt Register
TIMG_INT_ENA_TIMERS_REG Interrupt enable bits 0x0098 | RAV
TIMG_INT_RAW_TIMERS_REG Raw interrupt status Ox009C | RO
TIMG_INT_ST_TIMERS_REG Masked interrupt status OxO0AO0 | RO
TIMG_INT_CLR_TIMERS_REG Interrupt clear bits Ox00A4 | WO
Version Register
TIMG_TIMERS_DATE_REG | Version control register | oxoors | RW
Configuration Register
TIMG_REGCLK_REG | Timer group clock gate register | oxoorc | RW

 

Espressif Systems
S

283

ubmit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
12. 64-bit Timers

 

12.6 Registers

Register 12.1: TIMG_T:CONFIG_REG («: 0-1) (0x0000+36*»)

 

 

 

© SS
ey
Sek g Soe”
EFS sf SIO
SOSGSY “7 SoSoS Ge” oe
NL we NLL &
[ 31 | 2 | 2 [2 w]e] aio] e [e o|
fof+ [a] x01 [ofofofofo 0 9 0 0 0 0 0 O]Reset

 

TIMG_Tx_USE_XTAL 1: Use XTAL_CLK as the source clock of timer group. 0: Use APB_CLK as the
source clock of timer group. (RAM)

TIMG_Tx_ALARM_EN_ When set, the alarm is enabled. This bit is automatically cleared once an alarm
occurs. (R/V)

TIMG_Tx_LEVEL_INT_EN When set, an alarm will generate a level type interrupt. (RAM)
TIMG_Tx_EDGE_INT_EN When set, an alarm will generate an edge type interrupt. (R/V)
TIMG_Tx_DIVIDER_ Timer x clock (Tx_clk) prescaler value. (RAV)
TIMG_Tx_AUTORELOAD When set, timer x auto-reload at alarm is enabled. (RAV)

TIMG_Tx_INCREASE When set, the timer x time-base counter will increment every clock tick. When
cleared, the timer x time-base counter will decrement. (RAM)

TIMG_Tx_EN When set, the timer x time-base counter is enabled. (RAW)

Register 12.2: TIMG_TxLO_REG (x: 0-1) (0x0004+36*\)

No
Sf
oe”
~S

[ “|

| 0x000000 | Reset

 

 

 

TIMG_Tx_LO After writing to TIMG_TxUPDATE_REG, the low 32 bits of the time-base counter of timer
can be read here. (RO)

Espressif Systems 284 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.3: TIMG_THI_REG (:: 0-1) (0x0008+36*»)

N
ae
(ws
ws

31 °

 

 

©x000000 Reset

 

 

 

TIMG_Tx_HI After writing to TIMG_TxUPDATE_REG, the high 32 bits of the time-base counter of timer
can be read here. (RO)

Register 12.4: TIMG_T<UPDATE_REG («: 0-1) (0x000C+36**)

 

[ st [20 o|

 

 

[ojo 0 0 0 0000900000009 90900000000 0 0 0 0 0 OlReset

 

TIMG_Tx_UPDATE After writing 0 or 1 to TIMG_TxUPDATE_REG, the counter value is latched. (RAM)

Register 12.5: TIMG_TxALARMLO_REG («: 0-1) (0x0010+36*.)

 

 

 

a
we
[= |
| 0x000000 | Reset

 

TIMG_Tx_ALARM_LO Timer x alarm trigger time-base counter value, low 32 bits. (R/V)

Register 12.6: TIMG TxALARMHI REG («: 0-1) (0x0014+36*:)
eS
wr

[ “|

| 0x000000 | Reset

 

 

 

TIMG_Tx_ALARM_HI Timer x alarm trigger time-base counter value, high 32 bits. (RAW)

Espressif Systems 285 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.7: TIMG_T<LOADLO_REG (x: 0-1) (0x0018+36*\)

oY
L
Sf
oe”
~S

[ “|

| 0x000000 | Reset

 

 

 

TIMG_Tx_LOAD_LO Low 82 bits of the value that a reload will load onto timer x time-base Counter.
(RAW)

Register 12.8: TIMG_T:LOADHI_REG («: 0-1) (0x001C+36":)

 

31 °

 

 

 

0x000000 Reset

 

TIMG_Tx_LOAD_HI High 32 bits of the value that a reload will load onto timer « time-base counter.
(RAV)

Register 12.9: TIMG_TxLOAD_REG (: 0-1) (0x0020+36*.)

Y
AVY
(ws
ws

[ 7]

| 0x000000 | Reset

 

 

 

TIMG_Tx_LOAD Write any value to trigger a timer « time-base counter reload. (WO)

Espressif Systems 286 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.10: TIMG_WDTCONFIGO_REG (0x0048)

 

 

 

Ad >
Rc S nF
SS A> Y SS
A86% &? SxS
LP OS FF Sev’
S GCG & 2 b& os CP
Ss LX OK KE SS & OKs
a? a2 a2 a2 Kg}? AYAY a7 a? ALR?
wW © wW © © wW © wW © WKY) &
© oS oS Or oS © Or
PS MOSM &
[ a1 [x 29 | 28 a7 | 26 2s | a4 3] x [21 [20 ts|7 5] «| 13 [2 o|
fof o [| o [| 9 [| 0 [ofo] oxt | Oxt [ifofo 0 9 0 9 9 0 0 0 0 0 0 O]Reset

 

TIMG_WDT_PROCPU_RESET_EN WOT reset CPU enable. (R/V)
TIMG_WDT_FLASHBOOT_MOD_EN When set, Flash boot protection is enabled. (RAV)

TIMG_WDT_SYS RESET LENGTH System reset signal length selection. 0: 100 ns, 1: 200 ns, 2:
800 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us. (RAW)

TIMG_WDT_CPU_RESET_ LENGTH CPU reset signal length selection. 0: 100 ns, 1: 200 ns, 2: 800
ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us. (RAV)

TIMG_WDT_LEVEL_INT_EN When set, a level type interrupt will occur at the timeout of a stage
configured to generate an interrupt. (RAV)

TIMG_WDT_EDGE_INT_EN When set, an edge type interrupt will occur at the timeout of a stage
configured to generate an interrupt. (RAV)

TIMG_WDT_STG3_ Stage 3 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system. (RAV)
TIMG_WDT_STG2 Stage 2 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system. (RAV)
TIMG_WDT_STG1 Stage 1 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system. (RAV)
TIMG_WDT_STGO Stage 0 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system. (RAV)

TIMG_WDT_EN When set, MWDT is enabled. (R/W)

Register 12.11: TIMG_WDTCONFIG1_REG (0x004C)

 

 

 

SF
oe)
&
*
& >
7 s
x Ce
[a1 16 [is o|
Ox01 [o 0000000000000 0 O]Reset

 

TIMG_WDT_CLK_PRESCALER MWDT clock prescaler value. MWDT clock period = 12.5 ns *
TIMG_WDT_CLK_PRESCALE. (RAW)

Espressif Systems 287 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.12: TIMG_WDTCONFIG2_REG (0x0050)

 

 

 

&
Iw
©
s
ws
[a |
| Ox18cbas0 |Reset

 

TIMG_WDT_STGO HOLD Stage 0 timeout value, in MWDT clock cycles. (R/W)

Register 12.13: TIMG_WDTCONFIG3_REG (0x0054)

2

Ww

Ss
KO
SY

Ge Lf

ws

[a |

| Ox Ffffff | Reset

 

 

 

TIMG_WDT_STG1_HOLD Stage 1 timeout value, in MWDT clock cycles. (R/W)

Register 12.14: TIMG_WDTCONFIG4_REG (0x0058)

S
ov
&
wr

 

 

| OxOfffff | Reset

 

TIMG_WDT_STG2_HOLD Stage 2 timeout value, in MWDT clock cycles. (R/W)

Espressif Systems 288 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.15: TIMG_WDTCONFIG5_REG (0x005C)

S
Or
&

we
[2 “|

| OxOfffff | Reset

 

 

 

TIMG_WDT_STG3_HOLD Stage 3 timeout value, in MWDT clock cycles. (R/W)

Register 12.16: TIMG_WDTFEED_REG (0x0060)

&
&

Oz
ws

[ 7]

| 0x000000 | Reset

 

 

 

TIMG_WDT_FEED Write any value to feed the MWDT. (WO) (WO)

Register 12.17: TIMG_WDTWPROTECT_REG (0x0064)

g
ee

we
[a |

| Ox50d83aa1 | Reset

 

 

 

TIMG_WDT_WKEY If the register contains a different value than its reset value, write protection is
enabled. (R/W)

Espressif Systems 289 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.18: TIMG_RTCCALICFG2_REG (0x00A8)

 

 

 

 

 

 

 

 

&}
SS
S 9
& go
a <=
ov ov s
e e e
~ < <
aa ~~ aa
oO” Or oO”
of of & x
we ww ES we
| 31 7 | 6 3 | 2 1 | o |
| Ox fffff | 0x3 [o o| 0 |Reset
TIMG_RTC_CALI_ TIMEOUT RTC calibration timeout indicator (RO)
TIMG_RTC_CALITIMEOUT_RST_CNT Cycles that release calibration timeout reset (RAV)
TIMG_RTC_CALI TIMEOUT_THRES Threshold value for the RTC calibration timer. If the calibration
timer’s value exceeds this threshold, a timeout is triggered. (RAV)
Register 12.19: TIMG_INT_ENA_TIMERS_REG (0x0098)
ww
See
SKK?
. SZSS
eo Soo
E We
[a1 3| 2 | 1 | 0 |
jo0 0000000000000 0000 000000 0 0 0 0[0]0] 9 Reset
TIMG_Tx_INT_ENA The interrupt enable bit for the TIMG_Tx_INT interrupt. (RAW)
TIMG_WDT_INT_ENA The interrupt enable bit for the TIMG_WDT_INT interrupt. (RAV)
Register 12.20: TIMG_INT_RAW_TIMERS_REG (0x009C)
Ss
See
& See
& NS

 

[ ELE]

jo9 0000000000000 00 0000090 090 00 0 0[0]0] 0 IReset

 

 

TIMG_Tx_INT_RAW The raw interrupt status bit for the TIMG_Tx_INT interrupt. (RO)

TIMG_WDT_INT_RAW The raw interrupt status bit for the TIMG_WDT_INT interrupt. (RO)

Espressif Systems 290 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.21: TIMG_INT_ST_TIMERS_REG (0x00A0)

0% Or”
F WQS

[ EEL]

joo 0 0 0000000000090 0000090 00 0 0 0 ofo[o][o IReset

 

 

 

TIMG_Tx_INT_ST The masked interrupt status bit for the TIMG_T_INT interrupt. (RO)

TIMG_WDT_INT_ST The masked interrupt status bit for the TIMG_WDT_INT interrupt. (RO)

Register 12.22: TIMG_INT_CLR_TIMERS_REG (0x00A4)

Vv
Poe
WKIK
5. SSeS
& Soe
@
& ws wY we

 

[ EEL]

joo 0 0 0000000000090 0000090 00 0 0 0 ofo[o][o IReset

 

 

TIMG_Tx_INT_CLR_ Set this bit to clear the TIMG_T_INT interrupt. (WO)

TIMG_WDT_INT_CLR Set this bit to clear the TIMG_WDT_INT interrupt. (WO)

Register 12.23: TIMG_TIMERS_DATE_REG (0x00F8)

 

 

 

 

s
ee
& x
& w
| 31 28 | 7 oO |
[0 0 0 o 0x1 907261 |Reset
TIMG_TIMERS DATE Version control register. (RAV)
Espressif Systems 291 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
12. 64-bit Timers

 

Register 12.24: TIMG_REGCLK_REG (0x00FC)

 

 

 

 

 

0j/O0 0 0 00 0 00 00 0 00 00 00 0 00 00 00 0 0 0 0 0 0 OfReset

 

TIMG_CLK_EN Register clock gate signal. 1: Registers can be read and written to by software. 0:
Registers can not be read or written to by software. (RAV)

Espressif Systems 292 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
13. Watchdog Timers

 

13. Watchdog Timers

13.1 Overview

Watchdog timers are hardware timers used to detect and recover from malfunctions. They must be periocically
fed (reset) to prevent a timeout. A system/software that is behaving unexpectedly (e.g. is stuck in a software loop
or in overdue events) will fail to feed the watchdog thus trigger a watchdog time out. Therefore, watchdog timers
are useful for detecting and handling erroneous systen7/software behavior.

The ESP82-S2 contains three watchdog timers: one in each of the two timer groups (called Main System
Watchdog Timers, or MWDT) and one in the RTC Module (called the RTC Watchdog Timer, or RWDT). Each
watchdog timer allows for four separately configurable stages and each stage can be programmed to take one of
three (or four for RWDT) actions upon expiry, unless the watchdog is fed or disabled. The actions upon expiry
are: interrupt, CPU reset, core reset and system reset. Only RWDT can trigger a system reset that will reset the
entire digital circuits, which is the main system including the RTC itself. A timeout value can be set for each stage
individually.

During the flash boot process, RWDT and the first MWDT are enabled automatically in order to detect and
recover from booting errors.

Note that while this chapter provides the functional descriptions of the watchdog timer’s, their register
descriptions are provided in Chapter 12: 64-bit Timers.

13.2 Features
Watchdog timers have the following features:

* Four stages, each with a programmable timeout value. Each stage can be configured and
enabled/cisabled separately

One of three/four (for MWDTs/ RWDT) possible actions (interrupt, CPU reset, core reset and system reset)
available upon expiry of each stage

82-bit expiry counter

Write protection, to prevent RWDT and MWDT configuration from being altered inadvertently

Flash boot protection
lf the boot process from an SPI flash does not complete within a predetermined period of time, the
watchdog will reboot the entire main system.

13.3. Functional Description

13.3.1 Clock Source and 32-Bit Counter

At the core of each watchdog timer is a 32-bit counter. The clock source of MWDTs is derived from the APB
clock via a pre-MWDT 16-bit configurable prescaler. Conversely, the clock source of RWDT is derived directly
from a RTC slow clock (without a prescaler) which is usually running at 82 kHz. The 16-bit prescaler for MWDTs
is configured via the TIMG_WDT_CLK_PRESCALER field of TIMG_WDTCONFIG1_REG.

MWDTs and RWDT are enabled by setting the TIMG_WDT_EN and RTC_CNTL_WDT_EN fields respectively.
When enabled, the 32-bit counters of each watchdog will increment on each source clock cycle until the timeout
value of the current stage is reached (i.e. expiry of the current stage). When this occurs, the current counter value

Espressif Systems 293 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
13. Watchdog Timers

 

is reset to zero and the next stage will become active. If a watchdog timer is fed by software, the timer will return
to stage O and reset its counter value to zero. Software can feed a watchdog timer by writing any value to
TIMG_WDTFEED_REG for MDWTs and RTC_CNTL_RTC_WDT_FEED for RWDT.

13.3.2 Stages and Timeout Actions

Timer stages allow for a timer to have a series of different timeout values and corresponding expiry action. When
one stage expires, the expiry action is triggered, the counter value is reset to zero, and the next stage becomes
active. MWDTs/ RWDT provide four stages (called stages O to 3). The watchdog timers will progress through
each stage in a loop (i.e. from stage O to 3, then back to stage 0).

Timeout values of each stage for MWDTs are configured in TIMG_WDTCONFIG/_REG (where / ranges from 2 to
5), whilst timeout values for RWDT are configured in RTC_CNTL_WDT_STG/_HOLD_REG registers (where /
ranges from 0 to 3).

Please note that the timeout value of stage 0 for RWDT (Tholag) is determined together by
EFUSE_WDT_DELAY_SEL field of an eFuse register and RTC_CTRL_WDT_STGO_HOLD_REG. The relationship
is as follows:

Thowo = RTC_CTRL_WDT_STGO_HOLD_REG « EFUSE_WDT_DELAY_SEL + 1
Upon the expiry of each stage, one of the following expiry actions will be executed:

® Trigger an interrupt
When the stage expires, an interrupt is triggered.

Reset a CPU core
When the stage expires, the CPU core will be reset.

Reset the main system
When the stage expires, the main system (which includes MWDTs, CPU, and all peripherals) will be reset.
The RTC will not be reset.

Reset the main system and RTC
When the stage expires the main system and the RTC will both be reset. This action is only available in
RWDT.

Disabled
This stage will have no effects on the system.

For MWDTs, the expiry action of all stages is configured in TIMG_WDTCONFIGO_REG. Likewise for RWDT, the
expiry action is configured in RTC_WDTCONFIGO.

13.3.3 Write Protection

Watchdog timers are critical to detecting and handling erroneous system/software behavior, thus should not be
disabled easily (e.g. due to a misplaced register write). Therefore, MWDTs and RWDT incorporate a write
protection mechanism that prevent the watchdogs from being disabled or tampered with due to an accidental
write. The write protection mechanism is implemented using a write-key register for each timer
(TIMG_WDT_WKEY for MWDT, RTC_CNTL_WDT_WKEY for RWDT). The value Ox60D83AA1 must be written to
the watchdog timer’s write-key register before any other register of the same watchdog timer can be changed.
Any attempts to write to a watchdog timer’s registers (other than the write-key register itself} whilst the write-key
register’s value is not Ox5O0D83AA1 will be ignored. The recommended procedure for accessing a watchdog
timer is as follows:

Espressif Systems 294 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
13. Watchdog Timers

 

1. Disable the write protection by writing the value Ox50D83AA1 to the timer’s write-key register.
2. Make the required modification of the watchdog such as feeding or changing its configuration.

3. Re-enable write protection by writing any value other than Ox50D83AA1 to the timer’s write-key register.

13.3.4 Flash Boot Protection

During flash booting process, MWDT in timer group O (TIMGO), as well as RWDT, are automatically enabled.
Stage 0 for the enabled MWDT is automatically configured to reset the system upon expiry. Likewise, stage O for
RWDT is configured to reset the main system and RTC when it expires. After booting,
TIMG_WDT_FLASHBOOT_MOD_EN and RTC_CNTL_WDT_FLASHBOOT_MOD_EN should be cleared to stop
the flash boot protection procedure for both MWDT and RWDT respectively. After this, MWDT and RWDT can be
configured by software.

13.4 Registers
MWDT registers are part of the timer submodule and are described in the Chapter 12: 64-bit Timers Timer
Registers section.

Espressif Systems 295 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
14. XTAL32K Watchdog

 

14. XTALS2K Watchdog

14.1 Overview

XTAL32K Watchdog on ESP32-S2 is used to monitor the status of external crystal XTALS2K_CLK. This
Watchdog can detect the oscillation failure of XTAL82K_CLK, change the clock source of RTC, etc. When
XTAL32K_CLK works as the clock source of RTC SLOW_CLK and stops vibrating, XTAL82K Watchdog first
switches to BACKUP32K_CLK derived from RTC_CLK and generates an interrupt (If the chip is in deep sleep
mode, the CPU will be woken up), and then switches back to XTAL32K_CLK after it is restarted by

software.

 

 

 

 

XTAL32K
{>
Watchdog Interrupt
RTC_CNTL_XTAL32K_WDT_EN
Monitor

 

 

BACKUP32K_CLK_EN
&
XTAL32K_CLK 4

RTC_CLK . BACKUP32K_CLK
——* Divisor —HHWH— > 1

 

 

 

 

 

 

 

RTC_SLOW_CLK

 

 

 

 

 

 

 

 

Figure 14-1. XTAL32K Watchdog

14.2 Features

14.2.1. XTAL382K Watchdog Interrupts and Wake-up
When XTAL32K Watchdog detects the oscillation failure of XTALG2K_CLK, an oscillation failure interrupt is
generated. At this point the CPU will be woken up if in hibernation.

14.2.2 BACKUP32K_CLK

Once XTAL32K Watchdog detects the oscillation failure of XTALG2K_CLK, it replaces XTAL32K_CLK with
BACKUP32K_CLK (with a frequency of 32 kHz) derived from RTC_CLK as RTC’s SLOW_CLK, so as to ensure
proper functioning of the system.

14.3 Functional Description

14.3.1 Workflow
1. XTALS2K Watchdog starts counting when RTC_CNTL_XTAL_32K_WDT_EN is enabled. The counter keeps
counting until it detects the positive edge of XTAL_32K and is then cleared. When the counter reaches
RTC_CNTL_XTAL382K_WDT_TIMEOUT, it generates an interrupt or a wake-up signal and is then reset.

Espressif Systems 296 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
14. XTAL32K Watchdog

 

2. XTALG2K Watchdog automatically enables BACKUP32K_CLK as the alternative clock source of RTC
SLOW_CLK, to ensure the system’s proper functioning and the accuracy of timers running on RTC
SLOW_CLK (e.g. RTC_TIMER). For information about clock frequency configuration, please refer to
Section 14.3.2 Configuring the Divisor of BACKUP32K_CLK.

3. To restore XTAL32K Watchdog, software restarts XTAL32K_CLK by turning its XPD signal on and off via
RTC_CNTL_XPD_XTAL_32K bit. Then, XTAL82K Watchdog switches back to XTAL32K_CLK by setting
RTC_CNTL_XTAL382K_WDT_EN bit to 0. If the chip is in deep sleep mode, XTAL32K Watchdog will wake
up the CPU to finish the above steps.

14.3.2 Configuring the Divisor of BACKUP32K_CLK

Chips have different RTC_CLK frequencies due to production process variations. To ensure the accuracy of
RTC_TIMER and other timers running on SLOW_CLK when BACKUP32K_CLK is at work, the divisor of
BACKUP32K_CLK should be configured according to the actual frequency of RTC_CLK.

Define the frequency of RTC_CLK as f_rtc_clk (unit: kHz), and the eight divisor components as

Xo, %1,%2,%3, 04,05, TG, aNd x7, respectively. S = xp +21 +a2+a43+ 24+ 25 +26 +27,

The following conditions should be fulfilled:

S = f_rte_clk x (4/32)
M+1>a,>M(0<n<7)
M = f_rte_elk/32/2

Ly, Should be an interger. Mf and S are rounded up or down. Each divisor component (a9 ~27) is 4-bit long, and
corresponds to the value of RTC_CNTL_XTAL82K_CLK_FACTOR (G2-bit) in order.

For example, if the frequency of RTC_CLK is 163 kHz, then f_rtc_clk = 163, S = 20, M = 2, and
{Xo, 21, %2, 23, C4, U5, Ug, U7} = {2,3, 2,3, 2,3, 2,3}. As a result, the frequency of BACKUP32K_CLK is 32.6 kHz.

Espressif Systems 297 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

 

15. System Timer

15.1. Overview

System timer is a 64-bit timer specially for operating system. It can be used to schedule operating system tasks
by generating periodical system ticks or certain time delay interrupts. With the help of RTC timer, system timer
can keep updated after Light-sleep or Deep-sleep.

15.2 Main Features
° A 64-bit timer

* Clocked with APB_CLK
* Timer value increment step can be configured for each APB_CLK cycle.

* Support automatic time compensation in case of APB_CLK clock source switching between PLL_CLK and
XTAL_CLK, to improve timer accuracy.

* Generate three independent interrupts based on different alarm values or periods (targets).
* Support for 64-bit alarm values and 30-bit periods.
* Load back sleep time recorded by RTC timer after Deep-sleep or Light-sleep by software.

* Keep stalled if CPU is stalled or CPU is in on-chip-debugging mode.

15.3 Clock Source Selection

The System Timer is driven using XTAL_CLK or PLL_CLK clock. Selection between the two clock sources is
described in Table CPU_CLK Source in Chapter 2 Reset and Clock. For the specific clock frequency used for the
System Timer, please refer to Table 11 APB_CLK Source. On each clock period the timer will be increased by a
step value configured in either SYSTIMER_TIMER_XTAL_STEP or SYSTIMER_TIMER_PLL_STEP, depending on
which clock source is used.

15.4 Functional Description

 

 

 

   
 

PLL XTAL
SYSTIMER_TARGETx_WORK_EN
SYSTIMER_TARGETx_PERIOD_MODE
APB_CLK SYSTIMER_TARGETx_PERIOD
SYSTIMER_TIMER_TARGETx_LO
SYSTEM_SYSTIMER_CLK_EN CG SYSTIMER_TIMER_TARGETx_HI
SYSTIMER_TIMER_PLL_STEP Timer Timer CPU
Timer value Timer Interrupt Interrupt
[+m oe
SYSTIMER_TIMER_XTAL_STEP Counter Comparator "
p Matrix

 

 

 

 

 

 

 

 

 

Figure 15-1. System Timer Structure

Figure 15-1 shows the structure of system timer. The system timer can be enabled by setting the bit
SYSTEM_SYSTIMER_CLK_EN in register SYSTEM_PERIP_CLK_ENO_REG and be reset via software by setting

Espressif Systems 298 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

 

the bit SYSTEM_SYSTIMER_RST in register SYSTEM_PERIP_RST_ENO_REG. For more information, please refer
to Table 83 Peripheral Clock Gating and Reset Bits in Chapter 6 System Registers.

15.4.1. Read System Timer Value

1.

2.

Set SYSTIMER_TIMER_UPDATE to update the timer value into registers.

Wait till SYSTIMER_TIMER_VALUE_VALID is set, which means users now can read the timer values from
registers.

. Read the high 32 bits of the timer value from SYSTIMER_TIMER_VALUE_HI, and the low 32 bits from

SYSTIMER_TIMER_VALUE_LO.

15.4.2 Configure a Time-Delay Alarm

1.

Read the current value of system timer, see Section 15.4.1. This value will be used to calculate the target in
Step 3.

. Clear SYSTIMER_TARGETx_PERIOD_MODE to set the timer into a time-delay alarm mode.

. Write the high 82 bits of the target (alarm value) to SYSTIMER_TIMER_TARGETx_HI, and the low 82 bits to

SYSTIMER_TIMER_TARGETx_LO.

. Set SYSTIMER_TARGETx_WORK_EN to enable the selected work mode.

. Set SYSTIMER_INTx_ENA to enable timer interrupt. When the timer counts to the alarm value, an interrupt

will be triggered.

15.4.3 Configure Periodic Alarms

1.
2.
3.
4,

Set SYSTIMER_TARGET_PERIOD_MODE to configure the timer into periodic alarms mode.
Write the target (alarm period) to SYSTIMER_TARGET_PERIOD.
Set SYSTIMER_TARGET_WORK_EN to enable periodical alarms mode.

Set SYSTIMER_INT_ENA to enable timer interrupt. An interrupt will be triggered when the timer counts to
the target value set in Step 2.

15.4.4 Update after Deep-sleep and Light-sleep

1.
2.

3.

Configure RTC timer before the chip goes to Deep-sleep or Light-sleep, to record the exact sleep time.
Read the sleep time from RTC timer when the chip is woken up from Deep-sleep or Light-sleep.

Read current value of the system timer. See Section 15.4.1 for how to read the timer value.

. Add current value of the system timer to the time that RTC timer records in Deep-sleep mode or in

Light-sleep mode.

. Write the result into SYSTIMER_TIMER_LOAD_ HI (high 32 bits), and into SYSTIMER_TIMER_LOAD_LO

(low 82 bits).

. Set SYSTIMER_TIMER_LOAD to load the new value stored in SYSTIMER_TIMER_LOAD_HI and

SYSTIMER_TIMER_LOAD_LO into the system timer. By such way, the system timer is updated.

Espressif Systems 299 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
15. System Timer

 

15.5 Base Address

Users can access system timer registers with two base addresses, which can be seen in the following table. For
more information about accessing peripherals from different buses please see Chapter 1 System and
Memory.

Table 52: System Timer Base Address

 

 

 

Bus to Access Peripheral | Base Address
PeriBUS1 Ox8F423000
PeriBUS2 0x60023000

 

 

 

 

15.6 Register Summary

The addresses in the following table are relative to system timer base addresses provided in Section 15.5.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access
System Timer Registers
SYSTIMER_CONF_REG Configure system timer clock Ox0000 | RAV
SYSTIMER_LOAD_REG Load value to system timer 0x0004 | WO
SYSTIMER_LOAD_HI_REG High 32 bits to be loaded to system timer Ox0008 | RAV
SYSTIMER_LOAD_LO_REG Low 32 bits to be loaded to system timer Ox000C | RAV
SYSTIMER_STEP_REG System timer accumulation step O0x0010 | RAV
SYSTIMER_TARGETO_HI_REG System timer target 0, high 32 bits 0x0014 | RAV
SYSTIMER_TARGETO_LO_REG System timer target 0, low 32 bits 0x0018 | RAV
SYSTIMER_TARGET1_HI_REG System timer target 1, high 32 bits Ox001C | RAV
SYSTIMER_TARGET1_LO_REG System timer target 1, low 32 bits 0x0020 | RAV
SYSTIMER_TARGET2_HI_REG System timer target 2, high 32 bits 0x0024 | RAV
SYSTIMER_TARGET2_LO_ REG System timer target 2, low 32 bits 0x0028 | RAV
SYSTIMER_TARGETO_CONF_REG Configure work mode for system timer targetO | Ox002C | RAV
SYSTIMER_TARGET1_CONF_REG Configure work mode for system timer target 1 Ox0030 | RAV
SYSTIMER_TARGET2_CONF_REG Configure work mode for system timer target 2. | Ox0034 | RAV
SYSTIMER_UPDATE_REG Read out system timer value 0x0038 | varies
SYSTIMER_VALUE_HI_REG System timer value, high 32 bits Ox0038C | RO
SYSTIMER_VALUE_LO_REG System timer value, low 32 bits 0x0040 | RO
SYSTIMER_INT_ENA_REG System timer interrupt enable 0x0044 | RAV
SYSTIMER_INT_RAW_REG System timer interrupt raw 0x0048 | RO
SYSTIMER_INT_CLR_REG System timer interrupt clear O0x004C | WO
Version Register
SYSTIMER_DATE_REG Version control register OxOOFC | RAV
Espressif Systems 3800 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
15. System Timer

 

15.7 Registers

Register 15.1: SYSTIMER_CONF_REG (0x0000)

 

 

 

 

SYSTIMER_CLK_FO System timer clock force enable. (RAV)

SYSTIMER_CLK_EN Register clock enable. (RAV)

Register 15.2: SYSTIMER_LOAD_REG (0x0004)

&

ee

 

[ a1 [x o|

 

 

[oJo 0 0000000000000 00000 000090 00 09 0 0 0 OfReset

 

SYSTIMER_TIMER_LOAD Set this bit to 1, the value stored in SYSTIMER_TIMER_LOAD_HI and in
SYSTIMER_TIMER_LOAD_LO will be loaded to system timer. (WO)

Register 15.3: SYSTIMER_LOAD_HI_REG (0x0008)

eS
Oo f
Ss
Qa’

we

Qy
ew
S

 

 

| 0 | Reset

 

SYSTIMER_TIMER_LOAD HI The value to be loaded into system timer, high 32 bits. (R/V)

Espressif Systems 301 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

 

Register 15.4: SYSTIMER_LOAD_LO_REG (0x000C)

 

[ |

| 0 | Reset

 

 

SYSTIMER_TIMER_LOAD LO The value to be loaded into system timer, low 32 bits. (R/V)

Register 15.5: SYSTIMER_STEP_REG (0x0010)

 

 

 

Q
8 x
S V7
y *
QI 7
ww w
Sd Sv ev
fo Ss Ss
RG S S
[1 219 1o[» o|
joo 0 0 000000 0 9 1 | 80 |Reset

 

SYSTIMER_TIMER_XTAL_STEP Set system timer increment step when using XTAL_CLK. (RW)

SYSTIMER_TIMER _PLL_STEP Set system timer increment step when using PLL_CLK. (RW)

Register 15.6: SYSTIMER_TARGETO_HI_REG (0x0014)

 

 

 

Se
&
go
xX
Qy
we
se
[zn 7
| 0 |Reset

 

SYSTIMER_TIMER_TARGETO_HI System timer target 0, high 32 bits. (RAV)

Espressif Systems 802 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

 

Register 15.7: SYSTIMER_TARGETO_LO_REG (0x0018)

 

 

| 0 | Reset

 

SYSTIMER_TIMER_TARGETO_LO System timer target 0, low 32 bits. (RAV)

Register 15.8: SYSTIMER_TARGET1_HI_REG (0x001C)

 

 

 

x
ge
Oo
&
xX
Qr
w
Ss

[a ‘|
| 0 | Reset

 

SYSTIMER_TIMER_TARGET1_HI System timer target 1, high 32 bits. (RAV)

Register 15.9: SYSTIMER_TARGET1_LO_REG (0x0020)

 

 

 

se
Oo
as
Qr
ew
Qr
w
Ss

[a ]
| 0 | Reset

 

SYSTIMER_TIMER_TARGET1_LO System timer target 1, low 32 bits. (RAV)

Espressif Systems 803 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

 

Register 15.10: SYSTIMER_TARGET2_HI_REG (0x0024)

 

 

 

N
ge
&
go
we
Qy
ew
Ss
[a ‘|
| 0 | Reset

 

SYSTIMER_TIMER_TARGET2_HI System timer target 2, high 32 bits. (RAV)

Register 15.11: SYSTIMER_TARGET2_LO_REG (0x0028)

 

 

| 0 | Reset

 

SYSTIMER_TIMER_TARGET2_LO System timer target 2, low 32 bits. (RAV)

Register 15.12: SYSTIMER_TARGETO_CONF_REG (0x002C)

 

 

xy
§
a?” S
CS S
O97 O7
SS é
oy ae a
as s
os S
31 30 | 29 oO
alo 0x000000 Reset

 

 

 

 

 

SYSTIMER_TARGETO PERIOD Set alarm period for system timer target 0, only valid in periodic
alarms mode. (R/WV)

SYSTIMER_TARGETO_ PERIOD MODE Set work mode for system timer target O. O: work in a time-
delay alarm mode; 1: work in periodic alarms mode. (R/W)

SYSTIMER_TARGETO_ WORK_EN System timer target O work enable. (RAW)

Espressif Systems 3804 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

 

Register 15.13: SYSTIMER_TARGET1_CONF_REG (0x0030)

 

 

x
Q
7 S
SE S
NZKNZ NZ
EE &
Ee &
oe A Pe
as x
OS S
31 30 | 29 oO
alo ©x000000 Reset

 

 

 

 

 

SYSTIMER_TARGET1_ PERIOD Set alarm period for system timer target 1, only valid in periodic
alarms mode. (R/WV)

SYSTIMER_TARGET1_PERIOD_MODE Set work mode for system timer target 1. O: work in a time-
delay alarm mode; 1: work in periodic alarms mode. (R/W)

SYSTIMER_TARGET1_WORK_EN System timer target 1 work enable. (RAW)

Register 15.14: SYSTIMER_TARGET2_CONF_REG (0x0034)

 

 

 

X,
Q
Se oo ©
© O
SE é
og V7 ae
OOO oO
CaS as
OC" ey
WS ~~
O_O SO
CN S
| 31 | 30 [= o|
| 0 | 0 | 0x000000 |Reset

 

SYSTIMER_TARGET2 PERIOD Set alarm period for sytem timer target 2, only valid in periodic
alarms mode. (R/WV)

SYSTIMER_TARGET2 PERIOD MODE Set work mode for system timer target 2. O: work in a time-
delay alarm mode; 1: work in periodic alarms mode. (R/W)

SYSTIMER_TARGET2 WORK_EN System timer target 2 work enable. (RAV)

Espressif Systems 305 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

 

Register 15.15: SYSTIMER_UPDATE_REG (0x0038)

x »
eye
Se
ie &
eS &

 

[ a1 | » [2 o|

 

 

fofoJo o 0 0000000000000 000 0000 00 09 0 0 0 OfReset

 

SYSTIMER_TIMER VALUE VALID Check if it is valid to read out timer value from registers. 0: Not
ready to read timer value from registers; 1: Ready to read timer value from registers. (RO)

SYSTIMER_TIMER_UPDATE Update system timer value to registers. (WO)

Register 15.16: SYSTIMER_VALUE_HI_REG (0x003C)

 

[ “|

| 0 | Reset

 

 

SYSTIMER_TIMER VALUE _HI System timer value, high 32 bits. (RO)

Register 15.17: SYSTIMER_VALUE_LO_REG (0x0040)

 

 

| 0 | Reset

 

SYSTIMER_TIMER VALUE _LO System timer value, low 32 bits. (RO)

Espressif Systems 306 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
15. System Timer

Register 15.18: SYSTIMER_INT_ENA_REG (0x0044)

MP
SSF
soe
Sy
2 ES
D IO IO IO

 

31 3] 2

 

 

 

 

 

 

0 0 00 0 00 0 00 0 00 00 00 00 0 00 00 0 0 0 0 0] 0]0] O Reset

 

SYSTIMER_INTO_ENA Interrupt enable bit of system timer target 0. (R/W)
SYSTIMER_INT1_ENA Interrupt enable bit of system timer target 1. (RW)

SYSTIMER_INT2_ENA Interrupt enable bit of system timer target 2. (R/W)

Register 15.19: SYSTIMER_INT_RAW_REG (0x0048)

sate
VAN ZADZ
sass
.,
se aes’
& es

 

31 3] 2

 

 

 

 

 

 

0 0 00 0 00 000 0 00 00 00 00 0 00 00 0 0 0 0 0] 0]0] O Reset

 

SYSTIMER_INTO_RAW Interrupt raw bit of system timer target 0. (RO)
SYSTIMER_INT1_RAW_ Interrupt raw bit of system timer target 1. (RO)

SYSTIMER_INT2_RAW Interrupt raw bit of system timer target 2. (RO)

Register 15.20: SYSTIMER_INT_CLR_REG (0x004C)

 

 

 

 

eoror
VAN 7
Se
\ F F SL
‘ S VEE
é Pee
[1 3| 2 | 1 | 0 |
jo 0 0 0 0000000000000 000000 00 00 0 0[0]0] 0 Reset
SYSTIMER_INTO CLR Interrupt clear bit of system timer target 0. (WO)
SYSTIMER_INT1_CLR_ Interrupt clear bit of system timer target 1. (WO)
SYSTIMER_INT2_CLR_ Interrupt clear bit of system timer target 2. (WO)
Espressif Systems 807 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
15. System Timer

 

Register 15.21: SYSTIMER_DATE_REG (Ox00FC)

 

 

 

 

x
Sy
x
Ss
[1 o|
| 0x1 807160 |Reset
SYSTIMER_DATE Version control register. (RAV)
Espressif Systems 808 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

16. eFuse Controller

16.1 Overview

ESP32-S2 has a 4096-bit eFuse that stores parameters in the SoC. Once an eFuse bit is programmed to 1, it
can never be reverted to 0. Software can instruct the eFuse Controller to program individual bits for individual
parameters as needed. Some of these parameters can be read by software using the eFuse Controller registers,
while some can be directly used by hardware modules.

16.2 Features

* One-time programmable storage
* Configurable write protection
* Configurable software read protection

* Parameters use different hardware encoding schemes to protect against corruption

16.3. Functional Description

16.3.1 Structure
There are 11 eFuse blocks (BLOCKO ~ BLOCK10).

BLOCKO holds most core system parameters. Among these parameters, 24 bits are invisible to software and
can only be used by hardware and 88 bits are reserved for future use.

Table 54 lists all the parameters in BLOCKO and their offsets, bit widths, functional description, as well as
information on whether they can be used by hardware, and whether they are protected from programming.

The EFUSE_WR_DIS parameter is used to restrict the programming of other parameters, while EFUSE_RD_DIS
is used to restrict software from reading BLOCK4 ~ BLOCK10. More information on these two parameters can
be found in sections 16.3.1.1 and 16.3.1.2.

Table 54: Parameters in BLOCKO

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

. Programming-Protection
Bit Hardware .
Parameters Offset ; by EFUSE_WR_DIS Description
Width Use .
Bit Number

Disables programming of indi-
EFUSE_WR_DIS 0 32 Y N/A /

vidual eFuses

Disables software __ reading
EFUSE_RD_DIS 82 7 Y 0 from individual eFuse blocks

BLOCK4-10
EFUSE_DIS_RTC_RAM_BOOT 39 1 N 1 Disables boot from RTC RAM
EFUSE_DIS_ICACHE 40 1 Y Disables Cache
EFUSE_DIS_DCACHE 4 1 Y 2 Disables DCache
EFUSE_DIS_DOWNLOAD_ 40 1 y 9 Disables Icache when SoC is in
ICACHE Download mode
EFUSE_DIS_DOWNLOAD_ 43 1 y 9 Disables Dcache when SoC is
DCACHE in Download mode

Espressif Systems 809 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

. Programming-Protection
Bit Hardware _—
Parameters Offset ; by EFUSE_WR_DIS Description
Width Use ,
Bit Number

Disables forcing chip into
EFUSE_DIS_FORCE_DOWNLOAD | 44 1 Y 2

Download mode

Disables the USB OTG hara-
EFUSE_DIS_USB 45 1 Y 2

ware

Disables the TWAI Controller
EFUSE_DIS_CAN 46 1 Y 2

hardware

Disables capability to Remap
EFUSE_DIS_BOOT_REMAP 47 1 Y 2

RAM to ROM address space

Software cisables JTAG. When

software disabled, JTAG can be
EFUSE_SOFT_DIS_JTAG 49 1 Y 2 ; j

activated temporarily by HMAC

peripheral.

Hardware disables JTAG per-
EFUSE_HARD_DIS_JTAG 50 1 Y 2

manently.
EFUSE_DIS_ DOWNLOAD_ 54 1 Y 9 Disables flash encryption when
MANUAL ENCRYPT in download boot modes

Exchanges USB D+ and D-
EFUSE_USB_EXCHG_PINS 56 1 Y 30 ;

pins
EFUSE_EXT_PHY_ENABLE 57 1 N 30 Enables external USB PHY
EFUSE_USB_FORCE_NOPERSIST]| 58 1 N 30 Forces to set USB BVALID to 1

lf VDD_SPIFORCE is 1, deter-
EFUSE_VDD_SPI_XPD 68 1 Y 3 mines if the VDD_SPI regulator

is powered on

lf VDD_SPILFORCE is 1, de-

termines VDD_SPI voltage. 0:
EFUSE_VDD_SPI_TIEH 69 1 Y 3 VDD_SPI connects to 1.8 V

LDO; 1: VDD_SPI connects to

VDD_RTC_IO

When set, XPD_VDD_PSI_REG

and VDD_SPI_LTIEH will be
EFUSE_VDD_SPI_FORCE 70 1 Y 3 ;

used to configure VDD_SPI

LDO

Selects RTC WODT_ timeout
EFUSE_WDT_DELAY_SEL 80 2 Y 3

threshold at startup

Enables encryption and de-

cryption, when an SPI boot
EFUSE_SPI_LBOOT_CRYPT_CNT 82 3 Y 4 mode is set. Feature is enabled

when 1 or 3 bits are set in the

eFuse, disabled otherwise.
EFUSE_SECURE_BOOT_KEY_ 85 1 N 5 If set, revokes use of secure
REVOKEO boot key digest 0

Espressif Systems 310 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
16. eFuse Controller

 

 

Bit

Hardware

Programming-Protection

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Parameters Offset by EFUSE_WR_DIS Description
Width Use ,
Bit Number

EFUSE_SECURE_BOOT_KEY_ 86 1 N 6 If set, revokes use of secure
REVOKE1 boot key digest 1
EFUSE_SECURE_BOOT_KEY_ a7 1 N 7 If set, revokes use of secure
REVOKE2 boot key digest 2
EFUSE_KEY_PURPOSE_O 88 4 Y 8 KEYO purpose, see Table 55
EFUSE_KEY_PURPOSE_1 92 4 Y 9 KEY1 purpose, see Table 55
EFUSE_KEY_PURPOSE_2 96 4 Y 10 KEY2 purpose, see Table 55
EFUSE_KEY_PURPOSE_3 100 4 Y 11 KEY3 purpose, see Table 55
EFUSE_KEY_PURPOSE_4 104 4 Y 12 KEY4 purpose, see Table 55
EFUSE_KEY_PURPOSE_5 108 4 Y 13 KEY5 purpose, see Table 55
EFUSE_SECURE_BOOT_EN 116 q N 15 Enables secure boot
EFUSE SECURE BOOT. 417 1 N 16 Enables aggressive secure
AGGRESSIVE_REVOKE boot key revocation mode

Configures flash startup delay

after SoC power-up, unit is
EFUSE_FLASH_TPUW 124 4 N 18 ;

(ms/2). When the value is 15,

delay is 7.5 ms.

Disables all Download boot
EFUSE_DIS_DOWNLOAD_MODE | 128 1 N 18

modes

Disables Legacy SPI boot
EFUSE_DIS_LEGACY_SPILBOOT | 129 1 N 18

mode

Selects the default UART for
EFUSE_UART_PRINT_CHANNEL 130 q N 18 printing boot messages, 0:

UARTO; 1: UART1
EFUSE_DIS_USB_DOWNLOAD_ 499 1 N 18 Disables use of USB in UART
MODE download boot mode

Enables secure UART down-
EFUSE_ENABLE_SECURITY_ ;

183 1 N 18 load mode (read/write flash

DOWNLOAD

only)

Sets the default UART boot

message output mode. 2’b00:

Enabled; 2’b01: Enable when
EFUSE_UART_PRINT_CONTROL | 134 2 N 18 ;

GPIO 46 is low at reset; 2’b10:

Enable when GPIO 46 is high at

rest; 2’611: Disabled.

Sets default power supply for

GPIO3S3 ~ GPIOS7, set when
EFUSE_PIN_POWER_SELECTION | 136 1 N 18 pe

SPI flash is_ initialized. 0:

VDD3P3_CPU; 1: VDD_SPI

Selects SPI flash type, O: max-
EFUSE_FLASH_TYPE 137 q N 18 imum four data lines; 1: eight

data lines

 

Espressif Systems

311

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
16. eFuse Controller

 

 

. Programming-Protection
Bit Hardware

 

Parameters Offset by EFUSE_WR_DIS Description
Width Use ,
Bit Number
Forces ROM code to send
EFUSE_FORCE_SEND_ RESUME 138 q N 18 an SPI flash resume command

during SPI boot

 

 

EFUSE_SECURE_VERSION

139 16 N 18

 

 

 

 

 

Secure version (used by ESP-
IDF anti-rollback feature)

 

 

Table 55 lists all key purpose and their values. Setting the eFuse parameter EFUSE_KEY_PURPOSE_n programs

the purpose for eFuse block KEY (9: O~ 5).

Table 55: Key Purpose Values

 

Key Purpose Values

Purposes

 

User purposes (software-only use)

 

Reserved

 

XTS_AES_256_KEY_1 (flash/PSRAM encryption)

 

XTS_AES_256_KEY_2 (flash/PSRAM encryption)

 

XTS_AES_128 KEY (flash/PSRAM encryption)

 

HMAC Downstream mode

 

JTAG soft enable key (uses HMAC Downstream mode)

 

Digital Signature peripheral key (uses HMAC Downstream mode)

 

HMAC Upstream mode

 

SECURE _BOOT_DIGESTO (Secure Boot key digest)

 

SECURE BOOT _DIGEST1 (Secure Boot key digest)

 

 

AIS) OClalN]/ a) a}aAyalrmyato

 

 

SECURE _BOOT_DIGEST2 (Secure Boot key digest)

 

Table 56 provides the details on the parameters in BLOCK1 ~ BLOCK10.

Table 56: Parameters in BLOCK1-10

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Hardware Write Protection by | Software Read Protection _
BLOCK Parameters Bit Width Use EFUSE_WR_DIS py EFUSE_RD_DIS Description
Bit Number Bit Number
BLOCK‘ EFUSE_MAC 48 N 20 N/A MAC address
EFUSE_SPI_PAD_ [0:5] N 20 N/A CLK
CONFIGURE [6:11] N 20 N/A Q (D1)
[12:17] N 20 N/A D (DO)
[18:23] N 20 N/A CS
[24:29] N 20 N/A HD (D8)
[30:35] N 20 N/A WP (D2)
[36:41] N 20 N/A DQS
[42:47] N 20 N/A D4
[48:53] N 20 N/A D5
[54:59] N 20 N/A D6
[60:65] N 20 N/A D7
Espressif Systems 312 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
16. eFuse Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

oe Write Protection by | Software Read Protection
BLOCK Parameters Bit Width “lee EFUSE_WR_DIS by EFUSE_RD_DIS Description
“e Bit Number Bit Number
EFUSE_SYS_DATA_PARTO 78 N 20 N/A System data

BLOCK2 | EFUSE_SYS_DATA_PART1 256 N 21 N/A System data
BLOCK3 EFUSE_USR_DATA 256 N 22 N/A User data

KeyO or user
BLOCK4 EFUSE_KEYO_DATA 256 Y 23 0

data

Key1 or user
BLOCKS EFUSE_KEY1_DATA 256 Y 24 1

data

Key2 or user
BLOCK6 EFUSE_KEY2_DATA 256 Y 25 2

data

Key3 or user
BLOCK7 EFUSE_KEY3_DATA 256 Y 26 3

data

Key4 or user
BLOCK8 EFUSE_KEY4_DATA 256 Y 27 4

data

Key5 or user
BLOCK9 EFUSE_KEY5_DATA 256 Y 28 5

data
BLOCK10 | EFUSE_SYS_DATA_PART2 256 N 29 6 System data

 

Among these blocks, BLOCK4 ~ 9 stores KEYO ~ 5, respectively. Up to six 256-bit keys can be programmed
into eFuse. Whenever a key is programmed, its purpose value should also be programmed (see table 55). For
example, a key for the JTAG function in HMAC Downstream mode is programmed to KEYS (i.e., BLOCK), then,
the key purpose value 6 should be programmed to EFUSE_KEY_PURPOSE_3.

BLOCK1 ~ BLOCK10 use the RS coding scheme, so there are some restrictions on writing to these parameters
(refer to Section 16.3.1.8: Data Storage and Section 16.3.2: Software Programming of Parameters).

16.3.1.1 EFUSE_WR_DIS

Parameter EFUSE_WR_DIS determines whether individual eFuse parameters are write-protected. After burning
EFUSE_WR_DIS, execute an eFuse read operation so the new values will take effect (refer to Updating eFuse
read registers in Section 16.3.8).

The columns “Programming-Protected by EFUSE_WR_DIS’” in Table 54 and Table 56 list the specific bits of
EFUSE_WR_DIS that determine the write protected status of each parameter.

When the corresponding bit is 0, the parameter is not write protected and can be programmed if the parameter
has not been programmed.

When the corresponding bit is 1, the parameter is write protected and none of its bits can be modified. The
non-programmed bits always remain O, while programmed bits always remain 1.

16.3.1.2 EFUSE_RD_DIS

Only the eFuse blocks BLCOK4 ~ BLOCK10 can be individually software read protected. The corresponding bit
in EFUSE_RD_DIS is shown in Table 56. After burning EFUSE_RD_DIS, execute an eFuse read operation so the
new values will take effect (refer to Updating eFuse read registers in Section 16.3.8).

Espressif Systems 313 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback

 
16. eFuse Controller

 

lf the corresponding EFUSE_RD_DIS bit is 0, then the eFuse block can be read by software. If the corresponding
EFUSE_RD_DIS bit is 1, then the parameter controlled by this bit is software read protected.

Other parameters that are not in BLOCK4 ~ BLOCK10 can always be read by software.

Although BLOCK4 ~ BLOCK10 can be set to read-protected, they can still be used by hardware modules, if the
EFUSE_KEY_PURPOSE_» bit is set accordingly.

16.3.1.3 Data Storage

Internal to the SoC, eFuses use hardware encoding schemes to protect against data corruption.

All BLOCKO parameters except for EFUSE_WR_DIS are stored with four backups, meaning each bit is stored
four times. This backup scheme is automatically applied by the hardware and is not visible to software.

BLOCK1 ~ BLOCK10 use RS (44, 32) coding scheme that supports up to 5 bytes of automatic error correction.
The primitive polynomial of RS (44, 32) is p(x) = #8 + at +23 +2? +1. The shift register circuit that generates
the check code is shown in Figure 16-1, where gf_mul_n (n is an integer) is the result of multiplying a byte of data
in the GF'(2) field by the element a”.

 

 

Output

 

 

Input mi, ma, ... Mk

 

 

 

 

Figure 16-1. Shift Register Circuit

Software must encode the 32-byte parameter using RS (44, 32) to generate a 12-byte check code, and then
burn the parameter and the check code into eFuse at the same time. The eFuse Controller automatically
decodes the RS encoding and applies error correction when reading back the eFuse block.

Because the RS check codes are generated across the entire 256-bit eFuse block, each block can only be
written to one time.

16.3.2 Software Programming of Parameters

The eFuse controller can only write to eFuse parameters in one block at a time. BLOCKO ~ BLOCK10 share the
same registers to store the parameters to be programmed. Configure parameter EFUSE_BLK_NUM to indicate
which block is to be programmed.

Programming BLOCKO

When EFUSE_BLK_NUM = 0, BLOCKO is programmed. Register EFUSE_PGM_DATAO_REG stores
EFUSE_WR_DIS. EFUSE_PGM_DATA1_REG ~ EFUSE_PGM_DATAS5_REG store the information of new
BLOCKO parameters to be programmed. Note that 24 BLOCKO bits are reserved and can only be used by
hardware. These must always be set to 0 in the programming registers. The specific bits are:

¢ EFUSE_PGM_DATA1_REG[29:31]
¢ EFUSE_PGM_DATA1_REG[20:23]
e EFUSE_PGM_DATA2_REG|7:15]
e EFUSE_PGM_DATA2_REG[O0:3]

Espressif Systems 314 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

¢ EFUSE_PGM_DATAS_REG[16:19]

Values written to EFUSE_PGM_DATA6_REG ~ EFUSE_PGM_DATA?7_REG and
EFUSE_PGM_CHECK_VALUEO_REG ~ EFUSE_PGM_CHECK_VALUE2_REG are ignored when programming
BLOCKO.

Programming BLOCK1

When EFUSE_BLK_NUM = 1, EFUSE_PGM_DATAO_REG ~ EFUSE_PGM_DATAS5_REG store the parameters to
be programmed. EFUSE_PGM_CHECK_VALUEO_ REG ~ EFUSE_PGM_DATA2_REG store the corresponding
RS check codes. Values written to EFUSE_PGM_DATA6_REG ~ EFUSE_PGM_DATA7_REG are ignored when
programming BLOCK1, the RS check codes should be calculated as if these bits were all 0.

Programming BLOCK2 ~ 10

When EFUSE_BLK_NUM = 2 10, EFUSE_PGM_DATAO_REG ~ EFUSE_PGM_DATA7_REG store the
parameters to be programmed to this block. EFUSE_PGM_CHECK_VALUEO_REG ~
EFUSE_PGM_CHECK_VALUE2_REG store the corresponding RS check codes.

Programming process
The process of programming parameters is as follows:
1. Set EFUSE_BLK_NUM parameter as described above.

2. Write the parameters to be programmed into registers EFUSE_PGM_DATAO_REG ~
EFUSE_PGM_DATA7_REG and EFUSE_PGM_CHECK_VALUEO_REG ~
EFUSE_PGM_CHECK_VALUE2 REG.

3. Ensure the eFuse clock registers are set correctly as described in Section 16.3.4.1: eFuse-Programming
Timing.

4. Ensure the eFuse programming voltage VDDQ is set correctly as described in Section 16.3.4.2: eFuse
VDDQ Seiting.

5. Set EFUSE_OP_CODE field in register EFUSE_CONF_REG to Ox5A5A.

6. Set EFUSE_PGM_CWVD field in register EFUSE_CMD_REG to 1.

7. Poll register EFUSE_CMD_REG until it is 0x0, or wait for a pgm_cone interrupt. Information on how to
identify a pgm/read_cone interrupt is provided at the end of Section 16.3.3.

8. Clear the parameters written into the register.

9. Trigger an eFuse read operation (see Section 16.3.3: Software Reading of Parameters) to update eFuse
registers with the new values.

Limitations

For BLOCKO, the programming of different parameters and even the programming of different bits of the same
parameter does not need to be done at once. It is, however, recommended that users minimize programming
cycles and program all the bits of a parameter in one programming action. In addition, after all parameters
controlled by a certain bit of EFUSE_WR_DIS are programmed, that bit should be immediately programmed. The
programming of parameters controlled by a certain bit of EFUSE_WR_DIS, and the programming of the bit itself
can even be completed at the same time. Repeated programming of already programmed bits is strictly
forbidden, otherwise, programming errors will occur.

BLOCK1 cannot be programmed by users as it has been programmed at manufacturing.

Espressif Systems 315 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

BLOCK2 ~ 10 can only be programmed once. Repeated programming is not allowed.

16.3.3 Software Reading of Parameters

Software cannot read eFuse bits directly. The eFuse Controller hardware reads all eFuse bits and stores the
results to their corresponding registers in the memory space. Then, software can read eFuse bits by reading the
registers that start with EFUSE_RD_. Details are provided in the table below.

 

 

 

 

 

 

 

 

 

 

 

 

BLOCK | Read Registers When Programming This Block
0 EFUSE_RD_WR_DIS_REG EFUSE_PGM_DATAO_REG

0 EFUSE_RD_REPEAT_DATAO ~ 4_REG EFUSE_PGM_DATA1 ~ 5 REG

4 EFUSE_RD_MAC_SPI_SYS_0~5 REG EFUSE_PGM_DATAO ~ 5 REG

2 EFUSE_RD_SYS_DATA_PART1_0~ 7_REG EFUSE_PGM_DATAO ~ 7_REG

3 EFUSE_RD_USR_DATAO ~ 7_REG EFUSE_PGM_DATAO ~ 7_REG

4-9 EFUSE_RD_KEYn_DATAO ~ 7_REG (7: 0 ~ 5) | EFUSE_PGM_DATAO ~ 7_REG

10 EFUSE_RD_SYS_DATA_PART2_0~ 7_REG EFUSE_PGM_DATAO ~ 7_REG

 

Updating eFuse read registers

The eFuse Controller hardware populates the read registers from the internal eFuse storage. This read operation
happens on system reset and can also be triggered manually by software as needed, for example if new eFuse
values have been programmed.

The process of triggering an eFuse controller read from software is as follows:
1. Configure the eFuse read timing registers as described in Section 16.3.4.3: eFuse-Read Timing.
2. Set the EFUSE_OP_CODE field in register EFUSE_CONF_REG to Ox5AA5.
3. Set the EFUSE_READ_CMD field in register EFUSE_CMD_REG to 1.

4. Poll the EFUSE_CMD_REG register until it is OxO, or wait for a read_done interrupt. Information on how to
identify a pgm/read_cone interrupt is provided below.

5. Software reads the values of each parameter from memory.
The eFuse read registers will now hold updated values for all eFuse parameters.
Error detection
Error registers allow software to detect an inconsistency in the stored eFuses.

EFUSE_RD_REPEAT_ERRO ~ 3_REG indicate inconsistencies in the stored backup copies of the parameters in
BLOCKO (except for EFUSE_WR_DIS) . Value 1 indicates an error was detected, and the bit became invalid.
Value 0 indicates no error.

Registers EFUSE_RD_RS_ERRO ~ 1_REG store the number of corrected bytes as well as the result of RS
decoding during eFuse reading BLOCK1 ~ BLOCK10.

Software can read the values of above registers only after the eFuse read registers have been updated.
Identifying program/read operation completion

The two methods to identify the completion of program/read operation are described below. Please note that bit
1 corresponds to program operation, and bit 0 corresponds to read operation.

° Method one:

Espressif Systems 316 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

1. Poll bit 1/0 in register EFUSE_INT_RAW_REG until it is 1, which represents the completion of a
program/read operation.

° Method two:

1. Set bit 1/0 in register EFUSE_INT_ENA_REG to 1 to enable eFuse Controller to post a
pgn7/read_done interrupt.

2. Configure Interrupt Matrix to enable the CPU to respond to eFuse interrupt signal.
3. Wait for the pgm/read_cone interrupt.
4. Set the bit 1/0 in register EFUSE_INT_CLR_REG to 1 to clear the pgm/read_cone interrupt.

16.3.4 Timing

16.3.4.1. eFuse-Programming Timing

Figure 16-2 shows the timing for programming eFuse. Four registers EFUSE_TSUP_A, EFUSE_TPGM,
EFUSE_THP_A, and EFUSE_TPGM_INACTIVE are used to configure the timing. Terms used in the timing
diagrams in this section are described as follows:

* CSB: Chip select, active low
e VDDQ: eFuse programming voltage

* PGENB: eFuse programming enable signal, active low

CSB |
VDDQ |
PGENB |

 

 

—
|
<<

 

ADDR ean
a>
EFUSE_TPGM BES TPGM_INACTIVE
EFUSE_TSUP_A
STROBE

 

 

 

 

 

LOAD

Figure 16-2. eFuse-Programming Timing Diagram

EFUSE_THP_A

 

 

—

 

The eFuse block uses the CLK_APB clock, which is configurable. Therefore, the timing parameters should be

configured according to the specific clock frequency. After reset, the initial parameters are based on 20 MHz
clock frequency.

Table 58: Configuration of eFuse-Programming Timing Parameters

EFUSE_TSUP_A EFUSE_TPGM EFUSE_THP_A | EFUSE_TPGM_INACTIVE
APB Frequency
{> 6.669 ns) (9-11 ys, usually 10 zs) {> 6.166 ns) {> 35.96 ns)
80 MHz Ox2 0x820 Ox2 Ox4
40 MHz Ox1 0x190 Ox1 Ox2
20 MHz Ox1 OxC8 Ox1 Ox1
Espressif Systems 317

 

 

 

 

 

 

 

 

 

 

 

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
16. eFuse Controller

In Figure 16-2, Address AO is programmed, then the corresponding eFuse bit is 1; Address A1 is not

programmed, then the corresponding eFuse bit is O.

16.3.4.2 eFuse VDDQ Timing Setting

VDDQ is the eFuse programming voltage, and its timing parameters should be configured according to the APB

clock frequency:

Table 59: Configuration of VDDQ Timing Parameters

 

 

 

 

EFUSE_DAC_CLK_DIV EFUSE_PWR_ON_NUM EFUSE_PWR_OFF_NUM
APB Frequency
(> 1 ys) (> EFUSE_DAC_CLK_DIV*255) © 3 ps)
80 MHz OxAO OxA200 0x100
40 MHz 0x50 0x5100 Ox80
20 MHz 0x28 O0x2880 0x40

 

 

 

 

 

 

16.3.4.3 eFuse-Read Timing

Figure 16-3 shows the timing for reading eFuse. Three registers EFUSE_TSUR_A, EFUSE_TRD, and
EFUSE_THR_A are used to configure the timing.

The parameters should be configured according to the specific APB clock frequency. Details can be found in the

 

 

 

 

 

 

 

 

 

 

table below.
Table 60: Configuration of eFuse-Reading Parameters
EFUSE_TSUR_A | EFUSE_TRD | EFUSE_THR_A
APB Frequency
(> 6.669 ns) (> 35.96 ns) (> 6.166 ns)
80 MHz Ox2 Ox4 Ox2
40 MHz Ox1 Ox2 Ox1
20 MHz Ox1 Ox1 Ox1
Espressif Systems 318 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

 

CSB |

VDDQ 7
PGENB | |

ADDR TT or
AO Al ><

EFUSE_TRD

EFUSE_TSUR_A PUL
STROBE SF
EFUSE_THR_A
LOAD

 

 

 

 

 

 

 

 

Q9~Q0

 

 

 

 

Figure 16-3. Timing Diagram for Reading eFuse

16.3.5 The Use of Parameters by Hardware Modules
Hardware modules are directly hardwired to the ESP382-S2 in order to use the parameters listed in Table 54 and
56, specifically those marked with “Y” in columns “Hardware Use”. Software cannot change this behavior.

16.3.6 Interrupts
* pgm_done interrupt: Triggered when eFuse programming has finished. To enable this interrupt, set
EFUSE_PGM_DONE_INT_ENA to 1.

* read_done interrupt: Triggered when eFuse reading has finished. To enable this interrupt, set
EFUSE_READ_DONE_INT_ENA to 1.

16.4 Base Address

Users can access the eFuse Controller with two base addresses, which can be seen in the following table. For
more information about accessing peripherals from different buses please see Chapter 1 System and
Memory.

Table 61: eFuse Controller Base Address

 

Bus to Access Peripheral | Base Address
PeriBUS1 0x6001 A000
PeriBUS2 OxSFC1A000

 

 

 

 

 

 

16.5 Register Summary

The addresses in the following table are relative to the eFuse base addresses provided in Section 16.4.

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access

PGM Data Registers

EFUSE_PGM_DATAO_REG Register O that stores data to be programmed. Ox0000 RAW

EFUSE_PGM_DATA1_REG Register 1 that stores data to be programmed. O0x0004 RAW
Espressif Systems 319 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
EFUSE_PGM_DATA2_REG Register 2 that stores data to be programmed. O0x0008 RAW
EFUSE_PGM_DATA3_REG Register 3 that stores data to be programmed. Ox000C RAW
EFUSE_PGM_DATA4_REG Register 4 that stores data to be programmed. 0x0010 RAW
EFUSE_PGM_DATA5 REG Register 5 that stores data to be programmed. 0x0014 RAW
EFUSE_PGM_DATA6_REG Register 6 that stores data to be programmed. 0x0018 RAW
EFUSE_PGM_DATA7_REG Register 7 that stores data to be programmed. 0x001C RAW

Register O that stores the RS code to be pro-
EFUSE_PGM_CHECK_VALUEO_REG 0x0020 RAW

grammed.

Register 1 that stores the RS code to be pro-
EFUSE_PGM_CHECK_VALUE1_REG 0x0024 RAW

grammed.

Register 2 that stores the RS code to be pro-
EFUSE_PGM_CHECK_VALUE2 REG 0x0028 RAW

grammed.
Read Data Registers
EFUSE_RD_WR_DIS_REG Register 0 of BLOCKO. 0x002C RO
EFUSE_RD_REPEAT DATAO_REG Register 1 of BLOCKO. O0x0030 RO
EFUSE_RD_REPEAT_DATA1_REG Register 2 of BLOCKO. 0x0034 RO
EFUSE_RD_REPEAT DATA2 REG Register 3 of BLOCKO. 0x0038 RO
EFUSE_RD_REPEAT_ DATA3_ REG Register 4 of BLOCKO. O0x003C RO
EFUSE_RD_REPEAT DATA4 REG Register 5 of BLOCKO. 0x0040 RO
EFUSE_RD_MAC_SPI_SYS_O_REG Register 0 of BLOCK1. 0x0044 RO
EFUSE_RD_MAC_SPI_SYS_1_REG Register 1 of BLOCK1. 0x0048 RO
EFUSE_RD_MAC_SPI_SYS_2 REG Register 2 of BLOCK1. 0x004C RO
EFUSE_RD_MAC_SPI_SYS_3 REG Register 3 of BLOCK1. 0x0050 RO
EFUSE_RD_MAC_SPI_SYS_4 REG Register 4 of BLOCK1. 0x0054 RO
EFUSE_RD_MAC_SPI_SYS_5 REG Register 5 of BLOCK1. 0x0058 RO
EFUSE_RD_SYS_DATA_PART1_0_REG | Register 0 of BLOCk2 (system). Ox005C RO
EFUSE_RD_SYS_DATA_PART1_1_REG | Register 1 of BLOCK2 (system). Ox0060 RO
EFUSE_RD_SYS_DATA_PART1_2 REG | Register 2 of BLOCK2 (system). 0x0064 RO
EFUSE_RD_SYS_DATA_PART1_3 REG | Register 3 of BLOCK2 (system). Ox0068 RO
EFUSE_RD_SYS_DATA_PART1_4 REG | Register 4 of BLOCk2 (system). Ox006C RO
EFUSE_RD_SYS_DATA_PART1_5 REG | Register 5 of BLOCK2 (system). 0x0070 RO
EFUSE_RD_SYS_DATA_PART1_6_ REG | Register 6 of BLOCK2 (system). 0x0074 RO
EFUSE_RD_SYS_DATA_PART1_7_ REG | Register 7 of BLOCK2 (system). 0x0078 RO
EFUSE_RD_USR_DATAO_REG Register 0 of BLOCKS (user). 0x007C RO
EFUSE_RD_USR_DATA1_REG Register 1 of BLOCKS (user). Ox0080 RO
EFUSE_RD_USR_DATA2_ REG Register 2 of BLOCKS (user). 0x0084 RO
EFUSE_RD_USR_DATA3_REG Register 3 of BLOCKS (user). 0x0088 RO
EFUSE_RD_USR_DATA4 REG Register 4 of BLOCKS (user). Ox008C RO
EFUSE_RD_USR_DATA5 REG Register 5 of BLOCKS (user). O0x0090 RO
EFUSE_RD_USR_DATA6_REG Register 6 of BLOCKS (user). 0x0094 RO
EFUSE_RD_USR_DATA7_REG Register 7 of BLOCKS (user). 0x0098 RO
EFUSE_RD_KEYO_DATAO_REG Register 0 of BLOCK4 (KEYO). Ox009C RO
EFUSE_RD_KEYO_DATA1_REG Register 1 of BLOCK4 (KEYO). Ox00A0 RO

Espressif Systems 820 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
16. eFuse Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
EFUSE_RD_KEYO_DATA2_ REG Register 2 of BLOCK4 (KEYO). Ox00A4 RO
EFUSE_RD_KEYO_DATA3_REG Register 3 of BLOCK4 (KEYO). Ox00A8 RO
EFUSE_RD_KEYO_DATA4 REG Register 4 of BLOCK4 (KEYO). OxO00AC RO
EFUSE_RD_KEYO_DATA5 REG Register 5 of BLOCK4 (KEYO). OxOOBO RO
EFUSE_RD_KEYO_DATA6_REG Register 6 of BLOCK4 (KEYO). Ox00B4 RO
EFUSE_RD_KEYO_DATA7_REG Register 7 of BLOCK4 (KEYO). Ox00B8 RO
EFUSE_RD_KEY1_DATAO_REG Register 0 of BLOCKS (KEY1). Ox00BC RO
EFUSE_RD_KEY1_DATA1_REG Register 1 of BLOCKS (KEY1). Ox00CO RO
EFUSE_RD_KEY1_DATA2 REG Register 2 of BLOCKS (KEY1). Ox00C4 RO
EFUSE_RD_KEY1_DATA3_REG Register 3 of BLOCKS (KEY1). Ox00C8 RO
EFUSE_RD_KEY1_DATA4 REG Register 4 of BLOCKS (KEY1). Ox00CC RO
EFUSE_RD_KEY1_DATA5 REG Register 5 of BLOCKS (KEY1). Ox00DO RO
EFUSE_RD_KEY1_DATA6_REG Register 6 of BLOCKS (KEY1). O0x00D4 RO
EFUSE_RD_KEY1_DATA7_REG Register 7 of BLOCKS (KEY1). Ox00D8 RO
EFUSE_RD_KEY2_DATAO_REG Register 0 of BLOCK6 (KEY2). Ox00DC RO
EFUSE_RD_KEY2_DATA1_REG Register 1 of BLOCK6 (KEY2). OxOO0EO RO
EFUSE_RD_KEY2_DATA2 REG Register 2 of BLOCK6 (KEY2). Ox00E4 RO
EFUSE_RD_KEY2_DATA3_REG Register 3 of BLOCK6 (KEY2). Ox00E8 RO
EFUSE_RD_KEY2_DATA4 REG Register 4 of BLOCK6 (KEY2). OxO0EC RO
EFUSE_RD_KEY2_DATA5 REG Register 5 of BLOCK6 (KEY2). OxO0FO RO
EFUSE_RD_KEY2_DATA6_REG Register 6 of BLOCK6 (KEY2). OxO00F4 RO
EFUSE_RD_KEY2_DATA7_REG Register 7 of BLOCK6 (KEY2). OxO0F8 RO
EFUSE_RD_KEYS_DATAO_REG Register 0 of BLOCK? (KEYS). OxOOFC RO
EFUSE_RD_KEY3_DATA1_REG Register 1 of BLOCK? (KEYS). 0x0100 RO
EFUSE_RD_KEY3_DATA2 REG Register 2 of BLOCK? (KEYS). 0x0104 RO
EFUSE_RD_KEY3_DATA3_REG Register 3 of BLOCK? (KEYS). 0x0108 RO
EFUSE_RD_KEY3_DATA4 REG Register 4 of BLOCK? (KEYS). 0x010C RO
EFUSE_RD_KEYS_DATA5 REG Register 5 of BLOCK? (KEYS). 0x0110 RO
EFUSE_RD_KEY3_DATA6_REG Register 6 of BLOCK? (KEYS). 0x0114 RO
EFUSE_RD_KEY3_DATA7_REG Register 7 of BLOCK? (KEYS). 0x0118 RO
EFUSE_RD_KEY4_DATAO_REG Register 0 of BLOCK8 (KEY4). 0x011C RO
EFUSE_RD_KEY4_DATA1_REG Register 1 of BLOCK8 (KEY4). 0x01 20 RO
EFUSE_RD_KEY4_DATA2 REG Register 2 of BLOCK8 (KEY4). 0x01 24 RO
EFUSE_RD_KEY4_DATA3 REG Register 3 of BLOCK8 (KEY4). 0x0128 RO
EFUSE_RD_KEY4_DATA4 REG Register 4 of BLOCK8 (KEY4). 0x012C RO
EFUSE_RD_KEY4_DATA5 REG Register 5 of BLOCK8 (KEY4). 0x0130 RO
EFUSE_RD_KEY4_DATA6_REG Register 6 of BLOCK8 (KEY4). 0x0134 RO
EFUSE_RD_KEY4_DATA7_REG Register 7 of BLOCK8 (KEY4). 0x0138 RO
EFUSE_RD_KEY5 DATAO_REG Register 0 of BLOCK9 (KEYS). 0x013C RO
EFUSE_RD_KEY5_DATA1_REG Register 1 of BLOCK9 (KEYS). 0x0140 RO
EFUSE_RD_KEY5 DATA2 REG Register 2 of BLOCK9 (KEY5). 0x01 44 RO
EFUSE_RD_KEY5 DATA3 REG Register 3 of BLOCK9 (KEYS). 0x0148 RO
EFUSE_RD_KEY5_DATA4 REG Register 4 of BLOCK9 (KEYS). 0x014C RO

 

Espressif Systems

321

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
16. eFuse Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Submit Documentation Feedback

Name Description Address | Access
EFUSE_RD_KEY5 DATA5 REG Register 5 of BLOCK9 (KEYS). 0x0150 RO
EFUSE_RD_KEY5_DATA6_REG Register 6 of BLOCK9 (KEYS). 0x0154 RO
EFUSE_RD_KEY5_DATA7_REG Register 7 of BLOCK9 (KEYS). 0x0158 RO
EFUSE_RD_SYS_DATA_PART2_0_REG | Register 0 of BLOCK10 (system). 0x015C RO
EFUSE_RD_SYS_DATA_PART2_1_REG | Register 1 of BLOCK10 (system). 0x0160 RO
EFUSE_RD_SYS_DATA_PART2_2 REG | Register 2 of BLOCK10 (system). 0x0164 RO
EFUSE_RD_SYS_DATA_PART2_3 REG | Register 3 of BLOCK10 (system). 0x0168 RO
EFUSE_RD_SYS_DATA_PART2_4 REG | Register 4 of BLOCK10 (system). O0x016C RO
EFUSE_RD_SYS_DATA_PART2_5 REG | Register 5 of BLOCK10 (system). 0x01 70 RO
EFUSE_RD_SYS_DATA_PART2_6_REG | Register 6 of BLOCK10 (system). 0x01 74 RO
EFUSE_RD_SYS_DATA_PART2_7_REG | Register 7 of BLOCK10 (system). 0x0178 RO
Error Status Registers
EFUSE_RD_REPEAT_ERRO_REG Programming error record register 0 of BLOCKO. | 0x017C RO
EFUSE_RD_REPEAT_ERR1_REG Programming error record register 1 of BLOCKO. | 0x0180 RO
EFUSE_RD_REPEAT_ERR2 REG Programming error record register 2 of BLOCKO. | 0x0184 RO
EFUSE_RD_REPEAT_ERRS_REG Programming error record register 38 of BLOCKO. | 0x0188 RO
EFUSE_RD_REPEAT_ERR4_REG Programming error record register 4 of BLOCKO. | 0x0190 RO
Programming error record register O of BLOCK1-
EFUSE_RD_RS_ERRO_REG 10. 0x01C0 RO
Programming error record register 1 of BLOCK1-
EFUSE_RD_RS_ERR1_REG 10. 0x01C4 RO
Control/Status Registers
EFUSE_CLK_REG eFuse clock configuration register. 0x01C8 RAW
EFUSE_CONF_REG eFuse operation mode configuration register. 0x01CC RAW
EFUSE_CMD_REG eFuse command register. 0x01D4 RAW
EFUSE_DAC_CONF_REG Controls the eFuse programming voltage. Ox01E8 RAW
EFUSE_STATUS_REG eFuse status register. 0x01DO RO
Interrupt Registers
EFUSE_INT_RAW_REG eFuse raw interrupt register. 0x01D8 RO
EFUSE_INT_ST_REG eFuse interrupt status register. 0x01DC RO
EFUSE_INT_ENA_REG eFuse interrupt enable register. Ox01E0O RAW
EFUSE_INT_CLR_REG eFuse interrupt clear register. Ox01E4 WO
Configuration Registers
EFUSE_RD_TIM_CONF_REG Configures read timing parameters. OxO1EC RAW
Configuration register 0 of eFuse programming
EFUSE_WR_TIM_CONFO_REG , Ox01FO RAW
timing parameters.
EFUSE WR TIM_CONF1 REG Configuration register 1 of eFuse programming OxO1F4 RAW
timing parameters.
Configuration register 2 of eFuse programming
EFUSE_WR_TIM_CONF2_REG , OxO1F8 RAW
timing parameters.
Version Register
EFUSE_DATE_REG Version control register. Ox01FC RAW
Espressif Systems 822 ESP32-S2 TRM (Preliminary V0.4)

 
16. eFuse Controller

 

16.6 Registers

Register 16.1: EFUSE_PGM_DATA”_REG (7: 0-7) (0x0000+4*n)

 

 

 

ae
oO x
&E
ry
&
[= |
| 0x000000 | Reset

 

EFUSE_PGM_DATA_» The content of the nth 32-bit data to be programmed. (RAW)

Register 16.2: EFUSE_PGM_CHECK_VALUEn_REG (7: 0-2) (0x0020+4*;)

 

 

| 0x000000 | Reset

 

EFUSE _PGM_RS_DATA_» The content of the nth 32-bit RS code to be programmed. (RAW)

Register 16.3: EFUSE_RD_WR_DIS_REG (0x002C)
©
Ros
Oe

 

 

| 0x000000 | Reset

 

EFUSE WR_DIS_ Disables programming of individual eFuses. (RO)

Espressif Systems 823 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.4: EFUSE_RD_REPEAT_DATAO_REG (0x0030)

 

 

 

xz
S xX
Az yy MY
Zé s Oe
S SSS Ooo Se SoVoe
LS OSS SEES SKS yo”
e SR e se SESS & LSIH oe &
Sits SK’ SITE OS
» SES » ¥EESESEEEEES
SL EEL SE EE EEE LE ELE EL SL Koa
€ S& 8&8 € S8EEEEEEEEEEFE é
[1 22| 2 ar| 26 | 25 | 2 [2s wie [|i] [as | wlelulofo]s]-[s o|
[o 0 o| oo |o]o]o fo 0 0 of[ofofofofofofofofofo]ofo]o] x0 |Reset

 

EFUSE RD_DIS Disables software reading from individual eFuse blocks (BLOCK4-10). (RO)
EFUSE_DIS_RTC_RAM_BOOT Set this bit to disable boot from RTC RAM. (RO)
EFUSE_DIS_ICACHE Set this bit to disable ICache. (RO)

EFUSE_DIS_DCACHE Set this bit to disable DCache. (RO)

EFUSE DIS DOWNLOAD _ICACHE Disables Icache when SoC is in Download mode. (RO)
EFUSE DIS DOWNLOAD DCACHE Disables Dcache when SoC is in Download mode. (RO)

EFUSE DIS FORCE DOWNLOAD Set this bit to disable the function that forces chip into download
mode. (RO)

EFUSE_DIS_USB Set this bit to disable USB OTG function. (RO)

EFUSE DIS_CAN Set this bit to disable the TWAI Controller function. (RO)

EFUSE DIS_BOOT_REMAP Disables capability to Remap RAM to ROM address space. (RO)
EFUSE RPT4 RESERVEDS5 Reserved (used for four backups method). (RO)

EFUSE_SOFT_DIS_JTAG Software disables JTAG. When software disabled, JTAG can be activated
temporarily by HMAC peripheral. (RO)

EFUSE_ HARD _DIS_JTAG Hardware disables JTAG permanently. (RO)

EFUSE DIS DOWNLOAD MANUAL_ENCRYPT Disables flash encryption when in download boot
modes. (RO)

EFUSE USB_EXCHG PINS Set this bit to exchange USB D+ and D- pins. (RO)
EFUSE EXT PHY ENABLE Set this bit to enable external USB PHY. (RO)
EFUSE USB_FORCE_NOPERSIST If set, forces USB BVALID to 1. (RO)

EFUSE RPT4 RESERVEDO Reserved (used for four backups method). (RO)

Espressif Systems 824 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

Register 16.5: EFUSE_RD_REPEAT_DATA1_REG (0x0034)

 

 

 

YAO
LEE
CEL «
S 7 &
x SY NNO € PR ©
O O OO® 9 M7 SE
8 & Se? YS’ ot Soret
~ SEN SF SD SSS
ge Kg CPS SX SOs’
S SS XO S S YX S
a SO SEE SO s SEE
& & SES & & SES &
[1 227 x| 23 | 2 | a1 | 20 [17 16 [15 els [els o|
| OxO | OxO [ofofo] oo | oo Jo 0 0 0 0 0 0 0 ofofofofo 0 0 ofreset

 

EFUSE_VDD_SPI_XPD [If VDD_SPI_FORCE is 1, this value determines if the VDD_SPI regulator is
powered on. (RO)

EFUSE VDD_SPI_TIEH [If VDD_SPI_FORCE is 1, determines VDD_SPI voltage. 0: VDD_SPI con-
nects to 1.8 VLDO; 1: VDD_SPI connects to VDD_RTC_IO. (RO)

EFUSE_VDD_SPI_FORCE Set this bit to use XPD_VDD_PSI_REG and VDD_SPI_TIEH to configure
VDD_SPI LDO. (RO)

EFUSE_ WDT_DELAY SEL Selects RTC watchdog timeout threshold at startup. O: 40,000 slow
clock cycles; 1: 80,000 slow clock cycles; 2: 160,000 slow clock cycles; 3: 320,000 slow clock
cycles. (RO)

EFUSE SPI_BOOT_CRYPT_CNT Enables encryption and decryption, when an SPI boot mode is
set. Feature is enabled 1 or 3 bits are set in the eFuse, disabled otherwise. (RO)

EFUSE SECURE BOOT_KEY REVOKEO If set, revokes use of secure boot key digest 0. (RO)
EFUSE SECURE BOOT_KEY REVOKE‘1 If set, revokes use of secure boot key cigest 1. (RO)
EFUSE SECURE BOOT_KEY REVOKE2 If set, revokes use of secure boot key cigest 2. (RO)
EFUSE KEY PURPOSE_0 Purpose of KEYO. Refer to Table 55 Key Purpose Values. (RO)

EFUSE KEY PURPOSE _1 Purpose of KEY1. Refer to Table 55 Key Purpose Values. (RO)

Espressif Systems 825 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

Register 16.6: EFUSE_RD_REPEAT_DATA2_REG (0x0038)

 

 

 

 

EFUSE_KEY_PURPOSE_2 Purpose of KEY2. Refer to Table 55 Key Purpose Values. (RO)
EFUSE_KEY_PURPOSE_3 Purpose of KEYS. Refer to Table 55 Key Purpose Values. (RO)
EFUSE_KEY_PURPOSE_4 Purpose of KEY4. Refer to Table 55 Key Purpose Values. (RO)
EFUSE_KEY_PURPOSE_5 Purpose of KEYS. Refer to Table 55 Key Purpose Values. (RO)
EFUSE SECURE BOOT_EN Set this bit to enable secure boot. (RO)

EFUSE SECURE BOOT_AGGRESSIVE_REVOKE Set this bit to enable aggressive secure boot key
revocation mode. (RO)

EFUSE RPT4 RESERVED1 Reserved (used for four backups method). (RO)

EFUSE FLASH _TPUW Configures flash startup delay after SoC power-up, in unit of (ms/2). When
the value is 15, delay is 7.5 ms. (RO)

Espressif Systems 826 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.7: EFUSE_RD_REPEAT_DATA3_REG (0x003C)

 

 

| Oxo | Ox0O

 

EFUSE DIS DOWNLOAD MODE Set this bit to disable all download boot modes. (RO)
EFUSE DIS LEGACY SPIBOOT Set this bit to disable Legacy SPI boot mode. (RO)

EFUSE UART_PRINT_CHANNEL Selects the default UART for printing boot messages. 0: UARTO;
1: UART1. (RO)

EFUSE RPT4 RESERVED3 Reserved (used for four backups method). (RO)

EFUSE_DIS_USB_ DOWNLOAD MODE Set this bit to disable use of USB OTG in UART download
boot mode. (RO)

EFUSE_ENABLE SECURITY_DOWNLOAD Set this bit to enable secure UART download mode
(read/write flash only). (RO)

EFUSE UART_PRINT_CONTROL Set the default UART boot message output mode.
00: Enabled.
01: Enable when GPIO46 is low at reset.
10: Enable when GPIO46 is high at reset.
11: Disabled. (RO)

EFUSE PIN_POWER_SELECTION Set default power supply for GPIOS3-GPIO37, set when SPI
flash is initialized. 0: VDDGP3_CPU; 1: VDD_SPI. (RO)

EFUSE FLASH_TYPE SPI flash type. 0: maximum four data lines, 1: eight data lines. (RO)

EFUSE_FORCE_SEND_RESUME If set, forces ROM code to send an SPI flash resume command
during SPI boot. (RO)

EFUSE SECURE VERSION Secure version (used by ESP-IDF anti-rolloack feature). (RO)

EFUSE RPT4 RESERVED2 Reserved (used for four backups method). (RO)

Espressif Systems 827 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.8: EFUSE_RD_REPEAT_DATA4 REG (0x0040)

 

 

 

%
©
Ss
C
3
ev
S 3
rs Sw’
F ~
€ gg
[1 x |2s o|
[o 00000 0 o| 0x0000 |Reset

 

EFUSE RPT4 RESERVED4 Reserved (used for four backups method). (RO)

Register 16.9: EFUSE_RD_MAC_SPI_SYS_0_REG (0x0044)

 

31 °

 

 

 

0x000000 Reset

 

EFUSE MAC_0 Stores the low 32 bits of MAC address. (RO)

Register 16.10: EFUSE_RD_MAC_SPI_SYS_1_REG (0x0048)

 

 

 

 

&
ss
°°
g >
s *
S S
$ &
| 31 16 | 15 9 |
| x00 | x00 |Reset
EFUSE MAC_1_ Stores the high 16 bits of MAC address. (RO)
EFUSE_SPILPAD_CONF_0 Stores the zeroth part of SPILPAD_CONF. (RO)
Espressif Systems 828 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

Register 16.11: EFUSE_RD_MAC_SPI_SYS_2_ REG (0x004C)

>
x

 

[2 |

| 0x000000 | Reset

 

 

EFUSE_SPI_PAD_CONF_1 Stores the first part of SPI_PAD_CONF. (RO)

Register 16.12: EFUSE_RD_MAC_SPI_SYS_3_REG (0x0050)

 

 

 

9
Oo” Y
& a
ae’ ?
Ss o&
se ge
oe oS
gg ©
| 31 18 | 17 o |
| Ox0O | Ox000 | Reset

 

EFUSE_SPI_PAD_CONF_2_ Stores the second part of SPI_LPAD_CONF. (RO)

EFUSE SYS DATA _PARTO_0 Stores the zeroth part of the zeroth part of system data. (RO)

Register 16.13: EFUSE_RD_MAC_SPI_SYS_4 REG (0x0054)

 

 

| 0x000000 | Reset

 

EFUSE SYS DATA _PARTO_1 Stores the fist part of the zeroth part of system data. (RO)

Espressif Systems 829 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.14: EFUSE_RD_MAC_SPI_SYS_5 REG (0x0058)

ot
S
¥
ae

 

[ “|

| 0x000000 | Reset

 

 

EFUSE SYS DATA PARTO_2 Stores the second part of the zeroth part of system data. (RO)

Register 16.15: EFUSE_RD_SYS_DATA_PART1_»_REG (7: 0-7) (0x005C+4*/)

 

[ “|

| 0x000000 | Reset

 

 

EFUSE SYS _DATA_PART1_/ Stores the nth 32 bits of the first part of system data. (RO)

Register 16.16: EFUSE_RD_USR_DATA»_REG (7: 0-7) (0x007C+4*/)

 

 

&
Ss
Ky’
<2)
&
31 0
0x000000 Reset

 

 

 

EFUSE_USR_DATA Stores the nth 32 bits of BLOCKS (user). (RO)

Espressif Systems 830 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.17: EFUSE_RD_KEYO_DATA”_REG (7: 0-7) (0x009C+4*7)

&

X’
a)
&

[ “|

| 0x000000 | Reset

 

 

 

EFUSE_KEY0O_ DATA” Stores the nth 32 bits of KEYO. (RO)

Register 16.18: EFUSE_RD_KEY1_DATAn_REG (7: 0-7) (Ox0O0BC+4*))

 

 

| 0x000000 | Reset

 

EFUSE_KEY1_DATA” Stores the nth 32 bits of KEY1. (RO)

Register 16.19: EFUSE_RD_KEY2_DATAn_REG (7: 0-7) (Ox00DC+4*/)

 

 

 

&
&
Sx
»w
&
[a o]
| 0x000000 | Reset

 

EFUSE_KEY2_DATA” Stores the nth 32 bits of KEY2. (RO)

Register 16.20: EFUSE_RD_KEY3_DATA»_REG (7: 0-7) (OxOOFC+4*/)

 

 

| ©x000000 | Reset

 

EFUSE_KEY3_ DATA” Stores the nth 32 bits of KEYS. (RO)

Espressif Systems 831 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.21: EFUSE_RD_KEY4 DATA”_REG (7: 0-7) (0x011C0+4*7)

&

X’
a)
&

 

 

| 0x000000 | Reset

 

EFUSE_KEY4 DATA” Stores the nth 32 bits of KEY4. (RO)

Register 16.22: EFUSE_RD_KEY5_DATA”_REG (7: 0-7) (0x013C+4*n)

Ce
Ss

é
Kae

&

[a |

| 0x000000 | Reset

 

 

 

EFUSE_KEY5 DATA” Stores the nth 32 bits of KEYS. (RO)

Register 16.23: EFUSE_RD_SYS_DATA_PART2_n_REG (7: 0-7) (0x015C+4*/)

<7
oO
&

[ “|

| 0x000000 | Reset

 

 

 

EFUSE SYS _ DATA PART2_” Stores the nth 82 bits of the 2nd part of system data. (RO)

Espressif Systems 832 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.24: EFUSE_RD_REPEAT_ERRO_REG (0x017C)

 

 

 

<
S ge
ge ge
eS SF Sd <
$F SEF S&S se s SIGE SF
SPS. SER’ Soro Erk” SDE LF
SOS PELE ERIKS’
SF KEP Vor ERE EEL QOS &
ROK) WP BOE D7 FOS SE NG” ¢
Foes SOC EF LOLP LIE ”
s PEP ps SESE LLL KKK KY’ o
2 x7 x’ XY’, Ky’ i XY’, XY’, XY’, XY’, x7 XY, x7 XY’, x7 XY’, x7 XY’, Ky’ x’
NN & SSFP PO FOP POP? 2
€ E ESS & ESES ESS SES SESS &
[a1 29 | 28 2r| 26 | 25 | 2 [2s ~f9fasfa fo lelu]sfelulfol ee] fe o|
[o 0 o| oxo | 0] 0] 0 [o 0 0 ofofofofofofofofofofofo]ofo] Ox0 |Reset

 

EFUSE RD_DIS_ERR Any bit equal to 1 denotes a programming error in EFUSE_RD_DIS. (RO)

EFUSE DIS_RTC_RAM_BOOT_ERR Any bit equal to 1 denotes a programming error in
EFUSE_DIS_RTC_RAM_BOOT. (RO}

EFUSE DIS_ICACHE ERR Any bit equal to 1 denotes a programming error in EFUSE_DIS_ICACHE.
(RO)

EFUSE DIS DCACHE_ERR Any bit equal to 1 denotes a _ programming error in
EFUSE_DIS_DCACHE. (RO)

EFUSE DIS DOWNLOAD _ICACHE_ERR Any bit equal to 1 denotes a programming error in
EFUSE_DIS_DOWNLOAD_ICACHE. (RO)

EFUSE DIS DOWNLOAD DCACHE ERR Any bit equal to 1 denotes a programming error in
EFUSE_DIS_ DOWNLOAD _DCACHE. (RO)

EFUSE DIS FORCE DOWNLOAD ERR Any bit equal to 1 denotes a programming error in
EFUSE_DIS_FORCE_DOWNLOAD. (RO)

EFUSE DIS _USB_ERR Any bit equal to 1 denotes a programming error in EFUSE_DIS_USB. (RO)
EFUSE DIS_CAN_ERR Any bit equal to 1 denotes a programming error in EFUSE_DIS_CAN. (RO)

EFUSE DIS BOOT_REMAP_ERR Any bit equal to 1 denotes a programming error in
EFUSE_DIS_BOOT_REMAP. (RO)

EFUSE RPT4_RESERVED5 ERR Any bit equal to 1 denotes a programming error in
EFUSE_RPT4_RESERVEDS. (RO)

EFUSE SOFT_DIS_ JTAG_ERR Any bit equal to 1 denotes a programming error in
EFUSE_SOFT_DIS_JTAG. (RO)

EFUSE HARD DIS JTAG_ERR Any bit equal to 1 denotes a programming error in
EFUSE_HARD_DIS_JTAG. (RO)

Continued on the next page...

Espressif Systems 833 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.24: EFUSE_RD_REPEAT_ERRO_REG (0x017C)

Continued from the previous page...

EFUSE DIS DOWNLOAD MANUAL_ENCRYPT_ERR Any bit equal to 1 denotes a programming
error in EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT. (RO)

EFUSE USB_EXCHG PINS ERR Any bit equal to 1 denotes a programming error in
EFUSE_USB_EXCHG_PINS. (RO)

EFUSE EXT PHY ENABLE ERR Any bit equal to 1 denotes a programming error in
EFUSE_EXT_ PHY ENABLE. (RO)

EFUSE USB_FORCE_NOPERSIST_ERR Any bit equal to 1 denotes a programming error in
EFUSE_USB_FORCE_NOPERSIST. (RO)

EFUSE RPT4_RESERVEDO ERR Any bit equal to 1 denotes a programming error in
EFUSE_RPT4_RESERVEDO. (RO)

Espressif Systems 834 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.25: EFUSE_RD_REPEAT_ERR1_REG (0x0180)

 

 

SVM
Vv SOS
MNS
os oo &
g & BEY LS
$ SF CES SF oF Ske
Ky <7 RA RAR? a ae S& 4 g
P en LPP KF KOO’
g g gy Ay Ae v8
Ne Ne LEK’ OP > Voge’
we LS SOS oF SL SO
¥ SEE AF SS S ge S
S SK SES SK OS S SES s
& & ESS & & SSS ©
31 28 | 27 24) 23 22 21 | 20 18} 17 16} 15 7 6 5 4 3 o
Ox0 Ox0 olo]o Ox0 oo Jo o 0 0 0 0 0 0 Ofolololo o 0c OlReset

 

 

 

 

 

 

 

 

 

 

 

 

 

 

EFUSE VDD_SPI_XPD_ERR Any bit equal to 1 denotes a programming error in
EFUSE_VDD_SPI_XPD. (RO)

EFUSE VDD_SPI_TIEH_ERR Any bit equal to 1 denotes a programming error in
EFUSE_VDD_SPI_TIEH. (RO)

EFUSE VDD_SPI_FORCE_ERR Any bit equal to 1 denotes a programming error in
EFUSE_VDD_SPI|_FORCE. (RO)

EFUSE_ WDT_DELAY SEL ERR Any bit equal to 1 denotes a programming error in
EFUSE_WDT_DELAY_SEL. (RO)

EFUSE SPI_BOOT_CRYPT_CNT_ERR Any bit equal to 1 denotes a programming error in
EFUSE_SPI_BOOT_CRYPT_CNT. (RO)

EFUSE SECURE BOOT_KEY REVOKEO_ERR Any bit equal to 1 denotes a programming error in
EFUSE_SECURE_BOOT_KEY_REVOKEO. (RO)

EFUSE SECURE BOOT _KEY REVOKE1_ERR Any bit equal to 1 denotes a programming error in
EFUSE_ SECURE BOOT _KEY_REVOKE1. (RO)

EFUSE SECURE BOOT _KEY REVOKE2_ERR Any bit equal to 1 denotes a programming error in
EFUSE_ SECURE BOOT _KEY_REVOKE2. (RO)

EFUSE KEY PURPOSE 0 ERR Any bit equal to 1 denotes a programming error in
EFUSE_KEY_PURPOSE_0. (RO)

EFUSE KEY PURPOSE _1_ERR Any bit equal to 1 denotes a programming error in
EFUSE_KEY_PURPOSE_1. (RO)

Espressif Systems 3835 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.26: EFUSE_RD_REPEAT_ERR2_REG (0x0184)

 

 

 

 

 

 

 

 

 

 

 

 

 

&
&
S
&
we
S
Ok
$ KS g g g g
< v7 ee’ ¥Y ¥ gy
Y & KARA 3 ge go gh
sy & Poh ce ce eS eS
Q S Xe § g g g
GF KK? Ss Ss Ss Fs
Qy SS SK ¢ ¢ g g
x 0 a“ A? A? “WP
wv é SS» ¢ ¢ &
x? x? M7 KY we xX 7 7 x7
S ws Sos & S S ws ws
é g SSS g g g g
31 28 | 27 22) 21 20 | 19 16 | 15 12] 11 B17 4/3 0
oxo oxo of/olo 0 90 0 oxo oxo oxo oxo Reset
EFUSE KEY PURPOSE 2 ERR Any bit equal to 1 denotes a programming error in
EFUSE_KEY_PURPOSE_2. (RO)
EFUSE KEY PURPOSE 3 ERR Any bit equal to 1 denotes a programming error in
EFUSE_KEY_PURPOSE_3. (RO)
EFUSE KEY PURPOSE 4 ERR Any bit equal to 1 denotes a programming error in
EFUSE_KEY_PURPOSE_4. (RO)
EFUSE KEY PURPOSE 5 ERR Any bit equal to 1 denotes a programming error in
EFUSE_KEY_PURPOSE_5. (RO)
EFUSE SECURE BOOT_EN ERR Any bit equal to 1 denotes a programming error in
EFUSE_ SECURE BOOT _EN. (RO)
EFUSE SECURE BOOT_AGGRESSIVE REVOKE _ERR Any bit equal to 1 denotes a programming
error in EFUSE_SECURE_BOOT_AGGRESSIVE_REVOKE. (RO)
EFUSE_ RPT4_RESERVED1 ERR Any bit equal to 1 denotes a programming error in
EFUSE_RPT4_RESERVED1. (RO)
EFUSE FLASH _TPUW_ERR Any bit equal to 1 denotes a programming error in
EFUSE_FLASH_TPUW. (RO)
Espressif Systems 836 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

Register 16.27: EFUSE_RD_REPEAT_ERR3_REG (0x0188)

& &
or S
Ss S
S SN
QB ee
ao )
g S
& &
we Or
&§ &§

 

“Pl E

ele Te}=]}e]: [2]

 

Espressif Systems

Ox0 | Ox00

[o[o[o] oo [o[o]o]ofo]o ]reset

EFUSE DIS DOWNLOAD MODE _ERR Any bit equal to 1 denotes a programming error in

EFUSE_DIS_DOWNLOAD_MODE. (RO)

EFUSE DIS _ LEGACY SPILBOOT_ERR Any bit equal to 1 denotes a programming error in

EFUSE_DIS_LEGACY_SPI_BOOT. (RO)

EFUSE UART_PRINT_CHANNEL_ERR Any bit equal to 1 denotes a programming error in

EFUSE_UART_PRINT_CHANNEL. (RO)

EFUSE_RPT4_RESERVED3_ERR Any bit
EFUSE_RPT4_RESERVEDS. (RO)

equal to

denotes a programming error in

EFUSE DIS USB_DOWNLOAD MODE_ERR Any bit equal to 1 denotes a programming error in

EFUSE_DIS_USB_DOWNLOAD_MODE. (RO)

EFUSE_ENABLE_SECURITY_DOWNLOAD_ERR Any bit equal to 1 denotes a programming error

in EFUSE_ENABLE_SECURITY_DOWNLOAD. (RO)

EFUSE UART_PRINT_CONTROL_ERR Any bit equal to 1 denotes a programming error in

EFUSE_UART_PRINT_CONTROL. (RO)

EFUSE PIN_POWER_SELECTION_ERR Any bit equal to 1 denotes a programming error in

EFUSE_PIN_POWER_SELECTION. (RO)

EFUSE_FLASH_TYPE_ERR Any bit
EFUSE_FLASH_TYPE. (RO)

equal to 1

denotes a

programming error in

EFUSE FORCE_SEND_ RESUME ERR Any bit equal to 1 denotes a programming error in

EFUSE_FORCE_SEND_RESUME. (RO)

EFUSE_SECURE_VERSION_ERR Any bit
EFUSE_SECURE_VERSION. (RO)

equal to

EFUSE_RPT4_RESERVED2_ERR Any bit
EFUSE_RPT4_RESERVEDZ2. (RO)

equal to

337

denotes a programming error in

denotes a programming error in

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

Register 16.28: EFUSE_RD_REPEAT_ERR4_REG (0x0190)

 

 

&
oy
eo
S
SE
Se
xy
& &
& ws
€ &
31 24 | 23 oO
o 0 0 0 0 0 0 0 0x0000 Reset

 

 

 

 

EFUSE_RPT4 RESERVED4 ERR ff any bitin RPT4_RESERVED4 is 1, there is a programming error
in EFUSE_RPT4_RESERVED4. (RO)

Register 16.29: EFUSE_RD_RS_ERRO_REG (0x01 C0)

 

 

 

Ss =
Vv So
SF SF FS SE CXS SS
VSM SM EY ES EF EF SE EL &
7 7 7 7 7 7 7 \7 $ O7 g 7 7
SK LS KF SS LK & xe Me x SK LK HK LK
[ st [20 28 ar [26 x] 2 | 2 20 1 [1 t6[ 15 [1s 2 u [10 a7 |e «[ 3 [2 o|
[o| x0 [o| x0 [o| x0 [o] x0 [o] Ox [o] x0 [o] x0 [o | x0 |Reset

 

EFUSE MAC SPI_8M_ERR_NUM The value of this signal means the number of error bytes in
BLOCK1. (RO)

EFUSE_MAC_SPI_8M_FAIL 0: Means no failure and that the data of BLOCK1 is reliable; 1: Means
that programming BLOCK1 data failed and the number of error bytes is over 5. (RO)

EFUSE SYS _PART1_NUM The value of this signal means the number of error bytes in BLOCK2.
(RO)

EFUSE_SYS_ PART1_FAIL 0: Means no failure and that the data of BLOCK2 is reliable; 1: Means
that programming BLOCk2 data failed and the number of error bytes is over 5. (RO)

EFUSE USR_DATA_ERR_NUM The value of this signal means the number of error bytes in BLOCKS.
(RO)

EFUSE_USR_DATA_FAIL 0: Means no failure and that the data of BLOCKS is reliable; 1: Means that
programming BLOCKS data failed and the number of error bytes is over 5. (RO)

EFUSE_ KEYn_ERR_NUM The value of this signal means the number of error bytes in KEYn. (RO)

EFUSE_KEYn_FAIL 0: Means no failure and that the data of KEYn is reliable; 1: Means that program-
ming KEYn failed and the number of error bytes is over 5. (RO)

Espressif Systems 838 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.30: EFUSE_RD_RS_ERR1_REG (0x01C4)

 

 

 

 

EFUSE KEY5 ERR_NUM The value of this signal means the number of error bytes in KEY5. (RO)

EFUSE_KEY5 FAIL 0: Means no failure and that the data of KEY5 is reliable; 1: Means that pro-
gramming user data failed and the number of error bytes is over 5. (RO)

EFUSE SYS _PART2_ERR_NUM The value of this signal means the number of error bytes in
BLOCK10. (RO)

EFUSE_SYS_ PART2_FAIL 0: Means no failure and that the data of BLOCK10 is reliable; 1: Means
that programming BLOCK10 data failed and the number of error bytes is over 5. (RO)

Register 16.31: EFUSE_CLK_REG (0x01 C8)

> » > SOS
~ ae s SIS
& & & LS

[1 7] 16 [is 3

 

 

|
[o 0 0 9 0 0 9 9 0 0 0 0 0 9 ofofo 0 0 0 0 9 9 9 0 0 9 Oo Ofo

 

EFUSE_EFUSE_MEM_FORCE_PD If set, forces eFuse SRAM into power-saving mode. (RAV)
EFUSE MEM _CLK_FORCE_ON If set, forces to activate clock signal of eFuse SRAM. (RAW)
EFUSE_EFUSE_MEM_FORCE_PU If set, forces eFuse SRAM into working mode. (R/V)

EFUSE_CLK_EN If set, forces to enable clock signal of eFuse memory. (RAV)

Espressif Systems 839 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.32: EFUSE_CONF_REG (0x01CC)

 

 

 

x
Q
Oo
> g
& &
[a1 16 [5 o|
[o 0000000000000 0 | Ox0O |Reset

 

EFUSE_ OP_CODE O0x5A5A: Operate programming command; Ox5AA5: Operate read command.

 

 

 

 

 

 

 

 

(RW)
Register 16.33: EFUSE_CMD_REG (0x01D4)
©
Ss of o
5 Bes
we Bw’ MS’
ES & OLS
E ac Pe
joo 0 0900000000909 090000900 0 9] Oxo [0 | © |Reset
EFUSE READ CMD Set this bit to send read command. (RW)
EFUSE PGM_CMD Set this bit to send programming command. (R/W)
EFUSE_ BLK_NUM The serial number of the block to be programmed. Value 0-10 corresponds to
block number 0-10, respectively. (R/W)
Register 16.34: EFUSE_DAC_CONF_REG (0x01E8)
&
o 3
S Ss ow sv’
“7 Ww Ww Ww
S oO
w x & & &
& S S & S
[1 [17 [1s of e |r o|
[o0 0 9 0 0 0 00000 0 oof 255 [o| 28 |Reset
EFUSE DAC _CLK_DIV Controls the division factor of the rising clock of the programming voltage.
(RW)
EFUSE DAC _CLK_PAD SEL Don’t care. (RAV)
EFUSE DAC NUM Controls the rising period of the programming voltage. (R/W)
EFUSE OE CLR Reduces the power supply of the programming voltage. (R/V)
Espressif Systems 340 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

Register 16.35: EFUSE_STATUS_REG (0x01 DO)

 

 

 

s
s
A?
sx” &
& & & &
[1 [17 1o[» [s o|
jo 0 0 9 0 0 9 00000 0 Of Oxo jo 9 9 0 0 of Oxo |Reset

 

EFUSE STATE Indicates the state of the eFuse state machine. (RO)

EFUSE REPEAT ERR_CNT Indicates the number of error bits during programming BLOCKO. (RO)

Register 16.36: EFUSE_INT_RAW_REG (0x01D8)

 

 

 

 

se
DX
Ks
LQ?
‘ aes
sf SS
Ce OLS
[z Lf]
joo 0 0 0000090000009 0090000009 00 0 0 0 0 0[0][0 Reset
EFUSE READ DONE_INT_RAW The raw bit signal for read_done interrupt. (RO)
EFUSE_PGM_DONE_INT_RAW The raw bit signal for pgm_cone interrupt. (RO)
Register 16.37: EFUSE_INT_ST_REG (0x01DC)
AS
9 4
sess
; ae
we Siw
& OS

 

[z Lf]

joo 0 0 0000090000009 0090000009 00 0 0 0 0 0[0][0 Reset

 

 

EFUSE READ DONE_INT_ST The status signal for read_cone interrupt. (RO)

EFUSE PGM_DONE_INT_ST The status signal for pgm_cone interrupt. (RO)

Espressif Systems 341 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.38: EFUSE_INT_ENA_ REG (0x01E0)

 

 

 

 

 

 

 

 

ee
See
oe
oS
a
& ee
XS
& SS
31 2 1 0
00000000000 00000000000 0 0 0 0 0 0 0 0] 0] 0 IReset
EFUSE READ DONE_INT_ENA The enable signal for read_done interrupt. (RAM)
EFUSE_ PGM_DONE_INT_ENA The enable signal for pgm_done interrupt. (R/V)
Register 16.39: EFUSE_INT_CLR_REG (0x01E4)
Ke
s“s
&
& SS
€ SS
[1 2 1 0 |

 

 

 

EFUSE READ DONE_INT_CLR The clear signal for read_cone interrupt. (WO)

EFUSE_PGM_DONE_INT_CLR The clear signal for pgm_done interrupt. (WO)

Register 16.40: EFUSE_RD_TIM_CONF_REG (0x01EC)

 

 

RN
Ss
> Ps
& & & we
£ ea SL ge
& & & &

31 24 | 23 16] 15 el7 oO

Ox12 Ox1 Ox1 Ox1 Reset

 

 

 

 

 

 

EFUSE_ THR_A Configures the hold time of read operation. (RAV)
EFUSE TRD Configures the length of pulse of read operation. (RAM)
EFUSE_TSUR_A Configures the setup time of read operation. (R/V)

EFUSE READ _INIT.NUM Configures the initial read time of eFuse. (RAV)

Espressif Systems 842 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
16. eFuse Controller

 

Register 16.41: EFUSE_WR_TIM_CONFO_REG (0x01 FO)

 

 

 

a
ss Ss e
& & Xe
& & &
31 16] 15 el7 oO
| | | |
| Oxc8 | Ox | Ox |Reset

 

EFUSE _THP_A Configures the hold time of programming operation. (RAW)
EFUSE TPGM_INACTIVE Configures the length of pulse during programming O to eFuse. (RAV)

EFUSE_ TPGM Configures the length of pulse during programming 1 to eFuse. (RAW)

Register 16.42: EFUSE_WR_TIM_CONF1_REG (0x01 F4)

 

 

 

Ss
sv
oO
7 Q 7
> & &
x Koa we
€ & &
| 31 24 | 23 8 | 7 9 |
| 0x2880 | oxt |Reset

 

EFUSE TSUP_A_ Configures the setup time of programming operation. (RAM)

EFUSE_ PWR_ON_NUM Configures the power up time for VDDQ. (R/W)

Register 16.43: EFUSE_WR_TIM_CONF2_REG (0x01 F8)

 

 

 

 

>
<S
ee
& s
S
& &
[a1 16 [is o|
fo0 9 00009000000 0 0 9 0x190 |Reset
EFUSE_ PWR_OFF_NUM Configures the power outage time for VDDQ. (RAW)
Espressif Systems 343 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
16. eFuse Controller

 

Register 16.44: EFUSE_DATE_REG (0x01FC)

 

 

 

 

&
Koa
&
[2 |
| 0x19081 100 |Reset
EFUSE DATE Version control register. (R/W)
Espressif Systems 344 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
17. 2C Controller

 

17. l?C Controller

17.1 Overview
The [2C (Inter-Integrated Circuit) controller allows ESP32-S2 to communicate with multiple peripheral devices.
These peripheral devices can share one bus.

17.2 Features

The [2C controller has the following features:
* Master mode and slave mode
© Multi-master and multi-slave communication
® Standard mode (100 kbit/s)
* Fast mode (400 kbit/s)
° 7-bit addressing and 10-bit addressing
* Continuous data transfer in master mode achieved by pulling SCL low
* Programmable digital noise filtering

* Double addressing mode

17.3. l?C Functional Description

17.3.1 [?C Introduction

The [2C bus has two lines, namely a serial data line (GDA) and a serial clock line (SCL). Both SDA and SCL lines
are open-drain. The I?C bus is connected to multiple devices, usually a single or multiple masters and a single or
multiple slaves. However, only one master cevice can access a slave at a time.

The master initiates communication by generating a start condition: pulling the SDA line | ow while SCL is high,
and sending nine clock pulses via SCL. The first eight pulses are used to transmits a byte, which consists of a
7-bit address followed by a read/write (R/T) bit. If the address of a slave matches the 7-bit address transmitted,
this matching slave can respond by pulling SDA low on the ninth clock pulse. The master and the slave can send
or receive data according to the R/W bit. Whether to terminate the data transfer or not is determined by the
logic level of the acknowledge (ACk) bit. During data transfer, SDA changes only when SCL is low. Once finishing
communication, the master sends a STOP condition: pulling SDA up while SCL is high. If a master both reads
and writes data in one transfer, then it should send a RESTART condition, a slave address and a R/W bit before
changing its operation.

Espressif Systems 345 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

17.3.2 |?C Architecture

 

 

12C_TRANS_START |

 

 

 

cm

do

 

cm

di

 

 

emd_rd

 

 

 

emd15

cmd_done

 

 

 

; emd_content

 

 

GMD_Controller

 

 

 

SCL_LOW_PERIOD
SCL_HIGH_PERIOD
SCL_WAIT_HIGH_PERIOD

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

    
 

 

 

 

 

 

 

 

 

 

 

 

 

 

rdata/wdata

 

 

 

 

 

 

l2¢_RX_LSB_FIRST
I2C_TX_LSB_FIRST

 

 

 

 

 

 

 

l12¢_SDA_FILTER_THRES

 

 

 

12C_SDA_FILTER_EN

 

.

(| SCL_FSM| SCLC
32x8bits
TX RAM AW *'SCL_MAIN_FSM
APB BUS
OO
32x8bits
»| DATAShifter «SPA _,
RX RAM rdata/wdata
12C_RX_LSB_FIRST
12C_TX_LSB_FIRST
Figure 17-1. I? Master Architecture

SCL_LOW_PERIOD

SCL_HIGH_PERIOD 12C_SCL_FILTER_EN
on

SCL_FSM <—_ l2C_SCL_FILTER_THRES
32x8bits 12C_SAMPLE_SCL_LEVEL
rw. | SCL_MAIN_FSM}«—
APB BUS Xx RAM SCL_Filter
Start_Detect
SDA
Sxsts SDA Filter
RX RAM DATA_Shifter |__|

 

 

 

The [2C controller runs either in master mode or slave mode, which is determined by I2C_MS_MODE bit. Figure
17-1 shows the architecture of a master, while Figure 17-2 shows that of a slave. The I?C controller has the
following main parts: transmit and receive memory (TX/RX RAM), command controller (CMD_Controller), SCL

Figure 17-2. l?C Slave Architecture

clock controller (S@CL_FSM), SDA data controller (SCL_MAIN_FSM), serial-to-parallel data converter
(DATA. Shifter), filter for SCL (SCL_Filter) and filter for SDA (SDA _Filter).

Espressif Systems

346

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
17. 2C Controller

 

17.3.2.1 TX/RX RAM

Both TX RAM and RX RAM are 82 x 8 bits. TX RAM stores data that the l?C controller needs to send. During
communication, when the I?C controller needs to send data (except acknowledgement bits), it reads data from
TX RAM and sends it sequentially via SDA. When the |2?C controller works in master mode, all data must be
stored in TX RAM in the order they will be sent to slaves. The data stored in TX RAM include slave addresses,
read/write bits, register addresses (only in dual addressing mode) and data to be sent. When the [@C controller
works in slave mode, TX RAM only stores data to be sent.

RX RAM stores data the |?C controller receives during communication. When the l?C controller works in slave
mode, neither slave addresses sent by the master nor register addresses (only in double addressing mode} will
be stored into RX RAM. Values of RX RAM can be read by software after 2C communication completes.

Both TX RAM and RX RAM can be accessed in FIFO or non-FIFO mode. The |2C_NONFIFO_EN bit sets FIFO or
non-FIFO mode.

TX RAM can be read and written by the CPU. The CPU writes to TX RAM either in FIFO mode or in non-FIFO
mode (direct address). In FIFO mode, the CPU writes to TX RAM via fixed address |I2C_DATA_REG, with
addresses for writing in TX RAM incremented automatically by hardware. In non-FIFO mode, the CPU accesses
TX RAM directly via address fields (I2@C Base Address + 0x100) ~(l?C Base Address + 0x17C). Each byte in TX
RAM occupies an entire word in the address space. Therefore, the address of the first byte is 2C Base Address +
0x100, the second byte I?C Base Address + 0x104, the third byte I?C Base Address + 0x108, and so on. The
CPU can only read TX RAM via direct addresses. Unlike addresses for writing, TX RAM must be read back from
addresses starting at l°C Base Address + 0x80.

RX RAM can only be read by the CPU. The CPU reads RX RAM either in FIFO mode or in non-FIFO mode (direct
address). In FIFO mode, the CPU reads RX RAM via fixed address I2C_DATA_REG, with addresses for reading
RX RAM incremented automatically by hardware. In non-FIFO mode, the CPU accesses TX RAM directly via
address fields (2?C Base Address + 0x100) ~(l?C Base Address + 0x17C). Each byte in RX RAM occupies an
entire word in the address space. Therefore, the address of the first byte is 2?C Base Address + 0x100, the
second byte l?C Base Address + 0x104, the third byte I?C Base Address + 0x108 and so on.

Given that addresses for writing to TX RAM have an identical range with those for reading RX RAM, TX RAM and
RX RAM can be seen as a 82 x 8 RAM. In following sections TX RAM and RX RAM are referred to as RAM.

17.3.2.2 CMD_Controller

] When the I2C controller works in master mode, the integrated CMD_Controller module reads commands from
16 sequential command registers and controls SCL_FSM and SDA_FSM accordingly.

 

 

 

31 30:14 13:11 10 9 8 7:0
cmdQ | CMD_DONE N/A | op_code | ack_value | ack_exp lack_check_en byte_num

31 30:14 13:11 10 9 8 7:0
cmd15 | CMD_DONE N/A op_code | ack_value | ack_exp lack_check_en byte_num

 

Figure 17-3. Structure of I?C Command Register

Command registers, whose structure is illustrated in Figure 17-3, are active only when the |?C controller works in

Espressif Systems 347 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

master mode. Fields of command registers are:

1. CMD_DONE: Indicates that a command has been executed. After each command has been executed, the
corresponding CMD_DONE bit is set to 1 by hardware. By reading this bit, software can tell if the
command has been executed. When writing new commands, this bit must be cleared by software.

2. op_code: Indicates the command. The |?C controller supports five commands:

RSTART: op_code = 0: The |?C controller sends a START bit and a RESTART bit defined by the 2C
protocol.

WRITE: op_code = 1: The |?C controller sends a slave address, a register address (only in double
addressing mode) and data to the slave.

READ: op_code = 2: The I?C controller reads data from the slave.

STOP: op_code = 3: The I2?C controller sends a STOP bit defined by the I?C protocol. This code also
indicates that the command sequence has been executed, and the CMD_Controller stops reading
commands. After restarted by software, the CMD_Controller resumes reading commands from
command register 0.

END: op_code = 4: The I?C controller pulls the SCL pin down and suspends l2C communication. This
code also indicates that the command sequence has completed, and the CMD_Controller stops
executing commands. Once software refreshes data in command registers and the RAM, the
CMD_Controller can be restarted to execute commands from command register 0 again.

3. ack_value: Used to configure the level of the ACK bit sent by the l?C controller during a read operation.
This bit is ignored during RSTART, STOP, END and WRITE conditions.

4. ack_exp: Used to configure the level of the ACK bit expected by the l2C controller during a write operation.
This bit is ignored during RSTART, STOP, END and READ conditions.

5. ack_check_en: Used to enable the l2C controller during a write operation to check whether ACK’s level
sent by the slave matches ack_exp in the command. If this bit is set and the level received does not match
ack_exp in the WRITE command, the master will generate an 12C_NACK_INT interrupt and a STOP
condition for data transfer. If this bit is cleared, the controller will not check the ACK level sent by the slave.
This bit is ignored during RSTART, STOP, END and READ conditions.

6. byte_num: Specifies the length of data (in bytes) to be read or written. Can range from 1 to 255 bytes. This
bit is ignored during RSTART, STOP and END conditions.

Each command sequence is executed starting from command register 0 and terminated by a STOP or an END.
Therefore, all 16 command registers must have a STOP or an END command.

A complete data transfer on the l2?C bus should be initiated by a START and terminated by a STOP. The transfer
process may be completed using multiple sequences, separated by END commands. Each sequence may differ
in the direction of data transfer, clock frequency, slave addresses, data length, data to be transmitted, etc. This
allows efficient use of available peripheral RAM and also achieves more flexible I2?C communication.

17.3.2.3 SCL_FSM

The integrated SCL_FSM module controls the SCL clock line. The frequency and duty cycle of SCL is configured
using I2C_SCL_LOW_PERIOD_REG, |2C_SCL_HIGH_PERIOD_REG and I2C_SCL_WAIT_HIGH_PERIOD. After

Espressif Systems 348 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

being in non-IDLE state for over |2C_SCL_ST_TO clock cycles, SCL_FSM triggers an I2C_SCL_ST_TO_INT
interrupt and returns to IDLE state.

17.3.2.4 SCL_MAIN_FSM

The integrated SCL_MAIN_FSM module controls the SDA data line and data storage. After being in non-IDLE
state for over I2C_SCL_MAIN_ST_TO clock cycles, SCL_MAIN_FSM triggers an I2C_SCL_MAIN_ST_TO_INT
interrupt and returns to IDLE state.

17.3.2.5 DATA_Shifter

The integrated DATA_Shifter module is used for serial/parallel conversion, converting TX RAM byte data to an
outgoing serial bitstream or an incoming serial bitstream to RX RAM byte data. I2C_RX_LSB_FIRST and
|2C_TX_LSB_FIRST can be used to select LSB- or MSB-first storage and transmission of data.

17.3.2.6 SCL_Filter and SDA_Filter

The integrated SCL_Filter and SDA_Filter modules are identical and are used to filter signal noises on SCL and
SDA, respectively. These filters can be enabled or disabled by configuring I2C_SCL_FILTER_EN and
12C_SDA_FILTER_EN.

SCL_Filter samples input signals on the SCL line continuously. These input signals are valid only if they remain
unchanged for consecutive I2C_SCL_FILTER_THRES clock cycles. Given that only valid inout signals can pass
through the filter, SCL_Filter can remove glitches whose pulse wicth is lower than I2C_SCL_FILTER_THRES APB
clock cycles.

SDA Filter is identical to SCL_Filter, only applied to the SDA line. The threshold pulse width is provided in the
12C_SDA_FILTER_THRES register.

17.3.3 |l?C Bus Timing
The [2C controller may use APB_CLK or REF_TICK as its clock source. When I2C_REF_ALWAYS_ON is 1,
APB_CLK is used; when I2C_REF_ALWAYS_ON is 0, REF_TICK is used.

 

SCL_LOW_PERIOD SCL_RSTART_SETUP_TIME STOP_SETUP_TIME
—* | ' tot ' ' a i ' '

—

       

tot t

SCL.WAITHIGH_PERIOD! SCL_HIGH PERIOD | SCL_START_HOLD_TIME STOP_HOLD_TIME

—- | i |

SDA

 

   

<> | os —
‘| SDA_START_HOLD_TIME '  “$DASAMPLE_TIME = SDA_HOLD_TIME nia
START ACK STOP

 

 

 

Figure 17-4. l?C Timing Diagram

Figure 17-4 shows the timing diagram of an I2?C master. The unit of parameters in this figure is I2C_CLK
(Trac_CLK). Specifically, when I2C_REF_ALWAYS_ON = 1, Trac CLK is TaPB CLK: when

Espressif Systems 349 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

12C_REF_ALWAYS_ON = 0, Trac_cxx iS Trer ricK. Figure 17-4 also specifies registers used to configure the
START bit, STOP bit, data hold time, data sample time, waiting time on the rising SCL edge, etc. Parameters in
Figure 17-4 are described as the following:

1. l2C_SCL_START_HOLD_TIME: Specifies the interval between pulling SDA low and pulling SCL low when
the master generates a START condition. This interval is (I2C_SCL_START_HOLD_TIME +1) x Tree exK.
This register is active only when the I2?C controller works in master mode.

2. |2C_SCL_LOW_PERIOD: Specifies the low period of SCL. This period lasts (l2C_SCL_START_HOLD_TIME
+1) x Trac etx. However, it could be extended when SCL is pulled low by peripheral devices or by an
END command executed by the |?C controller, or when the clock is stretched. This register is active only
when the [2C controller works in master mode.

8. 12C_SCL_WAIT_HIGH_PERIOD: Specifies time for SCL to go high in Trac crx. Please make sure that
SCL will be pulled high within this time period. Otherwise, the high period of SCL may be incorrect. This
register is active only when the I2?C controller works in master mode.

4, 12C_SCL_HIGH_PERIOD: Specifies the high period of SCL in Trac_exix. This register is active only when
the l?C controller works in master mode. When SCL goes high within (2C_SCL_WAIT_HIGH_PERIOD + 1)
x Trec_cxiK, its frequency is:

fi2zc_cLK
I2C_SCL_LOW_PERIOD + 1 + 12C_SCL_HIGH_PERIOD + |2C_SCL_WAIT_HIGH_PERIOD

 

fet =

5. 12C_SDA_SAMPLE_TIME: Specifies the interval between the rising edge of SCL and the level sampling
time of SDA. It is advised to set a value in the middle of SCL’s high period. This register is active both in
master mode and slave mode.

6. 12C_SDA_HOLD_TIME: Specifies the interval between changing the SDA output level and the falling edge
of SCL. This register is active both in master mode and slave mode.

SCL and SDA output drivers must be configured as open drain. There are two ways to achieve this:

1. Set 12C_SCL_FORCE_OUT and |2C_SDA_FORCE_OUT, and configure GPIO_PIN7_PAD_DRIVER register
for corresponding SCL and SDA pads as open-drain.

2. Clear I2C_SCL_FORCE_OUT and I2C_SDA_FORCE_OUT.

Because these lines are configured as open-drain, the low to high transition time of each line is determined
together by the pull-up resistance and the capacitance on the line. The output frequency of |2C is limited by the
SDA and SCL line’s pull-up speed, mainly SCL’s speed.

In addition, when I2C_SCL_FORCE_OUT and |2C_SCL_PD_EN are set to 1, SCL can be forced low; when
I2C_SDA_FORCE_OUT and I2C_SDA_PD_EN are set to 1, SDA can be forced low.

17.4 Typical Applications
For the convenience of description, I@C masters and slaves in all subsequent figures refer to ESP32-S2 [2C
peripheral controllers. However, these controllers can communicate with any other |?C devices.

Espressif Systems 350 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

17.4.1. An |l?C Master Writes to an |?C Slave with a 7-bit Address in One Command Se-
quence
Master
omd op_code byte_num
onal sor ||
onci_woe | ne
om stop | | | | sch | cave
_ <J——$_ >

 

 

 

 

Figure 17-5. An I2C Master Writing to an I2C Slave with a 7-bit Address

Figure 17-5 shows how an ?C master writes N bytes of data using 7-bit addressing. As shown in figure 17-5, the
first byte in the master’s RAM is a 7-bit slave acldress followed by a R/W bit. When the R/W bit is zero, it
indicates a WRITE operation. The remaining bytes are used to store data ready for transfer. The cmd box
contains related command sequences.

After the command sequence is configured and data in RAM is ready, the master enables the controller and
initiates data transfer by setting I2C_TRANS_START bit. The controller has four steps to take:

1. Wait for SCL to go high, to avoid SCL used by other masters or slaves.
2. Execute a RSTART command and send a START bit.

3. Execute a WRITE command by taking N+1 bytes from the RAM in order and send them to the slave in the
same order. The first byte is the address of the slave.

4. Send a STOP. Once the |2C master transfers a STOP bit, an 12C_TRANS_COMPLETE_INT interrupt is

generated.

lf data to be transferred is larger than 32 bytes, the RAM access will wrap around. While the controller sends
data, software must replace data already sent in RAM. To assist with this process, the master will generate an
12C_TXFIFO_WM_INT interrupt when less than I2C_TXFIFO_WM_THRHD bytes of data remain to be sent.

After detecting this interrupt, software can refresh data in RAM. When the RAM is accessed in non-FIFO mode, in
order to overwrite existing data in the RAM with new ones, software needs to first configure I2C_TX_UPDATE bit
to latch the start address and the end address of data sent in the RAM, and then read |2C_TXFIFO_START_ADDR
and |2C_TXFIFO_END_ADDR field in I2C_FIFO_ST_REG register to obtain these addresses. When the RAM is
accessed in FIFO mode, new data can be written to the RAM directly via 12C_DATA_REG register.

The controller stops executing the command sequence after a STOP command, or when one of the following

two events occurs:

1. When ack_check_en is set to 1, the I?C master checks the ACK value each time it sends a data byte. If the
ACK value received does not match ack_exp (the expected ACK value) in the WRITE command, the master
generates an |2C_NACK_INT interrupt and stops the transmission.

351
Submit Documentation Feedback

Espressif Systems ESP32-S2 TRM (Preliminary V0.4)
17. 2C Controller

 

2. During the high period of SCL, if the input value and the output value of SDA do not match, the l?C master
generates an |2C_ARBITRATION_LOST_INT interrupt, stoos executing the command sequence, returns to
IDLE state and releases SCL and SDA.

Once detecting a START bit sent by the I2C master, the I2C slave receives the address and compares it with its
own address. If the received address does not match I2C_SLAVE_ADDRI6:0], the slave stops receiving data. If
the received address does match |2C_SLAVE_ADDRJ6:0], the slave receives data and stores them into the RAM
in order.

lf data to be transferred is larger than 32 bytes, the RAM may wrap around. While the controller receives data,
software reclaim data already received by the slave. To assist with this process, the master will generate an
12C_RXFIFO_WM_INT after 12C_RXFIFO_WM_THRHD bytes are received in RAM.

Once detecting this interrupt, software can read data from the RAM registers. When the RAM is accessed in
non-FIFO mode, in order to read data, software needs to configure |I2C_RX_UPDATE bit to latch the start
address and the end address of data to be reclaimed, and read |I2C_RXFIFO_START_ADDR and
|2C_RXFIFO_END_ADDR fields in I2C_FIFO_ST_REG register to obtain these addresses. When the RAM is
accessed in FIFO mode, data can be read directly via 12C_DATA_REG register.

17.4.2 An |?C Master Writes to an I2C Slave with a 10-bit Address in One Command

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Sequence
Master
emd op_code byte_num
cma sor | | | |e
Slave
RAM addr0 |(slave_addr_first_7bits<<1| rAw) SDA ddr byted
i = = ‘ , a
addri slave_addr_second_byte addri byte1

 

 

 

 

 

 

 

 

 

 

Figure 17-6. A Master Writing to a Slave with a 10-bit Address

Besides 7-bit addressing (GLV_ADDR|6:0)), the ESP32-S2 |2C controller also supports 10-bit addressing
(SLV_ADDR[9:0)). In the following text, the slave address is referred to as SLV_ADDR.

Figure 17-6 shows how an |?C master writes N-bytes of data using 10-bit addressing. Unlike a 7-bit address, a
10-bit slave address is formed from two bytes. In master mode, the first byte of the slave address, which
comprises slave_addr_first_7bits and a R/W bit, is stored into addr0 in the RAM. slave_addr_first_7bits should
be configured as (Ox78 | SLV_ADDRI9:8])}. The second byte slave_addr_second_byte is stored into addr1 in the
RAM. slave_addr_second_byte should be configured as SLV_ADDR|7:0].

In the slave, the 10-bit addressing mode is enabled by configuring 12C_ADDR_10BIT_EN bit. The address of the
l2?C slave is configured using 12C_SLAVE_ADDR. |2C_SLAVE_ADDR/14:7] should be configured as
SLV_ADDR?:0], and I2C_SLAVE_ADDRJ6:0] should be configured as (0x78 | SLV_ADDR[9:8]). Since a 10-bit
slave address has one more byte than a 7-bit address, byte_num of the WRITE command and the number of
bytes in the RAM increase by one.

Espressif Systems 352 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
17. 2C Controller

17.4.3 An l?C Master Writes to an I2C Slave with Two 7-bit Addresses in One Command
Sequence

 

Master

 

cmd

RAM
add|  {slave_addr<<1| r/w) SDA addrO

 

 

 

 

 

 

 

 

 

addrM| byted

M

Figure 17-7. An |2?C Master Writing Address M in the RAM to an I?C Slave with a 7-bit Address

 

 

 

 

 

 

 

 

 

 

 

 

 

 

When working in slave mode, the controller supports double addressing, where the first address is the address of
an l2?C slave, and the second one is the slave’s memory address. Double addressing is enabled by configuring
|2C_FIFO_ADDR_CFG_EN. When using double addressing, RAM must be accessed in non-FIFO mode. As
figure 17-7 illustrates, the l?C slave put received byteO ~ byte(N-1) into its RAM in an order staring from addrM.
The RAM is overwritten every 32 bytes.

17.4.4 An l?C Master Writes to an IC Slave with a 7-bit Address in Multiple Command
Sequences

 

Master
emd op_code
emdo| ASI

 

i

ema’

emai

S

 

 

 

 

 

 

addi (lave_addr<<i| rAw) SDA addr byted

3

 

 

 

addi

a

 

 

 

 

 

 

 

 

 

I
g
3

addr byte(N-1)

 

 

 

 

Segment0

 

 

 

Master Segmenti
opcode byte_num
emdo| = WRITE M SCL

 

md

 

Slave

 

 

 

RAM
SDA addr(N-1) byte(N-1)

 

 

 

 

addrN) byteN

It

 

 

addr2

ones wows] vem

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Master Segment2

 

 

 

 

 

 

 

 

 

Figure 17-8. An l2?C Master Writing to an l?C Slave with a 7-bit Address in Multiple Sequences

Espressif Systems 353 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Given that the l?C Controller RAM holds only 82 bytes, when cata are too large to be processed even by the
wrapped RAM, it is advised to transmit them in multiple command sequences. At the end of every command
sequence is an END command. When the controller executes this END command to pull SCL low, software
refreshes command sequence registers and the RAM for next the transmission.

Figure 17-8 shows how an |?C master writes to an [2C slave in two or three segments. For the first segment, the
CMD_Controller registers are configured as shown in SegmentO. Once data in the master’s RAM is ready and
|2C_TRANS_START is set, the master initiates data transfer. After executing the END command, the master
turns off the SCL clock and pulls the SCL low to reserve the bus. Meanwhile, the controller generates an
I2C_END_DETECT_INT interrupt.

For the second segment, after detecting the 12C_END_DETECT_INT interrupt, software refreshes the
CMD_Cortroller registers and reloads the RAM and clears this interrupt, as shown in Segment. If cmd in the
second segment is a STOP, then data is transmitted to the slave in two segments. The master resumes cata
transfer after I2C_TRANS_START is set, and terminates the transfer by sending a STOP bit.

For the third segment, after the second data transfer finishes and an I2C_END_DETECT_INT is detected, the
CMD_Controller registers of the master are configured as shown in Segment2. Once I2C_TRANS_START is set,
the master generates a STOP bit and terminates the transfer.

Please note that other l2C masters will not transact on the bus between two segments. The bus is only released
after a STOP signal is sent. To interrupt the transfer, the l?C controller can be reset by setting 12C_FSM_RST at
any time. This register will later be cleared automatically by hardware.

When the master is in IDLE state and I2C_SCL_RST_SLV_EN is set, hardware sends 12C_SCL_RST_SLV_NUM
SCL pulses. I2C_SCL_RST_SLV_EN will later be cleared automatically by hardware.

Note that the operation of other l?C masters and |2C slaves may differ from that of the ESP382-S2 l?C devices.

Please refer to datasheets of specific I2C devices.

17.4.5 An l2C Master Reads an |2C Slave with a 7-bit Address in One Command Se-
quence

 

Master

 

cmd op_code byte_num

emdo|

emdt

 

emd2|

omd3|

 

£
s 5
g

emd4|

 

addr2

 

 

addr0 | (slave_addr<<1| r/w) addrN-1) byte(N-1)

 

 

 

 

 

 

addr1

 

 

addr2

Figure 17-9. An l2C Master Reading an I?C Slave with a 7-bit Address

 

 

 

 

 

 

 

 

 

Figure 17-9 shows how an |?C master reads N bytes of data from an |?C slave using 7-bit addressing. cmd is a
WRITE command, and when this command is executed the master sends a slave address. The byte sent

Espressif Systems 354 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

comprises a 7-bit slave address and a R/W bit. When the R/W bit is 1, it indicates a READ operation. If the
address of an 2C slave matches the sent address, this matching slave starts sending data to the master. The
master generates acknowledgements according to ack_value defined in the READ command upon receiving
every byte.

As illustrated in Figure 17-9, the master executes two READ commands: it generates ACKs for (N-1) bytes of
data in cmd2, and a NACK for the last byte of data in cmd 8. This configuration may be changed as required.
The master writes received data into the controller RAM from addrO, whose original content (a slave address and
a R/W bit) is overwritten by byteO marked red in Figure 17-9.

17.4.6 An l2C Master Reads an I?C Slave with a 10-bit Address in One Command Se-
quence

 

 

 

 

> Slave

 

 

 

 

 

 

 

 

 

RAM
addr | (slave_addr_first_7blts<<1| r/w) SDA addr0 byteD
<]———$$_
addri slave_addr_second_byte addr1 byte1
addr2 byte2 addr2

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 17-10. An I?@ Master Reading an I?C Slave with a 10-bit Address

Figure 17-10 shows how an |2C master reads data from an l?C slave using 10-bit addressing. Unlike 7-bit
addressing, in 10-bit addressing the WRITE command of the IC master is formed from two bytes, and
correspondingly the RAM of this master stores a 10-bit address of two bytes. |I2C_ADDR_10BIT_EN and
|2C_SLAVE_ADDR[14:0] should be set. Please refer to 17.4.2 for how to set this register.

Espressif Systems 355 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

17.4.7 An l2?C Master Reads an |?C Slave with Two 7-bit Addresses in One Command

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Sequence
Master
md op_code byte_num
oo em | td | | se
a Slave
RAM

lag SDA_y, | adiro
_ addr byted
addr |(slave_addr<<1| r/Aw) addr(M+1) byte1
addi /M
addr2 byte2

 

 

 

 

 

 

Figure 17-11. An l2?C Master Reading N Bytes of Data from addrM of an I?C Slave with a 7-bit Address

Figure 17-11 shows how an |2C master reads data from specified addresses in an [2C slave. This procedure is as
follows:

1. Set 12C_FIFO_ADDR_CFG_EN and prepare cata to be sent in the RAM of the slave.
2. Prepare the slave address and register address M in the master.

3. Set 12C_TRANS_START and start transferring N bytes of data in the slave’s RAM starting from address M
to the master.

Espressif Systems 356 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

17.4.8 An l2C Master Reads an I?C Slave with a 7-bit Address in Multiple Command
Sequences

 

Master

 

omd op_code.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

SCL Slave
emda}
RAM
SDA addrd byted
RAM addro |(slave_addr<cl| rw) addr byte!
addri byte1 addr2 a
SegmentoO
Segment
Master
md op_code byte_num
(molt va
oct! mew | | | | gon, || hen) even
cmd2| END/STOP addrN byton
addr2
RAM addr byteN
ccaon-y| omen
asstien| onan enn) teeny |
addr(N+2) byte(N+2)
Master Segment2

 

 

 

md

a

cmd0}

 

 

 

 

Figure 17-12. An l?C Master Reading an I?C Slave with a 7-bit Address in Segments

Figure 17-12 shows how an |2C master reads (N+M) bytes of data from an |?C slave in two/three segments

separated by END commands. Configuration procedures are described as follows:

1. Configure the command register and the RAM, as shown in Segmento.

2. Prepare data in the RAM of the slave, and set |2C_TRANS_ START to start data transfer. After executing the
END command, the master refreshes command registers and the RAM as shown in Segment1, and clears
the corresponding I2C_END_DETECT_INT interrupt. If cmd2 in the second segment is a STOP, then data
is read from the slave in two segments. The master resumes data transfer by setting 12C_TRANS_ START

and terminates the transfer by sending a STOP bit.

3. If cmd2 in Segment is an END, then cata is read from the slave in three segments. After the second data

transfer finishes and an I2C_END_DETECT_INT interrupt is detected, the cmd box is configured as shown
in Segment2. Once I2C_TRANS_START is set, the master terminates the transfer by sending a STOP bit.

17.5 Clock Stretching

In slave mode, the l?C controller can hold the SCL line low in exchange for more processing time. This function
called clock stretching is enabled by setting I2C_SLAVE_SCL_STRETCH_EN bit. The time period of clock

Espressif Systems

357

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
17. 2C Controller

 

stretching is configured by setting I2C_STRETCH_PROTECT_NUM bit. The SCL line will be held low when one
of the following three events occurs:

1.
2.

3.

Finding a match: In slave mode, the address of the l2C controller matches the address sent via the SDA line.
RAM being full: In slave mode, RX RAM of the l2?C controller is full.

Data all sent: In slave mode, TX RAM of the 2C controller is empty.

After SCL has been stretched low, the cause of stretching can be read from I2C_STRETCH_CAUSE bit. Clock
stretching is disabled by setting I2C_SLAVE_SCL_STRETCH_CLR bit.

17.6 Interrupts

I2C_SLAVE_STRETCH_INT: Generated when a slave holds SCL low.
12C_DET_START_INT: Triggered when a START bit is detected.

12C_SCL_MAIN_ST_TO_INT: Triggered when main state machine SCL_MAIN_FSM remains unchanged for
over I2C_SCL_MAIN_ST_TO[28:0] clock cycles.

|2C_SCL_ST_TO_INT: Triggered when state machine SCL_FSM remains unchanged for over
12C_SCL_ST_TO[23:0] clock cycles.

|2C_RXFIFO_UDF_INT: Triggered when the I?C controller receives I2C_NONFIFO_RX_THRES bytes of data
in non-FIFO mode.

|2C_TXFIFO_OVF_INT: Triggered when the I2C controller sends I2C_NONFIFO_TX_THRES bytes of data.

12C_NACK_INT: Triggered when the ACK value received by the master is not as expected, or when the
ACK value received by the slave is 1.

12C_TRANS_START_INT: Triggered when the I?C controller sends a START bit.

12C_TIME_OUT_INT: Triggered when SCL stays high or low for more than I2C_TIME_OUT clock cycles
during data transfer.

12C_TRANS_COMPLETE_INT: Triggered when the |2C controller detects a STOP bit.
12C_MST_TXFIFO_UDF_INT: Triggered when TX FIFO of the master underflows.

12C_ARBITRATION_LOST_INT: Triggered when the SDA's output value does not match its input value while
the master’s SCL is high.

12C_BYTE_TRANS_DONE_INT: Triggered when the |?C controller sends or receives a byte.

12C_END_DETECT_INT: Triggered when op_code of the master indicates an END command and an END
condition is detected.

12C_RXFIFO_OVF_INT: Triggered when Rx FIFO of the 2C controller overflows.

12C_TXFIFO_WM_INT: ?C TX FIFO watermark interrupt. Triggered when I2C_FIFO_PRT_EN is 1 and the
pointers of TX FIFO are less than 12C_TXFIFO_WM_THRHD/4:0].

12C_RXFIFO_WM_INT: I2?C Rx FIFO watermark interrupt. Triggered when I2C_FIFO_PRT_EN is 1 and the
pointers of Rx FIFO are greater than |2C_RXFIFO_WM_THRHD/4:0).

Espressif Systems 358 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
17. 2C Controller

 

17.7 Base Address

Users can access the [?C Controller with base addresses in Table 63. For more information about accessing

peripherals from different buses please see Chapter 1 System and Memory.

Table 63: l2C Controller Base Address

 

 

 

 

 

 

 

Bus to Access Peripheral Base Address
eco PeriBUS1 Ox8F413000

PeriBUS2 0x60013000
ect PeriBUS1 Ox8F427000

PeriBUS2 0x60027000

 

 

 

17.8 Register Summary

Addresses in the following table are relative to |?C base addresses provided in Section 17.7.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access

Timing Register

I2C_SCL_LOW_PERIOD_REG Configures the low level width of the SCL clock | OxO000 | RAV

I2C_SDA_HOLD_REG Configures the hold time after a negative SCL | Ox0030 | RAV
edge

I2C_SDA_SAMPLE_REG Configures the sample time after a positive SCL | 0x0034 | RAV
edge

I2C_SCL_HIGH_PERIOD_REG Configures the high level width of the SCL clock | 0x0038 | RAV

I2C_SCL_START_HOLD_REG Configures the interval between pulling SDA low | 0x0040 | RAV
and pulling SCL low when the master generates
a START condition

I2C_SCL_RSTART_SETUP_REG Configures the interval between the positive | Ox0044 | RAV
edge of SCL and the negative edge of SDA

I2C_SCL_STOP_HOLD_REG Configures the delay after the SCL clock edge | 0x0048 | RAV
for a stop condition

I2C_SCL_STOP_SETUP_REG Configures the delay between the SDA and SCL | 0x004C | RAV
positive edge for a stop condition

12C_SCL_ST_TIME_OUT_REG SCL status time out register Ox0098 | RAV

I2C_SCL_MAIN_ST_TIME_OUT_REG SCL main status time out register Ox009C | RAV

Configuration Register

12C_CTR_REG Transmission setting O0x0004 | RAV

I2C_TO_REG Setting time out control for receiving data Ox000C | RAV

12C_SLAVE_ADDR_REG Local slave address setting O0x0010 | RAV

|2C_FIFO_CONF_REG FIFO configuration register 0x0018 | RAV

12C_SCL_SP_CONF_REG Power configuration register OxO0AO | RAV

12C_SCL_STRETCH_CONF_REG Set SCL stretch of I2C slave OxO0A4 | varies

Status Register

12C_SR_REG Describe I2C work status 0x0008 | RO

|2C_FIFO_ST_REG FIFO status register 0x0014 | varies

12C_DATA_REG RX FIFO read data 0x001C | RO

Espressif Systems 359 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
17. 2C Controller

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
Interrupt Register
I2C_INT_RAW_REG Raw interrupt status 0x0020 | RO
12C_INT_CLR_REG Interrupt clear bits 0x0024 | WO
12C_INT_ENA_REG Interrupt enable bits 0x0028 | RAV
12C_INT_STATUS_REG Status of captured 12C communication events O0x002C | RO
Filter Register
I2C_SCL_FILTER_CFG_REG SCL filter configuration register Ox0050 =| RAV
|2C_SDA_FILTER_CFG_REG SDA filter configuration register 0x0054 | RAV
Command Register
I2C_COMDO_REG |2C command register 0 Ox0058 | RAV
I2C_COMD1_REG |12C command register 1 Ox005C_ | RAV
|2C_COMD2_REG |12C command register 2 Ox0060 | RAV
12C_COMD3_REG 12C command register 3 Ox0064 | RAV
12C_COMD4_REG |2C command register 4 Ox0068 | RAV
I2C_COMD5_REG 12C command register 5 Ox006C_ | RAV
|2C_COMD6_REG |12C command register 6 0x0070 | RAV
I2C_COMD7_REG |2C command register 7 0x0074 | RAV
12C_COMD8_REG |12C command register 8 0x0078 | RAV
I2C_COMD9_REG |12C command register 9 Ox007C | RAV
12C_COMD10_REG 12C command register 10 Ox0080 | RAV
12C_COMD11_REG |12C command register 11 0x0084 | RAV
12C_COMD12_REG |12C command register 12 O0x0088 | RAV
12C_COMD13_REG |2C command register 13 Ox008C | RAV
12C_COMD14_REG |2C command register 14 Ox0090 | RAV
I2C_COMD15_REG 12C command register 15 0x0094 | RAV
Version Register
12C_DATE_REG Version control register OxOOF8 | RAV
17.9 Registers
Register 17.1: 12C_SCL_LOW_PERIOD_REG (0x0000)
se
x
> ow
é Ss

 

E

«| 13

 

fo 0 0 090000000000 00 0 9

0x00

| Reset

 

I2C_SCL_LOW_PERIOD This register is used to configure for how long SCL remains low in master

mode, in I2C module clock cycles. (R/W)

Espressif Systems

Submit Documentation Feedback

360

ESP32-S2 TRM (Preliminary V0.4)

 
17. 2C Controller

 

Register 17.2: 12C_SDA_HOLD_REG (0x0030)

 

 

 

xX
f
°°
S re’
Poe Y
Ce Qe’
[a1 ro] o|
jo0 9000000000000 00000 0 0 x0 |Reset

 

12C_ SDA _HOLD_TIME This register is used to configure the interval between changing the SDA out-
put level and the falling edge of SCL, in 12C module clock cycles. (RAW)

Register 17.3: 12C_SDA_SAMPLE_REG (0x0034)

 

 

 

xX
ww
ee’
»
& oe
EF &’
[1 1o[» o|
joo9 0000000000009 00000 0 9 ox0 |Reset

 

12C_SDA_SAMPLE_TIME This register is used to configure the interval between the rising edge of
SCL and the level sampling time of SDA, in I2C module clock cycles. (RAW)

Register 17.4: I2C_SCL_HIGH_PERIOD_REG (0x0038)

 

 

 

oe
oO &
ee Ss
x g
WS x
w WO
S N// \//
é 9 9
Ss oF oF
& v v
[1 227 [13 °|
fo 0 0 of Ox00 | 9x00 |Reset

 

I2C_SCL_HIGH_PERIOD This register is used to configure for how long SCL remains high in master
mode, in I2C module clock cycles. (R/W)

I2C_SCL_WAIT_HIGH_PERIOD This register is used to configure for the SCL_FSM’s waiting period
for SCL to go high in master mode, in I2C module clock cycles. (R/W)

Espressif Systems 361 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

Register 17.5: 12C_SCL_START_HOLD_REG (0x0040)

 

 

 

w&
oo”
«>
ae
Ce
S ea
Pe &
NG &
[1 1o[» o|
joo9 0000000000009 00000 0 9 8 |Reset

 

12C_SCL_START_HOLD_TIME This register is used to configure interval between pulling SDA low
and pulling SCL low when the master generates a START condition, in 12C module clock cycles.

 

 

 

(RAW)
Register 17.6: I2C_SCL_RSTART_SETUP_REG (0x0044)
Xe
Q’
AS
gs
£7
“é
i)
> 3
‘S §
SP OF
e v
[1 | o|
joo 9 0000090090000 00909000 00 9 8 |Reset

 

I2C_SCL_RSTART_SETUP_TIME This register is used to configure the interval between the positive
edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.

 

 

 

(RAW)
Register 17.7: 12C_SCL_STOP_HOLD_REG (0x0048)
xX
oo
aS
& Oo”
Ss o?
€ v
[1 [13 o|
[oo 0 0000990000000 090 0 9 x00 |Reset

 

12C_SCL_STOP_HOLD_TIME This register is used to configure the delay after the STOP condition,
in l2C module clock cycles. (RAV)

Espressif Systems 862 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.8: 12C_SCL_STOP_SETUP_REG (0x004C)

 

 

 

joo9 0000000000009 00000 0 9 ox0 |Reset

 

12C_SCL_STOP_SETUP_TIME This register is used to configure the time between the positive edge
of SCL and the positive edge of SDA, in 12C module clock cycles. (RAV)

Register 17.9: 12C_SCL_ST_TIME_OUT_REG (0x0098)

xO

 

 

 

[0 000 0 0 0 o| Ox0100 |Reset

 

I2C_ SCL_ST_TO The threshold value of SCL_FSM state unchanged period. (RAW)

Register 17.10: I2C_SCL_MAIN_ST_TIME_OUT_REG (0x009C)

 

 

 

xO
gO’
OY
> SS
é §"
N\
[1 x |2s o|
[o 00000 0 o| 0x0100 |Reset

 

I2C_SCL_MAIN_ST_TO The threshold value of SCL_MAIN_FSM state unchanged period. (R/W)

Espressif Systems 863 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.11: 12C_CTR_REG (0x0004)

& PEE PE OO EE LL’

31 12] 1] io} 9 | s | 7] 6]s5 4/3 ]2 1 °

 

 

0 0 000 0 0 0 0 0 00 00 0 0 0 0 0 0/17 07/71)/0)/0]0}/0]0/1)0]1 ] 1 [Reset

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

I2C_ SDA_FORCE_OUT 0: direct output; 1: open drain output. (RAV)
I2C_ SCL _FORCE_OUT 0: direct output; 1: open drain output. (RAV)

I2C_ SAMPLE SCL_LEVEL This register is used to select the sample mode. 1: sample SDA data on
the SCL low level. 0: sample SDA data on the SCL high level. (RAM)

I2C_RX_FULL_ACK_LEVEL This register is used to configure the ACK value that need to sent by
master when the rx_fifo_cnt has reached the threshold. (RAV)

120 MS MODE Set this bit to configure the module as an I2C Master. Clear this bit to configure the
module as an I2C Slave. (R/W)

12C_ TRANS START Set this bit to start sending the data in TX FIFO. (RAM)

12C_TX_LSB_FIRST This bit is used to control the sending mode for data needing to be sent. 1:
send data from the least significant bit; O: send data from the most significant bit. (RAV)

I2C_RX_LSB_FIRST This bit is used to control the storage mode for received data. 1: receive data
from the least significant bit; O: receive data from the most significant bit. (RAV)

I2C_CLK_EN Reserved (RW)
I2C_ARBITRATION_EN This is the enable bit for I2C bus arbitration function. (RAV)
I2C_FSM_RST This register is used to reset the SCL_FSM. (RM)

I2C_REF_ALWAYS_ON This register is used to control the REF_TICK. (RAV)

Espressif Systems 364 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.12: I20_TO_REG (0x000C)

 

 

 

¥y
a “> &
£ s
€ ve ov
[ ENE J
fo 9 0 9 0 0 ofo] 0x0000 |Reset

 

12C_TIME_OUT_VALUE This register is used to configure the timeout for receiving a data bit in APB
clock cycles. (R/W)

12C_TIME_OUT_EN This is the enable bit for time out control. (RAM)

Register 17.13: I2€_SLAVE_ADDR_REG (0x0010)

 

 

 

S
rN &’
Qv
oc
ge & £
| 31 | 30 1s | 14 ° |
| 0 [o 0000000000000 0 o x00 |Reset

 

I2C_ SLAVE_ADDR When configured as an |2C Slave, this field is used to configure the slave address.

(RAV)
12C_ADDR_10BIT_EN This field is used to enable the slave 10-bit addressing mode in master mode.
(RAV)
Espressif Systems 365 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
17. 2C Controller

 

Register 17.14: l2C_FIFO_CONF_REG (0x0018)

y COPE &

[1 av] 26 [5 20] 19 w[a[ [uo [s | o|

 

 

 

[o 0 0 0 ofa | Ox15 | Ox15 fofofofo] Ox4 | oxb |Reset

 

I2C_RXFIFO_WM_THRHD The water mark threshold of RX FIFO in non-FIFO mode. When
12C_FIFO_PRT_EN is 1 and RX FIFO counter is bigger than I12C_RXFIFO_WM_THRHD/4:0],
I2C_RXFIFO_WM_INT_RAW bit will be valid. (RAV)

I2C_TXFIFO_WM_THRHD The water mark threshold of TX FIFO in non-FIFO mode. When
12C_FIFO_PRT_EN is 1 and TX FIFO counter is smaller than |2C_TXFIFO_WM_THRHD/4:0],
I2C_TXFIFO_WM_INT_RAW bit will be valid. (RAV)

I2C_NONFIFO_EN Set this bit to enable APB non-FIFO mode. (RAW)

12C_FIFO_ADDR_CFG_EN When this bit is set to 1, the byte received after the I2C address byte
represents the offset address in the I2C Slave RAM. (RAW)

I2C_RX_FIFO_RST Set this bit to reset RX FIFO. (RAV)
12C_TX_FIFO_RST Set this bit to reset TX FIFO. (R/W)

I2C_NONFIFO_RX_THRES When I|2C receives more than 12C_NONFIFO_RX_THRES bytes of data,
it will generate an I2C_RXFIFO_UDF_INT interrupt and update the current offset address of the
received data. (RAW)

I2C_NONFIFO_TX_THRES When |2C sends more than I2C_NONFIFO_TX_THRES bytes of data, it
will generate an I2C_TXFIFO_OVF_INT interrupt and update the current offset address of the sent
data. (RAV)

12C_FIFO_PRT_EN The control enable bit of FIFO pointer in non-FIFO mode. This bit controls the
valid bits and the interrupts of TX/RX FIFO overflow, underflow, full and empty. (RAV)

Espressif Systems S66 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

Register 17.15: I2¢_SCL_SP_CONF_REG (0x00A0)

 

 

 

s S
Cre
~ OQ Ck
& io” Oo” Oo
& gir ge g
[a1 afr [o[s if o |
[oo 9 090 00009000009 000000 0 0 0 ofofo] Oxo [0 |Reset

 

I2C_ SCL_RST_SLV_EN When [2C master is IDLE, set this bit to send out SCL pulses. The number
of pulses equals to 1I2C_SCL_RST_SLV_NUM[4:0]. (RAV)

12C_ SCL_RST_SLV_NUM Configure the pulses of SCL generated in 12C master mode. Valid when
12C_SCL_RST_SLV_EN is 1. (RAV)

I2C_SCL_PD_EN The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not
power down. Set |12C_SCL_FORCE_OUT and l2C_SCL_PD_EN to 1 to stretch SCL low. (RW)

12C_ SDA_PD_EN The power down enable bit for the 12C output SDA line. 1: Power down. 0: Not
power down. Set 12C_SDA_FORCE_OUT and |2C_SDA_PD_EN to 1 to stretch SDA low. (RAM)

Register 17.16: I2C_SCL_STRETCH_CONF_REG (0x00A4)

 

 

 

oS SS
NG 7 ss
OKO A?
OLS S
SES &
OvLOr” oS
Ss a &
g sor gS
& CL &
[a1 | 1] 1 [9 o|
[fo9 9 0009000000000 00 0 0 ofofo| x0 |Reset

 

l2C_ STRETCH PROTECT _NUM Configure the period of |2C slave stretching SCL line. (RAV)

I2C_SLAVE_SCL_STRETCH_EN The enable bit for slave SCL stretch function. 1: Enable. 0: Dis-
able. The SCL output line will be stretched low when |2C_SLAVE_SCL_STRETCH_EN is 1 and

stretch event happens. The stretch cause can be seen in |I2C_STRETCH_CAUSE. (RAW)

I2C_ SLAVE SCL_STRETCH_CLR Set this bit to clear the 12C slave SCL stretch function. (WO)

Espressif Systems 367 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
17. 2C Controller

Register 17.17: 12C_SR_REG (0x0008)

 

 

A
S
y 5S)
A KY x, SL
ye we & oe & A
& ey’ & 07 & te ES LGD
A ys oO 9 oO SKS &
Sf of S & & & & A & 9°Q% eB’
Ss oF Ss of S Ss oF & és ofo%es oS 207, of
CL CL Vv CG v CP PPO Wee
31 30 28) 27 26 24 | 23 1g | 17 16] 15 14] 13 8 7 6 5 4 3 2 1 oO
0 ox0 0 Ox0 ox0 0 o| oxo Ox0 olololo]oa]o]o]|o Reset

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

I2C_RESP_REC The received ACK value in master mode or slave mode. 0: ACK; 1: NACK. (RO)
I2C_SLAVE_ RW When in slave mode, 1: master reads from slave; 0: master writes to slave. (RO)

12C_TIME_OUT When the I2C controller takes more than |2C_TIME_OUT clocks to receive a data bit,
this field changes to 1. (RO)

12C_ARB_LOST When the |2C controller loses control of SCL line, this register changes to 1. (RO)
12C_BUS_BUSY 1: the I2C bus is busy transferring data; 0: the I2C bus is in idle state. (RO)

I2C_ SLAVE ADDRESSED When configured as an I2C Slave, and the address sent by the master is
equal to the address of the slave, then this bit will be of high level. (RO)

12C_BYTE_TRANS This field changes to 1 when one byte is transferred. (RO)
I2C_RXFIFO_CNT This field represents the amount of data neecled to be sent. (RO)

I2C_ STRETCH CAUSE The cause of stretching SCL low in slave mode. 0: stretching SCL low at
the beginning of I2C read data state. 1: stretching SCL low when I2C TX FIFO is empty in slave
mode. 2: stretching SCL low when |2C RX FIFO is full in slave mode. (RO)

12C_TXFIFO_CNT This field stores the amount of received data in RAM. (RO)

I2C_SCL_MAIN_STATE_LAST This field indicates the states of the 12C module state machine. 0:
Idle; 1: Address shift; 2: ACK address; 3: RX data; 4: TX data; 5: Send ACK; 6: Wait ACK (RO)

I2C_SCL_STATE LAST This field indicates the states of the state machine used to produce SCL. 0:
Idle; 1: Start; 2: Negative edge; 3: Low; 4: Positive edge; 5: High; 6: Stop (RO)

Espressif Systems 368 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.18: I2C_FIFO_ST_REG (0x0014)

S we S
&
&

 

31 30 | 29 22| 21 | 20 | 19 15 | 14 10 | 9 514 °

 

rn) Ox0 0} 0 Ox0 Ox0 Ox0 Ox0 Reset

 

 

 

 

 

 

 

 

 

 

I2C_RXFIFO_START_ADDR This is the offset address of the last received data, as described in
|2C_NONFIFO_RX_THRES. (RO)

I2C_RXFIFO_LEND_ADDR This is the offset address of the last received data, as de-
scribed in 12C_NONFIFO_RX_THRES. This value refreshes when an I2C_RXFIFO_UDF_INT or
12C_TRANS_ COMPLETE _INT interrupt is generated. (RO)

I2C_TXFIFO_START_ADDR This is the offset address of the first sent data, as described in
|2C_NONFIFO_TX_THRES. (RO)

I2C_TXFIFO_END_ADDR This is the offset address of the last sent data, as described
in l2C_NONFIFO_TX_THRES. The value refreshes when an |2C_TXFIFO_OVF_INT or
12C_TRANS_ COMPLETE _INT interrupt is generated. (RO)

I2C_RX_UPDATE Write 0 or 1 to I2C_RX_UPDATE to update the value of I2C_RXFIFO_END_ADDR
and I2C_RXFIFO_START_ADDR. (WO)

I2C_TX_UPDATE Write 0 or 1 to I2C_TX_UPDATE to update the value of I2C_TXFIFO_END_ADDR
and I2C_TXFIFO_START_ADDR. (WO)

I2C_SLAVE_RW_POINT The received data in I2C slave mode. (RO)

Register 17.19: I2C_DATA_REG (0x001C)

 

 

 

 

I2C_FIFO_RDATA The value of RX FIFO read data. (RO)

Espressif Systems 869 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.20: I2C_INT_RAW_REG (0x0020)

qj
o WA? os
KX NS DOOD O7 AM RES o
Ss sv DAES COS 6S ZL Ko XK NI
s YES SE EEL L CLES *
& PEPE EPO LPE OEE

 

E

el=—«[=[=l*)*[> l=] ]

 

|
[o 0000000000000 ofofofofofolofofo]olfo]o]o

TeTe}e] fe

0 0[0]0] 9 IReset

 

12C_RXFIFO_WM_INT_RAW The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt. (RO)

12C_TXFIFO_WM_INT_RAW) The raw interrupt bit for I2C_TXFIFO_WIM_INT interrupt. (RO)

I2C_RXFIFO_OVF_INT_RAW The raw interrupt bit for 12C_RXFIFO_OVF_INT interrupt. (RO)

I2C_END_DETECT_INT_RAW The raw interrupt bit for the 12C_END_DETECT_INT interrupt. (RO)

I2C_BYTE_TRANS DONE_INT_RAW The raw interrupt bit for the I2C_END_DETECT_INT interrupt.

(RO)

I2C_ARBITRATION_LOST_INT_RAW The raw interrupt bit for the 12C_ARBITRATION_LOST_INT in-

terrupt. (RO)

I2C_MST_TXFIFO_UDF_INT_RAW The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.

(RO)

I2C_TRANS_COMPLETE_INT_RAW The raw interrupt bit for the 12C_TRANS_COMPLETE_INT in-

terrupt. (RO)

12C_TIME_OUT_INT_RAW The raw interrupt bit for the 12C_TIME_OUT_INT interrupt. (RO)

I2C_ TRANS _START_INT_RAW The raw interrupt bit for the I2C_TRANS_START_INT interrupt. (RO)

I2C_NACK_INT_RAW The raw interrupt bit for 12C_SLAVE_STRETCH_INT interrupt. (RO)

12C_TXFIFO_OVF_INT_RAW The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt. (RO)

12C_RXFIFO_UDF_INT_RAW The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt. (RO)

l2C_ SCL_ST_TO_INT_RAW The raw interrupt bit for 12C_SCL_ST_TO_INT interrupt. (RO)

I2C_SCL_MAIN_ST_TO_INT_RAW The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.

(RO)

I2C_DET_START_INT_RAW The raw interrupt bit for 12C_DET_START_INT interrupt. (RO)

I2C_SLAVE_STRETCH_INT_RAW The raw interrupt bit for 12C_SLAVE_STRETCH_INT interrupt.

(RO)

Espressif Systems

3870 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.21: 12C_INT_CLR_REG (0x0024)

& PEE EOE EEE EOE EEL OSL
lf ofel=[»|= BoE Phy]

[2] a] [>]é]>
[fo 0 0 0 0 0 0 0 0 0 0 0 0 0 ofofofofofolofofofo]ofo][ofo]o]ofo]o ]Reset

 

12 i

 

 

I2C_RXFIFO_WM_INT_CLR Set this bit to clear |2C_RXFIFO_WM_INT interrupt. (WO)
12C_TXFIFO_WM_INT_CLR Set this bit to clear I2C_TXFIFO_WM_INT interrupt. (WO)
I2C_RXFIFO_OVF_INT_CLR_ Set this bit to clear 12C_RXFIFO_OVF_INT interrupt. (WO)
I2C_END_DETECT_INT_CLR Set this bit to clear the I2C_END_DETECT_INT interrupt. (WO)

I2C_BYTE_TRANS_DONE_INT_CLR Set this bit to clear the I2C_END_DETECT_INT interrupt. (WO)

12C_ARBITRATION_LOST_INT_CLR Set this bit to clear the I2C_ARBITRATION_LOST_INT inter-
rupt. (WO)

I2C_MST_TXFIFO_UDF_INT_CLR_ Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt. (WO)

I2C_TRANS_COMPLETE_INT_CLR Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
(WO)

12C_TIME_OUT_INT_CLR Set this bit to clear the I2C_TIME_OUT_INT interrupt. (WO)
I2C_TRANS_START_INT_CLR_ Set this bit to clear the I2C_TRANS_START_INT interrupt. (WO)
I2C_NACK_INT_CLR Set this bit to clear 2C_SLAVE_STRETCH_INT interrupt. (WO)
12C_TXFIFO_OVF_INT_CLR_ Set this bit to clear |2C_TXFIFO_OVF_INT interrupt. (WO)
I2C_RXFIFO_UDF_INT_CLR_ Set this bit to clear |2C_RXFIFO_UDF_INT interrupt. (WO)
I2C_SCL_ST_TO_INT_CLR Set this bit to clear 12C_SCL_ST_TO_INT interrupt. (WO)
I2C_SCL_MAIN_ST_TO_INT_CLR_ Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt. (WO)
I2C_DET_START_INT_CLR_ Set this bit to clear |2C_DET_START_INT interrupt. (WO)

I2C_SLAVE_STRETCH_INT_CLR_ Set this bit to clear 12C_SLAVE_STRETCH_INT interrupt. (WO)

Espressif Systems 371 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.22: I2C_INT_ENA_REG (0x0028)

e Pa
sr & sv “& SF
yy ere Se pS Leeroy
SOOM ES SKS IE KE ESE
SK LRK ZO RZKS SS SSS,
és WAS NS Ser ECE SOYovA> VS S
x KOPOEE LEI OP LS BeOS Wa
p GES FRESE CLE EC SEE
sf PEOPLE NRE LE OE EA
e O97 O77 O07 007207 OOO 4.07 O07 OF 7.07.0 7

GY
[ ooge PPP PPP LeeiEr]

[e]a
foo 0 00 000 00 00 0 0 ofofofofofolofo]ofo]ofo]ofo]o]oJo] ]reset

 

E

 

 

I2C_RXFIFO_WM_INT_ENA The raw interrupt bit for 12C_RXFIFO_WM_INT interrupt. (RAM)
12C_TXFIFO_WM_INT_ENA The raw interrupt bit for |12C_TXFIFO_WM_INT interrupt. (R/V)
I2C_RXFIFO_OVF_INT_ENA The raw interrupt bit for 12C_RXFIFO_OVF_INT interrupt. (RAV)
I2C_END_DETECT_INT_ENA The raw interrupt bit for the 12C_END_DETECT_INT interrupt. (RAY)

I2C_BYTE_TRANS DONE _INT_ENA The raw interrupt bit for the 12C_END_DETECT_INT interrupt.
(RAV)

12C¢_ARBITRATION_LOST_INT_ENA The raw interrupt bit for the 12C_ARBITRATION_LOST_INT in-
terrupt. (RW)

12¢_MST_TXFIFO_UDF_INT_ENA The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
(RAW)

12¢_ TRANS COMPLETE_INT_ENA The raw interrupt bit for the 12C_TRANS_ COMPLETE _INT in-
terrupt. (RW)

12C_TIME_OUT_INT_ENA The raw interrupt bit for the 12C_TIME_OUT_INT interrupt. (RAW)

I2C_ TRANS START_INT_ENA The raw interrupt bit for the 12C_TRANS_START_INT interrupt. (RAM)

I2C_ NACK_INT_ENA The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt. (RAV)
I2C_TXFIFO_OVF_INT_ENA The raw interrupt bit for 12C_TXFIFO_OVF_INT interrupt. (RAM)
I2C_RXFIFO_UDF_INT_ENA The raw interrupt bit for 12C_RXFIFO_UDF_INT interrupt. (RAV)
12C_ SCL_ST_TO_INT_ENA The raw interrupt bit for 12C_SCL_ST_TO_INT interrupt. (RAV)

I2C_ SCL_MAIN_ST_TO_INT_ENA The raw interrupt bit for 12C_SCL_MAIN_ST_TO_INT interrupt.
(RAV)

12C_DET_START_INT_ENA The raw interrupt bit for 12C_DET_START_INT interrupt. (RAM)

I2C_SLAVE_STRETCH_INT_ENA The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
(RAV)

Espressif Systems 872 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.23: I2C_INT_STATUS_REG (0x002C)

Ke & SF
A & SL «265
S AZ OK
S « A 2s
RR PA SD 6S SASOS
SROZOMNS SA CoS.
SELES SEE EGE SELES
LSELNS SA EERO MOM
REPL FOP EKER SE SOLE GPM.
LOO SYS FLAGS Cee 7 SW
s GX CL oes < rss SS ‘< OCLE
sf SLO DQEE PLO SSE SF
& PEPOELP OEE EEE EEE ESL

 

[a

wel] u|s 2 tfolo]e

ano

 

| 0

[2] 4] [7 [e]>[.|
00 00000 00 00 0 0 ofofofofofofofofofofo]ofo]ofo]o]o]o Jreset

 

Espressif Systems 873 ESP32-S2 TRM (Preliminary V0.4)

I2C_RXFIFO_WM_INT_ST The masked interrupt status bit for 12C_RXFIFO_WM_INT interrupt. (RO)
12C_TXFIFO_WM_INT_ST The masked interrupt status bit for |2C_TXFIFO_WM_INT interrupt. (RO)

I2C_RXFIFO_OVF_INT_ST The masked interrupt status bit for 12C_RXFIFO_OVF_INT interrupt. (RO)

I2C_END_DETECT_INT_ST Themasked interrupt status bit for the 12C_END_DETECT_INT interrupt.
(RO)

I2C_BYTE_TRANS DONE _INT_ST The masked interrupt status bit for the l2@C_END_DETECT_INT
interrupt. (RO)

I2C_ARBITRATION_LOST_INT_ST The masked interrupt status bit for the
12C_ARBITRATION_LOST_INT interrupt. (RO)

I2C_MST_TXFIFO_UDF_INT_ST The masked interrupt status bit for I2C_TRANS_COMPLETE_INT
interrupt. (RO)

I2C_ TRANS COMPLETE_INT_ST The masked interrupt status bit for the
12C_TRANS_COMPLETE_INT interrupt. (RO)

12C_TIME_OUT_INT_ST The masked interrupt status bit for the 12C_TIME_OUT_INT interrupt. (RO)

I2C_ TRANS START_INT_ST The masked interrupt status bit for the 12C_TRANS_START_INT inter-
rupt. (RO)

120 NACK_INT_ST The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt. (RO)

12C_TXFIFO_OVF_INT_ST The masked interrupt status bit for 12C_TXFIFO_OVF_INT interrupt. (RO)

12C_RXFIFO_UDF_INT_ST The masked interrupt status bit for 12C_RXFIFO_UDF_INT interrupt. (RO)

I2C_ SCL_ST_TO_INT_ST The masked interrupt status bit for 12C_SCL_ST_TO_INT interrupt. (RO)

I2C_ SCL_MAIN_ST_TO_INT_ST The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT in-
terrupt. (RO)

12C_DET_START_INT_ST The masked interrupt status bit for 12C_DET_START_INT interrupt. (RO)

I2C_SLAVE_STRETCH_INT_ST The masked interrupt status bit for I2C_SLAVE_STRETCH_INT in-
terrupt. (RO)

Submit Documentation Feedback
17. 2C Controller

Register 17.24: 12C_SCL_FILTER_CFG_REG (0x0050)

S
eg
Qa’ ks
eo Sf a
X NN
| 31 5 | 4 | 3 ° |

[foo 0000000000000 000000 000 00 0/1] Ox0 |Reset

 

 

 

12C_SCL_FILTER_THRES When a pulse on the SCL input has smaller width than this register value
in l2C module clock cycles, the 12C controller will ignore that pulse. (R/V)

I2C_SCL_FILTER_EN Thisis the filter enable bit for SCL. (R/W)

Register 17.25: I2C_SDA_FILTER_CFG_REG (0x0054)

 

 

000000000060 006 6060006000000 0 060 06 0 0 Of1 Ox0 Reset

 

 

 

 

 

12C_SDA_FILTER_THRES When a pulse on the SDA input has smaller wictth than this register value
in l2C module clock cycles, the 12C controller will ignore that pulse. (R/V)

I2C_SDA_FILTER_EN This is the filter enable bit for SDA. (R/W)

Register 17.26: I2C_COMDO0_REG (0x0058)

 

 

[ojo 0 0 0 9 0000000000 0 9 x00 |Reset

 

120 COMMANDO This is the content of command 0. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

120 _ COMMANDO DONE When command 0 is done in l2C Master mode, this bit changes to high
level. (RAW)

Espressif Systems 3874 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

Register 17.27: I2C_COMD1_REG (0x005C)

 

 

&
s
ov S
S & RY
S g S
& & &
| 31 | 30 14 | 13 o |
0x00 |Reset

 

foJo 0 0 09 0 0000000090 0 0 9]

 

120 _ COMMAND1 This is the content of command 1. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the

ACK bit. See I2C cmd structure for more Information. (RAW)

120 _ COMMAND1_DONE When command 1 is done in I2C Master mode, this bit changes to high

 

 

 

level. (RAW)
Register 17.28: 12C_COMD2_REG (0x0060)
&
ss
SF y
OQ Q
= Ss
Ss S RS
3 és &
on eC QP’
| 31 | 30 14 | 13 o |
0x00 |Reset

[ojo 0 0 0 9 0000000000 0 9

 

120 _ COMMANDZ2 This is the content of command 2. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the

ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND2_ DONE When command 2 is done in l2C Master mode, this bit changes to high

Level. (RAV)

Espressif Systems 3875
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
17. 2C Controller

Register 17.29: I2C_COMD3_REG (0x0064)

 

 

&
eS
7 o>
Q Q
we .
S
S & S
Pe’ eC Pe’
| 31 | 30 14 | 13 o |
0x00 |Reset

 

foJo 0 0 09 0 0000000090 0 0 9]

 

120 _ COMMANDS This is the content of command 3. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the

ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND3_DONE When command 3 is done in I2C Master mode, this bit changes to high

 

 

 

level. (RAW)
Register 17.30: I2C_COMD4_REG (0x0068)
&
oe
de? bx
OQ Q
Ss Ss
Ss S RS
3 és &
on eC QP’
| 31 | 30 14 | 13 o |
0x00 |Reset

 

120 _ COMMAND4 This is the content of command 4. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the

ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND4 DONE When command 4 is done in l2C Master mode, this bit changes to high

level. (RAV)

Espressif Systems 376
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
17. 2C Controller

Register 17.31: I2C_COMD5_REG (0x006C)

 

 

&
eS
7 {>
SS & SS
3 gs 3
Pe’ eC Pe’
| 31 | 30 14 | 13 o |
0x00 |Reset

 

foJo 0 0 09 0 0000000090 0 0 9]

 

120 COMMANDS This is the content of command 5. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

120 _ COMMAND5 DONE When command 5 is done in I2C Master mode, this bit changes to high

 

 

 

level. (RAW)
Register 17.32: 12C_COMD6_REG (0x0070)
&
Ss
©” ©
OY g
Ss Ss
Ss S RS
3 és &
& & &
| 31 | 30 14 | 13 o |
0x00 |Reset

 

120 _ COMMANDE This is the content of command 6. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

120 _ COMMAND6_DONE When command 6 is done in I2C Master mode, this bit changes to high
level. (RAW)

Espressif Systems 377 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
17. 2C Controller

Register 17.33: I2C_COMD7_REG (0x0074)

 

 

of
3° 5
a e
SS & SS
3 gs 3
Pe’ eC Pe’
| 31 | 30 14 | 13 o |
0x00 |Reset

 

foJo 0 0 09 0 0000000090 0 0 9]

 

120 COMMAND? This is the content of command 7. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the

ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND7_DONE When command 7 is done in |2C Master mode, this bit changes to high

 

 

 

level. (RAW)

Register 17.34: 12C_COMD8_REG (0x0078)
&
S&S
<P" &
S S
Ss S RS
3 és &
on eC QP’
| 31 | 30 14 | 13 o |
0x00 |Reset

 

120 COMMANDS This is the content of command 8. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the

ACK bit. See I2C cmd structure for more Information. (RAW)

120 _ COMMAND8_ DONE When command 8 is done in |2C Master mode, this bit changes to high

level. (RAV)

Espressif Systems 378
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
17. 2C Controller

Register 17.35: I2C_COMD9_REG (0x007C)

 

 

 

&
Ss
a 2
RS S s
& sf S
Qe’ & ee
| 31 | 30 14 | 13 ° |
| 0 | 00000000000 00000 o| x00 |Reset

 

120 _ COMMANDS This is the content of command 9. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMANDS _ DONE When command 9 is done in |2C Master mode, this bit changes to high

 

 

 

level. (RAW)
Register 17.36: 12C_COMD10_REG (0x0080)
&
Ss
3’ Ss
ee S we
S$ KS S

& < eC &
| 31 | 30 14 | 13 o |
| a fo 000000000000 000 | x00 |Reset

 

120 _ COMMAND10 This is the content of command 10. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

120 _ COMMAND10 DONE When command 10 is done in I2C Master mode, this bit changes to high
level. (RAW)

Espressif Systems 3879 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.37: 12C_COMD11_REG (0x0084)

 

 

&
eS
as ”
© ©
s s
wr wr
SS & »
9 s 9

& e &
31 30 14 | 13 o
o]O 0 0 00 00 00 00 00 00 0 0 0x00 Reset

 

 

 

 

 

120 _ COMMAND11 This is the content of command 11. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND11_DONE When command 11 is done in |12C Master mode, this bit changes to high

 

 

 

level. (RAW)
Register 17.38: 12C_COMD12_REG (0x0088)
&
Ss
XW xv
8 $
w w
» & »
3 FS 3
Pe’ eC Pe’
| 31 | 30 14 | 13 o |
| 0 [o 0000000000000 0 0 o| x00 |Reset

 

120 _ COMMAND12 This is the content of command 12. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND12 DONE When command 12 is done in |12C Master mode, this bit changes to high
level. (RAW)

Espressif Systems 880 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.39: I2C_COMD13_REG (0x008C)

 

 

&
s
Nei Oo
QO ©
s s
wr wr
SS > SS
S s g

& e &

31 30 14 | 13 o
ojo 0 000000000000 0 0 0 x00 Reset

 

 

 

 

 

I2¢_ COMMAND13 This is the content of command 18. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND13 DONE When command 13 is done in |12C Master mode, this bit changes to high

 

 

 

level. (RAW)
Register 17.40: 12C_COMD14_REG (0x0090)
&
eS
Q
voy vw
8 $
w w
» & »
3 FS 3
Pe’ eC Pe’
| 31 | 30 14 | 13 o |
| 0 [o 0000000000000 0 0 o| x00 |Reset

 

I2¢_ COMMAND14 This is the content of command 14. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND14 DONE When command 14 is done in |12C Master mode, this bit changes to high
level. (RAW)

Espressif Systems 381 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
17. 2C Controller

 

Register 17.41: 12C_COMD15_REG (0x0094)

 

 

&
s
xo” xo
QO ©
s s
wr wr
SS > SS
S s g

& e &

31 30 14 | 13 o
ojo 0 000000000000 0 0 0 x00 Reset

 

 

 

 

 

120 _ COMMAND‘15 This is the content of command 15. It consists of three parts: op_code is the
command, 0: RSTART; 1: WRITE; 2: READ; 3: STOP; 4: END. byte_num represents the number
of bytes that need to be sent or received. ack_check_en, ack_exp and ack are used to control the
ACK bit. See I2C cmd structure for more Information. (RAW)

I20_ COMMAND15 DONE When command 15 is done in 12C Master mode, this bit changes to high
level. (RAW)

Register 17.42: 12C_DATE_REG (0x00F8)

x
x
&

 

 

| 0x19052000 |Reset

 

I2C_DATE This is the the version control register. (RAV)

Espressif Systems 882 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

18. TWAI

18.1 Overview

The Two-Wire Automobile Interface (TWA\) is a multi-master, multi-cast communication protocol with error
detection and signaling and inbuilt message priorities and arbitration. The TWAI protocol is suited for automotive
and industrial applications (Please see TWAI Protocol Description).

ESP32-S2 contains a TWAI controller that can be connected to a TWAI bus via an external transceiver. The TWA|
controller contains numerous advanced features, and can be utilized in a wide range of use cases such as
automotive products, industrial automation controls, building automation etc.

18.2 Features
ESP32-S2 TWAI controller supports the following features:

* compatible with ISO 11898-1 protocol
* Supports Standard Frame Format (11-bit ID) and Extended Frame Format (29-bit ID)
® Bit rates from 1 Kbit/s to 1 Mbit/s
* Multiple modes of operation
- Normal
— Listen Only (no influence on bus)
— Self Test (transmissions do not require acknowledgment)
* 64-byte Receive FIFO
® Special transmissions
— Single-shot transmissions (does not automatically re-transmit upon error)
— Self Reception (the TWAI controller transmits and receives messages simultaneously)
* Acceptance Filter (supports single and dual filter modes)
* Error detection and handling
— Error counters
— Configurable Error Warning Limit
— Error Code Capture

— Arbitration Lost Capture

Espressif Systems 883 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

18.3 Functional Protocol
18.3.1 TWAI Properties

The TWAI protocol connects two or more nodes in a bus network, and allows for nodes to exchange messages
in a latency bounded manner. A TWAI bus will has a following properties.

Single Channel and Non-Return-to-Zero: The bus consists of a single channel to carry bits, thus
communication is half-duplex. Synchronization is also derived from this channel, thus extra channels (e.g., clock
or enable) are not required. The bit stream of a TWAI message is encoded using the Non-Return-to-Zero (NRZ)
method.

Bit Values: The single channel can either be in a Dominant or Recessive state, representing a logical O and a
logical 1 respectively. A node transmitting a Dominant state will always override a another node transmitting a
Recessive state. The physical implementation on the bus is left to the application level to decide (e.g., differential
wiring).

Bit-Stuffing: Certain fields of TWAI messages are bit-stuffed. A Transmitter that transmits five consecutive bits of
the same value should automatically insert a complementary bit. Likewise, a Receiver that receives five
consecutive bits should treat the next bit as a stuff bit. Bit stuffing is applied to the following fields: SOF,
Arbitration Field, Control Field, Data Field, and CRC Sequence (see Section 18.3.2 for more details).

Multi-cast: All nodes receive the same bits as they are connected to the same bus. Data is consistent across all
nodes unless there is a bus error (See Section 18.3.3).

Multi-master: Any node can initiate a transmission. If a transmission is already ongoing, a node will wait until the
current transmission is over before beginning its own transmission.

Message-Priorities and Arbitration: If two or more nodes simultaneously initiate a transmission, the TWAI
protocol ensures that one node will win arbitration of the bus. The Arbitration Field of the message transmitted by
each node is used to determine which node will win arbitration.

Error Detection and Signaling: Each node will actively monitor the bus for errors, and signal the detection
errors by transmitting an Error Frame.

Fault Confinement: Each node will maintain a set of error counts that are incremented/decremented according
to a set of rules. When the error counts surpass a certain threshold, a node will automatically eliminate itself from
the network by switching itself off.

Configurable Bit Rate: The bit rate for a single TWAI bus is configurable. However, all nodes within the same
bus must operate at the same bit rate.

Transmitters and Receivers: At any point in time, a TWAI node can either be a Transmitter or a Receiver.

* Anode originating a message is a Transmitter. The node remains a Transmitter until the bus is idle or until
the node loses arbitration. Note that multiple nodes can be Transmitter if they have yet to lose arbitration.

© All nodes that are not Transmitters are Receivers.

18.3.2 TWAI Messages

TWAI nodes use messages to transmit data, and signal errors to other nodes. Messages are split into various
frame types, and some frame types will have different frame formats. The TWAI protocol has of the following
frame types:

° Data Frames

Espressif Systems 384 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

* Remote Frames
° Error Frames
* Overload Frames
* Interframe Space
The TWAI protocol has the following frame formats:
® Standard Frame Format (SFF) that consists of a 11-bit identifier

* Extended Frame Format (EFF) that consists of a 29-bit identifier

18.3.2.1 Data Frames and Remote Frames

Data Frames are used by nodes to send data to other nodes, and can have a payload of 0 to 8 data bytes.
Remote Frames are used to nodes to request a Data Frame with the same Identifier from another node, thus
does not contain any data bytes. However, Data Frames and Remote Frames share many common fields. Figure
18-1 illustrates the fields and sub fields of the different frames and formats.

 

 

 

 

 

 

 

 

 

 

 

Arbitration Control Data cRC ACK
Field Field Field Field Field
Evslf
Standard Format || BaseID | & | w cRc a/4/8
Data Frame 8| qibitsy |) a) 2) OLe Data Byte 1 to 8 Sequence | 9 s x EOF
6|*)<
Arbitration Control Data CRC ACK
Field Field Field Field Field
Els/&
Extended Format [|| BaseID |@|w| ExtdID | &| _, cRC a\4/\8
Data Frame B| aris) |) 2) aspisy |) 2)&|) PLC | DataByte1tos Sequence [Q|¥%|y¥) FOF
m/2\o
o <
Arbitration Control CRC ACK
Field Field Field Field
Els/£
Standard Format cRC 8/4/88 EOF
Remote Frame Sequence | Oo 5 4
e/2\o
oO <
Arbitration Control CRC ACK
Field Field Field Field
Els|&
Extended Format [|| BaseID |&|w| eExtdID | &| _, CRC 8/9/38
Remote Frame 8 (11 bits) % a (18 bits) & t)@) oie Sequence 9 s s EOF
<
oO <=

 

 

 

 

Figure 18-1. The bit fields of Data Frames and Remote Frames

Arbitration Field
When two or more nodes transmits a Data or Remote Frame simultaneously, the Arbitration Field is used to

determine which node will win arbitration of the bus. During the Arbitration Field, if a node transmits a Recessive
bit but observes a Dominant bit, this indicates that another node has overridden its Recessive bit. Therefore, the

Espressif Systems 3885 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
18. TWAI

 

node transmitting the Recessive bit has lost arbitration of the bus and should immediately become a
Receiver.

The Arbitration Field primarily consists of the Frame Identifier that is transmitted most significant bit first. Given
that a Dominant bit represents a logical 0, and a Recessive bit represents a logical 1:

* A frame with the smallest ID value will always win arbitration.
* Given the same ID and format, Data Frames will always prevail over RTR Frames.

® Given the same first 11 bits of ID, a Standard Format Data Frame will prevail over an Extended Format Data
Frame due to the SRR being recessive.

Control Field

The control field primarily consists of the DLC (Data Length Code) which indicates the number of payload data
bytes for a Data Frame, or the number of requested data bytes for a Remote Frame. The DLC is transmitted
most significant bit first.

Data Field
The Data Field contains the actual payload data bytes of a Data Frame. Remote Frames do not contain a Data
Field.

CRC Field

The CRC Field primarily consists of aa CRC Sequence. The CRC Sequence is a 15-bit cyclic redundancy code
calculated form the de-stuffed contents (everything from the SOF to the end of the Data Field) of a Data or
Remote Frame.

Table 65: Data Frames and Remote Frames in SFF and EFF

 

Data/Remote Frames Description

 

 

 

SOF The SOF (Start of Frame) is a single Dominant bit used to synchronize nodes on
the bus.

Base ID The Base ID (ID.28 to ID.18) is the 11-bit Identifier for SFF, or the first 11-bits of
the 29-bit Identifier for EFF.

RTR The RTR (Remote Transmission Request) bit indicates whether the message is

a Data Frame (Dominant) or a Remote Frame (Recessive). This means that a
Remote Frame will always lose arbitration to a Data Frame given they have the

 

 

same ID.

SRR The SRR (Substitute Remote Request) bit is transmitted in EFF to substitute for
the RTR bit at the same position in SFF.

IDE The IDE (Identifier Extension) bit indicates whether the message is SFF (Dominant)

or EFF (Recessive). This means that a SFF frame will always win arbitration over
an EFF frame given they have the same Base ID.

 

 

 

 

Extd ID The Extended ID (ID.17 to ID.) is the remaining 18-bits of the 29-bit identifier for
EFF.

r The r1 (reserved bit 1) is always Dominant.

r0 The rO (reserved bit 0) is always Dominant.

DLC The DLC (Data Length Code) is 4-bits and should have a value from 0 to 8.

Data Frames use the DLC to indicate the number data bytes in the Data Frame.
Remote Frames used the DLC to indicate the number of data bytes to request
from another node.

 

 

 

 

Espressif Systems 386 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

 

 

 

 

 

 

 

 

 

Data/Remote Frames Description

Data Bytes The data payload of Data Frames. The number of bytes should match the value
of DLC. Data byte 0 is transmitted first, and each data byte is transmitted most
significant bit first.

CRC Sequence The CRC sequence is a 15-bit cyclic redundancy code.

CRC Delim The CRC Delim (CRC Delimeter) is a single Recessive bit that follows the CRC
sequence.

ACK Slot The ACK Slot (Acknowledgment Slot) that intended for Receiver nodes to indicate
that the Data or Remote Frame was received without issue. The Transmitter node
will send a Recessive bit in the ACK Slot and Receiver nodes should override the
ACK Slot with a Dominant bit if the frame was received without errors.

ACK Delim The ACK Delim (Acknowledgment Delimeter) is a single Recessive bit.

EOF The EOF (End of Frame} marks the end of a Data or Remote Frame, and consists
of seven Recessive bits.

 

18.3.2.2 Error and Overload Frames

Error Frames

Error Frames are transmitted when a node detects a Bus Error. Error Frames notably consist of an Error Flag

 

which is made up of 6 consecutive bits of the same value, thus violating the bit-stuffing rule. Therefore, when a

particular node detects a Bus Error and transmits an Error Frame, all other nodes will then detect a Stuff Error

and transmit their own Error Frames in response. This has the effect of propagating the detection of a Bus Error

across all nodes on the bus. When a node detects a Bus Error, it will transmit an Error Frame starting on the next

bit. However, if the tyoe of Bus Error was a CRC Error, then the Error Frame will start at the bit following the ACK

Delim (see Section 18.3.3). The following Figure 18-2 shows the various fields of an Error Frame:

 

 

Error Frame

 

 

 

Error Delimeter
(6 bits) (0 to 6 bits) (8 bits)

Active/Passive Error Flag Error Flag Superposition

 

 

 

 

 

Figure 18-2. Various Fields of an Error Frame

Table 66: Error Frame

 

Error Frame

Description

 

Error Flag

The Error Flag has two forms, the Active Error Flag consisting of 6 Dominant bits and
the Passive Error Flag consisting of 6 Recessive bits (unless overridden by Dominant
bits of other nodes). Active Error Flags are sent by Error Active nodes, whilst Passive
Error Flags are sent by Error Passive nodes.

 

Error Flag Su-
perposition

The Error Flag Superposition field meant to allow for other nodes on the bus to transmit
their respective Active Error Flags. The superposition field can range from 0 to 6 bits,
and ends when the first Recessive bit is detected (i.e., the first it of the Delimeter).

 

Error Delimeter

 

 

The Delimeter field marks the end of the Error/Overload Frame, and consists of 8 Re-
cessive bits.

 

 

Espressif Systems

3887 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Overload Frames

An Overload Frame has the same bit fields as an Error Frame containing an Active Error Flag. The key difference
is in the conditions that can trigger the transmission of an Overload Frame. Figure 18-3 below shows the bit fields
of an Overload Frame.

 

 

Overload Flag Overload Flag Superposition Overload Delimeter

Overload Frame (6 bits) (0 to 6 bits) (8 bits)

 

 

 

 

 

 

Figure 18-3. The Bit Fields of an Overload Frame

Table 67: Overload Frame

 

Overload Frame | Description

 

Overload Flag Consists of 6 Dominant bits. Same as an Active Error Flag.

 

Overload Flag | Allows for the superposition of Overload Flags from other nodes, similar to an Error Flag
Superposition Superposition.

 

Overload De- | Consists of 8 Recessive. Same as an Error Delimeter.
limeter

 

 

 

 

Overload Frames will be transmitted under the following conditions:
1. The internal conditions of a Receiver requires a celay of the next Data or Remote Frame.
2. Detection of a Dominant bit at the first and second bit of Intermission.

3. If a Dominant bit is detected at the eighth (last) bit of an Error Delimeter. Note that in this case, TEC and
REC will not be incremented (See Section 18.3.3).

Transmitting an overload frame due to one of the conditions must also satisfy the following rules:
* Transmitting an Overload Frame due to condition 1 must only be started at the first bit of Intermission.

* Transmitting an Overload Frame due to condition 2 and 3 must start one bit after the detecting the
Dominant bit of the condition.

* A maximum of two Overload frames may be generated in order to delay the next Data or Remote
Frame.

18.3.2.3  Interframe Space

The Interframe Space acts as a separator between frames. Data Frames and Remote Frames must be separated
from preceding frames by an Interframe Space, regardless of the preceding frame’s type (Data Frame, Remote
Frame, Error Frame, Overload Frame). However, Error Frames and Overload Frames co not need to be
separated from preceding frames.

Figure 18-4 shows the fields within an Interframe Space:

Espressif Systems 888 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

 

 

Intermission Suspend Transmission Bus Idle

Interframe Space (3 bits) (8 bits, Error Passive Only) (N bits)

 

 

 

Figure 18-4. The Fields within an Interframe Space

Table 68: Interframe Space

 

Interface Space | Description

 

Intermission The Intermission consists of 3 Recessive bits.

 

Suspend Trans- | An Error Passive node that has just transmitted a message must include a Suspend
mission Transmission field. This field consists of 8 Recessive bits. Error Active nodes should
not include this field.

Bus Idle The Bus Idle field is of arbitrary length. Bus Idle ends when an SOF is transmitted. If a
node has a pending transmission, the SOF should be transmitted at the first bit following

 

Intermission.

 

 

 

 

18.3.3 TWAI Errors
18.3.3.1 Error Types

Bus Errors in TWAI are categorized into one of the following types:

Bit Error

A Bit Error occurs when a node transmits a bit value (i.e., Dominant or Recessive) but the opposite bit is detected
(e.g., a Dominant bit is transmitted but a Recessive is detected). However, if the transmitted bit is Recessive and
is located in the Arbitration Field or ACK Slot or Passive Error Flag, then detecting a Dominant bit will not be
considered a Bit Error.

Stuff Error
A stuff error is detected when 6 consecutive bits of the same value are detected (thus violating the bit-stuffing
encoding).

CRC Error

A Receiver of a Data or Remote Frame will calculate a CRC based on the bits it has received. A CRC error
occurs when the CRC calculated by the Receiver does not match the CRC sequence in the received Data or
Remote Frame.

Form Error
A Form Error is detected when a fixed-form bit field of a message contains an illegal bit. For example, the r1 and
rO fields must be Dominant.

Acknowledgement Error
An Acknowledgment Error occurs when a Transmitter does not detect a Dominant bit at the ACK Slot.

18.3.3.2 Error States

TWAI nodes implement fault confinement by each maintaining two error counters, where the counter values
determine the error state. The two error counters are known as the Transmit Error Counter (TEC) and Receive
Error Counter (REC). TWAI has the following error states.

Espressif Systems 889 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Error Active
An Error Active node is able to participate in bus communication and transmit an Active Error Flag when it
detects an error.

Error Passive

An Error Passive node is able to participate in bus communication, but can only transmit an Passive Error Flag
when it detects an error. Error Passive noces that have transmitted a Data or Remote Frame must also include
the Suspend Transmission field in the subsequent Interframe Space.

Bus Off
A Bus Off node is not permitted to influence the bus in any way (i.e., is not allowed to transmit anything).

18.3.3.3 Error Counters

The TEC and REC are incremented/decremented according to the following rules. Note that more than one
rule can apply for a given message transfer.

1. When a Receiver cetects an error, the REC will be increased by 1, except when the detected error was a
Bit Error during the transmission of an Active Error Flag or an Overload Flag.

2. When a Receiver detects a Dominant bit as the first bit after sending an Error Flag, the REC will be
increased by 8.

3. When a Transmitter sends an Error Flag the TEC is increased by 8. However, the following scenarios are
exempt form this rule:

* lf a Transmitter is Error Passive that detects an Acknowledgment Error due to not detecting a
Dominant bit in the ACK slot, it should send a Passive Error Flag. If no Dominant bit is detected in that
Passive Error Flag, the TEC should not be increased.

° A Transmitter transmits an Error Flag due to a Stuff Error during Arbitration. If the offending bit should
have been Recessive but was monitored as Dominant, then the TEC should not be increased.

4. If a Transmitter detects a Bit Error whilst sending an Active Error Flag or Overload Flag, the REC is
increased by 8.

5. If a Receiver detects a Bit Error while sending an Active Error Flag or Overload Flag, the REC is increased

by 8.

6. Any node tolerates up to 7 consecutive Dominant bits after sending an Active/Passive Error Flag, or
Overload Flag. After detecting the 14th consecutive Dominant bit (when sending an Active Error Flag or
Overload Flag}, or the 8th consecutive Dominant bit following a Passive Error Flag, a Transmitter will
increase its TEC by 8 and a Receiver will increase its REC by 8. Each additional eight consecutive
Dominant bits will also increase the TEC (for Transmitters) or REC (for Receivers) by 8 as well.

7. When a Transmitter successfully transmits a message (getting ACK and no errors until the EOF is
complete), the TEC is decremented by 1, unless the TEC is already at 0.

8. When a Receiver successfully receives a message (no errors before ACK Slot, and successful sending of
ACK), the REC is decremented.

° |f the REC was between 1 and 127, the REC is decremented by 1.

® If the REC was greater than 127, the REC is set to 127.

Espressif Systems 3890 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

° If the REC was 0, the REC remains 0.

9. Anode becomes Error Passive when its TEC and/or REC is greater than or equal to 128. The error
condition that causes a node to become Error Passive will cause the node to send an Active Error Flag.
Note that once the REC has reached to 128, any further increases to its value are irrelevant until the REC
returns to a value less than 128.

10. Anode becomes Bus Off when its TEC is greater than or equal to 256.
11. An Error Passive node becomes Error Active when both the TEC and REC are less than or equal to 127.

12. A Bus Off node can become Error Active (with both its TEC and REC reset to 0) after it monitors 128
occurrences of 11 consecutive Recessive bits on the bus.

18.3.4 TWAI Bit Timing
18.3.4.1 Nominal Bit

The TWAI protocol allows a TWAI bus to operate at a particular bit rate. However, all nodes within a TWAI bus
must operate at the same bit rate.

¢ The Nominal Bit Rate is defined as number of bits transmitted per second from an ideal Transmitter and
without any synchronization.

¢ The Nominal Bit Time is defined as 1/Nominal Bit Rate.

A single Nominal Bit Time is divided into multiple segments, and each segment is made up of multiple Time
Quanta. A Time Quantum is a fixed unit of time, and is implemented as some form of prescaled clock signal in
each node. Figure 18-5 illustrates the segments within a single Nominal Bit Time.

TWAI Controllers will operate in time steps of one Time Quanta where the state of the TWAI bus is analyzed at
every Time Quanta. If two consecutive Time Quantas have different bus states (i.e., Recessive to Dominant or
vice versa), this will be considered an edge. When the bus is analyzed at the intersection of PBS1 and PBS2, this
is considered the Sample Point and the sampled bus value is considered the value of that bit.

 

   

¥—_———_——. NOMINAL BIT TIME

 

SS PBS 1

 

 

 

Sample point

 

 

 

Figure 18-5. Layout of a Bit

Table 69: Segments of a Nominal Bit Time

 

Segment Description

 

Ss The SS (Synchronization Segment) is 1 Time Quantum long. If all nodes are perfectly
synchronized, the edge of a bit will lie in the SS.

PBS1 PBS1 (Phase Buffer Segment 1) can be 1 to 16 Time Quanta long. PBS1 is meant
to compensate for the physical delay times within the network. PBS1 can also be

 

 

 

lengthened for synchronization purposes.

 

 

Espressif Systems 391 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

 

Segment Description
PBS2 PBS2 (Phase Buffer Segment 2) can be 1 to 8 Time Quanta long. PBS2 is meant to
compensate for the information processing time of nodes. PBS2 can also be shortened

 

for synchronization purposes.

 

 

 

 

18.3.4.2 Hard Synchronization and Resynchronization

Due to clock skew and jitter, the bit timing of nodes on the same bus may become out of phase. Therefore, a bit
edge may come before or after the SS. To ensure that the internal bit timing clocks of each node are kept in
phase, TWAI has various methods of synchronization. The Phase Error “e” is measured in the number of Time
Quanta and relative to the SS.

* A positive Phase Error (e > 0) is when the edge lies after the SS and before the Sample Point (i.e., the edge
is late).

* A negative Phase Error (e < 0) is when the edge lies after the Sample Point of the previous bit and before
SS (i-e., the edge is early).

To correct for Phase Errors, there are two forms of synchronization, known as Hard Synchronization and
Resynchronization. Hard Synchronization and Resynchronization obey the following rules.

* Only one synchronization may occur in a single bit time.
® Synchronizations only occurs on Recessive to Dominant edges.

Hard Synchronization

Hard Synchronization occurs on the Recessive to Dominant edges during Bus Idle (i.e., the SOF bit). All nodes
will restart their internal bit timings such that the Recessive to Dominant edge lies within the SS of the restarted
bit timing.

Resynchronization

Resynchronization occurs on Recessive to Dominant edges not during Bus Idle. If the edge has a positive Phase
Error (e > 0), PBS1 is lengthened by a certain number of Time Quanta. If the edge has a negative Phase Error (e
< 0), PBS2 will be shortened by a certain number of Time Quanta.

The number of Time Quanta to lengthen or shorten depends on the magnitude of the Phase Error, and is also
limited by the Synchronization Jump Width (SJW) value which is a programmable.

e When the magnitude of the Phase Error is less than or equal to the SJW, PBS1/PBS2 are
lengthened/shortened by e number of Time Quanta. This has a same effect as Hard Synchronization.

* When the magnitude of the Phase Error is greater to the SUW, PBS1/PBS2 are lengthened/shortened by
the SJW number of Time Quanta. This means it may take multiple bits of synchronization before the Phase
Error is entirely corrected.

18.4 Architectural Overview
The ESP82-S2 contains a TWAI Controller. Figure 18-6 show show the major functional blocks of the TWAI
Controller.

Espressif Systems 892 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

 

 

 

 

 

Host Coniroller
4

Addr] Data # 4? Control
vVvY¥

Registers

>

 

 

 

 

 

 

 

 

 

Configuration | Receive Buffer | Command | Error Management | Interrupt & Status | Transmit Buffer

thet

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Receive FIFO Error
Da Management \ 7
Logic
4s i 4
L__, fa
Acceptance Filter 5
£ A
a | E |

 

 

 

 

Bit Stream Processing

4 U We | csrsoee run

Bit Timing Logic

 

 

 

 

 

 

 

 

 

 

 

 

 

 

v q v
CLKOUT RX T™ BUS_OFF

 

 

 

Figure 18-6. TWAI Overview Diagram

18.4.1 Registers Block

The ESP82-S2 CPU accesses peripherals as 32-bit aligned words. However, the majority of registers in the TWAI
controller only contain useful data at the least significant byte (bits [7:0]). Therefore, in these registers, bits [81:8]
are ignored on writes, and return 0 on reads.

Configuration Registers

The configuration registers store various configuration options for the TWAI controller such as bit rates, operating
mode, Acceptance Filter etc. Configuration registers can only be modified whilst the TWAI controller is in Reset
Mode (See Section 18.5.1).

Command Register

The command register is used by the CPU to drive the TWAI controller to initiate certain actions such as
transmitting a message or clearing the Receive Buffer. The command register can only be modified when the
TWAI controller is in Operation Mode (see section 18.5.1).

Interrupt & Status Registers
The interrupt register indicates what events have occurred in the TWAI controller (each event is represented by a
separate bit). The status register indicates the current status of the TWAI controller.

Error Management Registers

The error management registers include error counters and capture registers. The error counter registers
represent TEC and REC values. The capture registers will record information about instances where TWAI
controller detects a bus error, or when it loses arbitration.

Transmit Buffer Registers
The transmit buffer is a 13-byte buffer used to store a TWAI message to be transmitted.

Espressif Systems 893 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Receive Buffer Registers
The Receive Buffer is a 18-byte buffer which stores a single message. The Receive Buffer acts as a window into
Receive FIFO mapping to the first received message in the Receive FIFO to the Receive Buffer.

Note that the Transmit Buffer registers, Receive Buffer registers, and the Acceptance Filter registers share the
same address range (offset Ox0040 to 0x0070). Their access is governed by the following rules:

e When the TWAI controller is in Reset Mode, the address range maps to the Acceptance Filter registers.
e When the TWAI controller is in Operation Mode:
— All reads to the address range maps to the Receive Buffer registers.

- All writes to the address range maps to the Transmit Buffer registers.

18.4.2 Bit Stream Processor

The Bit Stream Processing (BSP) module is responsible for framing data from the Transmit Buffer (e.g. bit stuffing
and additional CRC fields) and generating a bit stream for the Bit Timing Logic (BTL) module. At the same time,
the BSP module is also responsible for processing the received bit stream (e.g., de-stuffing and verifying CRC)
from the BTL module and placing the message into the Receive FIFO. The BSP will also detect errors on the
TWAI bus and report them to the Error Management Logic (EML).

18.4.3 Error Management Logic

The Error Management Logic (EML) module is responsible for updating the TEC and REC, recording error
information like error types and positions, and updating the error state of the TWAI Controller such that the BSP
module generates the correct Error Flags. Furthermore, this module also records the bit position when the TWAI
controller loses arbitration.

18.4.4 Bit Timing Logic

The Bit Timing Logic (BTL) module is responsible for transmitting and receiving messages at the configured bit
rate. The BTL module also handles synchronization of out of phase bits such that communication remains stable.
A single bit time consists of multiple programmable segments that allows users to set the length of each segment
to account for factors such as propagation delay and controller processing time etc.

18.4.5 Acceptance Filter

The Acceptance Filter is a programmable message filtering unit that allows the TWAI controller to accept or reject
a received message based on the message’s ID field. Only accepted messages will be stored in the Receive
FIFO, The Acceptance Filter’s registers can be programmed to specify a single filter, or specify two separate filters
(dual filter mode).

18.4.6 Receive FIFO

The Receive FIFO is a 64-byte buffer (internal to the TWAI controller) that stores received messages accepted by
the Acceptance Filter. Messages in the Receive FIFO can vary in size (between 3 to 13-bytes). When the Receive
FIFO is full (or does not have enough space to store the next received message in its entirety), the Overrun
Interrupt will be triggered, and any subsequent received messages will be lost until adequate space is cleared in
the Receive FIFO. The first message in the Receive FIFO will be mapped to the 13-byte Receive Buffer until that
message is cleared (using the Release Receive Buffer command bit). After clearing, the Receive Buffer will map
to the next message in the Receive FIFO, and the space occupied by the previous message in the Receive FIFO
can be used to receive new messages.

Espressif Systems 394 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

18.5 Functional Description

18.5.1 Modes
The ESP82-S2 TWAI controller has two working modes: Reset Mocle and Operation Mode. Reset Mode and
Operation Mode are entered by setting the TWAlL_RESET_MODE bit to 1 or 0 respectively.

18.5.1.1 Reset Mode

Entering Reset Mode is required in order to modify the various configuration registers of the TWAI controller.
When entering Reset Mode, the TWAI controller is essentially disconnected from the TWAI bus. When in Reset
Mode, the TWAI controller will not be able to transmit any messages (including error signaling). Any transmission
in progress is immediately terminated. Likewise, the TWAI controller will also not be able to receive any
messages.

18.5.1.2 Operation Mode

Entering Operation Mode essentially connects the TWAI controller to the TWAI bus, and write protects the TWAI
controller’s configuration registers ensuring the configuration stays consistent during operation. When in
Operation Mode, the TWAI controller can transmit and receive messages (including error signaling) depending on
which operating sub-mode the TWAI controller was configured with. The TWAI controller supports the following
operating sub-modes:

* Normal Mode: The TWAI controller can transmit and receive messages including error signaling (such as
Error and Overload Frames).

° Self Test Mode: Like Normal Mode, but the TWAI controller will consider the transmission of a Data or
RTR Frame successful even if it was not acknowledged. This is commonly used when self testing the TWAI
controller.

* Listen Only Mode: The TWAI controller will be able to receive messages, but will remain completely
passive on the TWAI bus. Thus, the TWAI controller will not be able to transmit any messages,
acknowledgments, or error signals. The error counters will remain frozen. This mode is useful for TWAI bus
monitors.

Note that when exiting Reset Mode (i.e., entering Operation Mode), the TWAI controller must wait for 11
consecutive Recessive bits to occur before being able to fully connect the TWAI bus (i.e., be able to transmit or
receive).

18.5.2 Bit Timing

The operating bit rate of the TWAI controller must be configured whilst the TWAI controller is in Reset Mode. The
bit rate configuration is located in TWAIBUS_TIMING_O_REG and TWAIBUS_TIMING_1_REG, and the two
registers contain the following fields:

The following Table 70 illustrates the bit fields of TWAL BUS_TIMING_O_REG.

Table 70: Bit Information of TWAIL CLOCK _DIVIDER_REG; TWAI Address 0x18

 

 

 

 

 

 

 

 

 

 

 

 

Bit 31-16 Bit 15 Bit 14 Bit 13 Biti2 |... Bit 1 Bit O
Reserved SJW.1 SJW.0 BRP.13 BRP12 |... BRP.1 BRP.O

Notes:

Espressif Systems 3895 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
18. TWAI

 

© SJW: Synchronization Jump Width (GJW) is configured in SJW.0 and SJW.1 where SUW = (2 x SUW.1 +
SJW.0 + 1).

° BRP: The TWAI Time Quanta clock is derived from a prescaled version of the APB clock that is usually 80
MHz. The Baud Rate Prescaler (BRP) field is used to define the prescaler according to the equation below,
where tr, is the Time Quanta clock period and te,x is APB clock period :
tra =2 x tong x (2° x BRP.13 + 2? x BRP.12+... + 2! x BRP1 + 2° x BRRO + 1)

The following Table 77 illustrates the bit fields of TWA BUS_TIMING_1_REG.

Table 71: Bit Information of TWAL BUS _TIMING_1_REG; TWAI Address Ox1c

 

 

 

 

 

 

 

 

 

 

 

 

 

Bit 31-8 Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0
Reserved | SAM PBS82.2 PBS2.1 PBS2.0 PBS1.3 PBS1.2 PBS1.1 PBS1.0
Notes:

* PBS1: The number of Time Quanta in Phase Buffer Segment 1 is defined according to the following
equation: (8 x PBS1.3 + 4 x PBS1.2 + 2 x PBS1.1 + PBS1.0 + 1).

* PBS2: The number of Time Quanta in Phase Buffer Segment 2 is defined according to the following
equation: (4 x PBS2.2 + 2 x PBS2.1 + PBS2.0 + 1).

© SAM: Enables triple sampling if set to 1. This is useful for low/medium speed buses where filtering spikes
on the bus line is beneficial.

18.5.3 Interrupt Management

The ESP82-S2 TWAI controller provides seven interrupts, each represented by a single bit in the

TWAIL INT _RAW_REG. For a particular interrupt to be triggered (i.e., its bit in TWALINT_RAW_REG set to 1), the
interrupt’s corresponding enable bit in TWAIL INT ENA_REG must be set.

The TWAI controller provides the seven following interrupts:
© Receive Interrupt
¢ Transmit Interrupt
© Error Warning Interrupt
® Data Overrun Interrupt
* Error Passive Interrupt
* Arbitration Lost Interrupt
* Bus Error Interrupt

The TWAI controller's interrupt signal to the interrupt matrix will be asserted whenever one or more interrupt bits
are set in the TWAIINT_RAW_REG, and deasserted when all bits in TWAILINT_RAW_REG are cleared. The
majority of interrupt bits in TWAIINT_RAW_REG are automatically cleared when the register is read. However,
the Receive Interrupt is an exception and can only be cleared the Receive FIFO is empty.

18.5.3.1 Receive Interrupt (RXI)

The Receive Interrupt (RXI) is asserted whenever the TWAI controller has received messages that are pending to
read from the Receive Buffer (i.e., when TWAILRX_MESSAGE_CNT_REG > 0). Pending received messages

Espressif Systems 396 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

includes valid messages in the Receive FIFO and also overrun messages. The RX! will not be deasserted until all
pending received messages are cleared using the TWAILRELEASE_BUF command bit.

18.5.3.2 Transmit Interrupt (TXI)

The Transmit Interrupt (TX)) is triggered whenever Transmit Buffer becomes free, indicating another message can
be loaded into the Transmit Buffer to be transmitted. The Transmit Buffer becomes free under the following

scenarios:

* A message transmission has completed successfully (i.e., Acknowledged without any errors). Any failed
messages will automatically be retried.

* A single shot transmission has completed (successfully or unsuccessfully, indicated by the
TWAITX_COMPLETE bit).

* A message transmission was aborted using the TWAlLABORT_TX command bit.

18.5.3.3 Error Warning Interrupt (EWI)

The Error Warning Interrupt (EW) is triggered whenever there is a change to the TWAI_ERR_ST or
TWAILBUS_OFF_ST bits of the TWAILSTATUS_REG (e., transition from 0 to 1 or vice versa). Thus, an EW!
could indicate one of the following events, depending on the values TWAILERR_ST or TWAL_BUS_OFF_ST at the

moment the EWI is triggered.
© If WAILERR_ST =0 or TWAILBUS_OFF_ST = 0:

— lf the TWAI controller was in the Error Active state, it indicates both the TEC and REC have returned
below the threshold value set by TWALERR_WARNING_LIMIT_REG.

— If the TWAI controller was previously in the Bus Recovery state, it indicates that Bus Recovery has
completed successtully.

© If TWAILERR_ST = 1 or TWALBUS_OFF_ST = 0: The TEC or REC error counters have exceeded the
threshold value set by TWALERR_WARNING_LIMIT_REG.

© If TWAILERR_ST = 1 or TWALBUS_OFF_ST = 1: The TWAI controller has entered the BUS_OFF state (due
to the TEC >= 256).

© If WAIERR_ST = 0 or TWALBUS_OFF_ST = 1: The TWAI controller’s TEC has dropped below the
threshold value set by TWALERR_WARNING_LIMIT_REG during BUS_OFF recovery.

18.5.3.4 Data Overrun Interrupt (DOI)

The Data Overrun Interrupt (DOI) is triggered whenever the Receive FIFO has overrun. The DO! indicates that the
Receive FIFO is full and should be cleared immediately to prevent any further overrun messages.

The DOI is only triggered on the first message that causes the Receive FIFO to overrun (i.e., the transition from
the Receive FIFO not being full to the Receive FIFO overrunning). Any subsequent overrun messages will not
trigger the DOI again. The DOI will only be able to trigger again when all received messages (valid or overrun)

have been cleared.

Espressif Systems 897 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

18.5.3.5 Error Passive Interrupt (TXI)

The Error Passive Interrupt (EPI) is triggered whenever the TWAI controller transitions from Error Active to Error
Passive, or vice versa.

18.5.3.6 Arbitration Lost Interrupt (ALI)

The Arbitration Lost Interrupt (ALI) is triggered whenever the TWAI controller is attempting to transmit a message
and loses arbitration. The bit position where the TWAI controller lost arbitration is automatically recorded in
Arbitration Lost Capture register (TWAlLARB LOST CAP_REG). When the ALI occurs again, the Arbitration Lost
Capture register will no longer record new bit location until it is cleared (via a read from the CPU).

18.5.3.7 Bus Error Interrupt (BEI)

The Bus Error Interrupt (BEI) is triggered whenever TWAI controller observes an error on the TWAI bus. When a
bus error occurs, the Bus Error type and its bit position are automatically recorded in the Error Code Capture
register (TWAILERR_CODE_CAP_REG). When the BEI occurs again, the Error Code Capture register will no
longer record new error information until it is cleared (via a read from the CPU).

18.5.4 Transmit and Receive Buffers
18.5.4.1. Overview of Buffers

Table 72: Buffer Layout for Standard Frame Format and Extended Frame Format

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Standard Frame Format (SFF) Extended Frame Format (EFF)

TWAI address Content TWAI address Content

0x40 TX/RX frame information 0x40 TX/RX frame information
0x44 TX/RX identifier 1 0x44 TX/RX identifier 1
0x48 TX/RX identifier 2 0x48 TX/RX identifier 2
Ox4c TX/RX data byte 1 Ox4c TX/RX identifier 3
0x50 TX/RX data byte 2 0x50 TX/RX identifier 4
Ox64 TX/RX data byte 3 0x54 TX/RX data byte 1
0x58 TX/RX data byte 4 0x58 TX/RX data byte 2
Ox5c TX/RX data byte 5 Ox5c TX/RX data byte 3
Ox60 TX/RX data byte 6 Ox60 TX/RX data byte 4
Ox64 TX/RX data byte 7 Ox64 TX/RX data byte 5
Ox68 TX/RX data byte 8 Ox68 TX/RX data byte 6
Ox6c reserved Ox6c TX/RX data byte 7
0x70 reserved 0x70 TX/RX data byte 8

 

 

 

 

 

Table 72 illustrates the layout of the Transmit Buffer and Receive Buffer registers. Both the Transmit and Receive
Buffer registers share the same address space and are only accessible when the TWAI controller is in Operation
Mode. CPU write operations will access the Transmit Buffer registers, and CPU read operations will access the
Receive Buffer registers. However, both buffers share the exact same register layout and fields to represent a
message (received or to be transmitted). The Transmit Buffer registers are used to configure a TWAI message to
be transmitted. The CPU would write to the Transmit Buffer registers specifying the message’s frame type, frame

Espressif Systems 398 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

format, frame ID, and frame data (payload). Once the Transmit Buffer is configured, the CPU would then initiate
the transmission by setting the TWAI_TX_REQ bit in TWAI_CMD_REG.

* For a self-reception request, set the TWAI_SELF_RX_REQ bit instead.
* For a single-shot transmission, set both the TWAI_TX_REQ and the TWAILABORT_TX simultaneously.

The Receive Buffer registers map to the first message in the Receive FIFO. The CPU would read the Receive
Buffer registers to obtain the first message’s frame type, frame format, frame ID, and frame data (payload). Once
the message has been read from the Receive Buffer registers, the CPU can set the TWAI_RELEASE_BUF bit in
TWAICMD_REG so that the next message in the Receive FIFO will be loaded in to the Receive Buffer

registers.

18.5.4.2 Frame Information

The frame information is one byte long and specifies a message’s frame type, frame format, and length of data.
The frame information fields are shown in Table 73.

Table 73: TX/RX Frame Information (SFF/EFF) TWAI Address 0x40

 

 

 

 

 

 

 

 

 

 

 

 

 

Bit 31-8 Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0
Reserved | FF! RTR? x8 x8 XDLC.3* | DLC.24 DLC.1+ DLC.0*
Notes:

e FF: The Frame Format (FF) bit specifies whether the message is Extended Frame Format (EFF) or Standard
Frame Format (SFF). The message is EFF when FF bit is 1, and SFF when FF bit is 0.

* RTR: The Remote Transmission Request (RTR) bit specifies whether the message is a Data Frame or a
Remote Frame. The message is a Remote Frame when the RTR bit is 1, and a Data Frame when the RTR
bit is O.

* DLC: The Data Length Code (DLC) field specifies the number of data bytes for a Data Frame, or the
number of data bytes to request in a Remote Frame. TWAI Data Frames are limited to a maximum payload
of 8 data bytes, thus the DLC should range anywhere from 0 to 8.

° X: Don’t care, can be any value.

18.5.4.3 Frame Identifier

The Frame Identifier fields is 2 bytes (11-bits) if the message is SFF, and 4 bytes (29-bits) if the message is
EFF.

The Frame Identifier fields for an SFF (11 -bits) message is shown in Table 74-75.

Table 74: TX/RX Identifier 1 (SFF); TWAI Address 0x44

 

 

 

 

 

 

 

 

 

 

 

 

 

Bit 31-8 | Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit O
Reserved | ID.28 ID.27 ID.26 ID.25 ID.24 ID.23 ID.22 ID.21
Espressif Systems 3899 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
18. TWAI

 

Table 75: TX/RX Identifier 2 (SFF); TWAI Address 0x48

 

Bit 31-8 | Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit O
Reserved | ID.20 ID.19 ID.18 xt x? x? x x?

 

 

 

 

 

 

 

 

 

 

 

 

The Frame Identifier fields for an EFF (29-bits) message is shown in Table 76-79.

Table 76: TX/RX Identifier 1 (EFF); TWAI Address 0x44

 

Bit 31-8 | Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit O
Reserved | |D.28 ID.27 ID.26 ID.25 ID.24 ID.23 ID.22 ID.21

 

 

 

 

 

 

 

 

 

 

 

 

Table 77: TX/RX Identifier 2 (EFF); TWAI Address 0x48

 

Bit 31-8 | Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit O
Reserved | ID.20 ID.19 ID.18 ID.17 ID.16 ID.15 ID.14 ID.13

 

 

 

 

 

 

 

 

 

 

 

 

Table 78: TX/RX Identifier 3 (EFF); TWAI Address 0x4c

 

Bit 31-8 | Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit O
Reserved | ID.12 ID.14 ID.10 ID.9 ID.8 ID.7 ID.6 IDS

 

 

 

 

 

 

 

 

 

 

 

 

Table 79: TX/RX Identifier 4 (EFF); TWAI Address 0x50

 

Bit 31-8 | Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit O
Reserved | |D.4 ID.3 ID.2 ID.1 ID.O xt x x?

 

 

 

 

 

 

 

 

 

 

 

 

18.5.4.4 Frame Data

The Frame Data fields contains the payload of transmitted or received a Data Frame, and can range from 0 to 8
bytes. The number of valid bytes should be equal to the DLC. However, if the DLC is larger than 8, the number of
valid bytes would still be limited to 8. Remote Frames do not have data payloads, thus the Frame Data fields will
be unused.

For example, when transmitting a Data Frame with 5 data bytes, the CPU should write a value of 5 to the DLC
field, and then fill in data bytes 1 to 5 in the Frame Data fields. Likewise, when receiving a Data Frame with a DLC
of 5, only data bytes 1 to 5 will contain valid payload data for the CPU to read.

18.5.5 Receive FIFO and Data Overruns

The Receive FIFO is a 64-byte internal buffer used to store received messages in First In First Out order. A single
received message can occupy between 3 to 13-bytes of space in the Receive FIFO, and their byte layout is
identical to the register layout of the Receive Buffer registers. The Receive Buffer registers are mapped to the
bytes of the first message in the Receive FIFO. When the TWAI controller receives a message, it will increment
the value of TWAI_RX_MESSAGE_COUNTER up to a maximum of 64. If there is adequate space in the Receive
FIFO, the message contents will be written into the Receive FIFO. Once a message has been read from the
Receive Buffer, the TWALRELEASE_BUF bit should be set. This will decrement
TWAILRX_MESSAGE_COUNTER and free the space occupied by the first message in the Receive FIFO. The

Espressif Systems 400 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Receive Buffer will then map to the next message in the Receive FIFO. A data overrun occurs when the TWAI
controller receives a message, but the Receive FIFO lacks the adequate free space to store the received
message in its entirety (either due to the message contents being larger than the free space in the Receive FIFO,
or the Receive FIFO being completely full).

When a data overrun occurs...

e Whatever free space is left in the Receive FIFO is filled with the partial contents of the overrun message. If
the Receive FIFO is already full, then none of the overrun message’s contents will be stored.

* On the first message that causes the Receive FIFO to overrun, a Data Overrun Interrupt will be triggered.
* Each overrun message will still increment the TWAI_RX_MESSAGE_COUNTER up to a maximum of 64.

* The RX FIFO will internally mark overrun messages as invalid. The TWAIMISS_ST bit can be used to
determine whether the message currently mapped to by the Receive Buffer is valid or overrun.

To clear an overrun Receive FIFO, the TWAI_ RELEASE _BUF must be called repeatedly called until
TWAILRX_MESSAGE_COUNTER is 0. This has the effect of freeing all valid messages in the Receive FIFO and
Clearing all overrun messages.

18.5.6 Acceptance Filter

The Acceptance Filter allows the TWAI controller to filter out received messages based on their ID (and optionally
their first data byte and frame type). Only accepted messages are passed on to the Receive FIFO. The use of
Acceptance Filters allows for a more lightweight operation of the TWAI controller (e.g., less use of Receive FIFO,
fewer Receive Interrupts) due to the TWAI Controller only needing to handle a subset of messages.

The Acceptance Filter configuration registers can only be accessed whilst the TWAI controller is in Reset Mode,
due to those registers sharing the same address space as the Transmit Buffer and Receive Buffer registers.

The registers consist of a 82-bit Acceptance Code Value and a 32-bit Acceptance Mask Value. The Code value
specifies a bit pattern in which each filtered bit of the message must match in order for the message to be
accepted. The Mask value is able to mask out certain bits of the Code value (i.e., set as “Don’t Care” bits). Each
filtered bit of the message must either match the acceptance code or be masked in order for the message to be
accepted, as demonstrated in Figure 18-7.

The TWAI Controller Acceptance Filter allows the 32-bit Code and Mask values to either define a single filter (i-e.,
Single Filter Mode), or two filters (i.e., Dual Filter Mode). How the Acceptance Filter interprets the 32-bit code and
mask values is dependent on whether Single Filter Mode is enabled, and the received message (i.e., SFF or

EFF).
message bit |
[ =
XNOR Sf OR FL AND , 5 = et epeephed
acceptance code bit — +

acceptance mask bit

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 18-7. Acceptance Filter

18.5.6.1 Single Filter Mode

Single Filter Mode is enabled by setting the TWAI_RX_FILTER_MODE bit to 1. This will cause the 32-bit code and
mask values to define a single filter. The single filter can filter the following bits of a Data or Remote Frame:

Espressif Systems 401 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

° SFF

- The entire 11-bit ID

— RIR bit

— Data byte 1 and Data byte 2

° EFF

- The entire 29-bit ID

— RIR bit

The following Figure 18-8 illustrates how the 32-bit code and mask values will be interpreted under Single Filter

Mode.

 

ID = Identifier
DB = Data Byte

ACR = TWAILACCEPTANCE_CODE
AMR = TWAIL_ACCEPTANCE_MASK

 

ACRO — Addr 0x0040

ACR1 — Addr 0x0044

ACR2 — Addr 0x0048

ACR3 — Addr 0x004C

 

7/6|5/4/3/2/1/0

7/6|/5/4/3/2[/1/0

7/6|5/4/3/2/1/0

7/6|5]/4/3|/2/1]/0

 

 

AMRO — Addr 0x0050

AMR1 — Addr 0x0054

AMR2 — Addr 0x0058

AMR3 — Addr 0x005C

 

7/6|5/4/3/2/1/0

7[6|5/4/3/2/1/0

7|6|5|4/ 3/2] 1/0

7|6|5|/4/3|2]1]0

 

 

 

 

 

 

 

 

 

 

 

 

 

 

wu jainje@iwlslelala) |olaloly)/ 8) 8/8/58) |S/Elm/+[alaiaja] [njamis|minjajo
b lalalslaiaialaal laialalzlzlziziz| Bla/sla/ala/ala| (Salsas aaa
* yeeayaejea\a; (A Qeresysys|5| jalalalajajajaja| jalalajajajalaja

OOO | TIM N SIA Ar oOo; +) N So 3/3
t JAINIQ/AINIQININ| [RASS ASS) SaSseiaine a) jaja a) a
W jajaiaidjajdjaia) ajaajadiaja/a) jajajgeeajaiee) ajaaa case

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 18-8. Single Filter Mode

18.5.6.2 Dual Filter Mode

Dual Filter Mode is enabled by setting the TWAILRX_FILTER_MODE bit to 0. This will cause the 32-bit code and
mask values to define a two separate filters, referred to as filter 1 or two. Under Dual Filter Mode, a message will
be accepted if it is accepted by one of the two filters.

The two filters can filter the following bits of a Data or Remote Frame:
© SFF
— The entire 11-bit ID
— RTR bit
— Data byte 1 (for filter 1 only)
© EFF
— The first 16 bits of the 29-bit ID

The following Figure 18-9 illustrates how the 32-bit code and mask values will be interpreted uncer Dual Filter
Mode.

402
Submit Documentation Feedback

Espressif Systems ESP32-S2 TRM (Preliminary V0.4)
18. TWAI

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

ID = Identifier © ACR =TWAIACCEPTANCE_CODE
DB =Data Byte 9 AMR =TWAI_ACCEPTANCE_MASK
Filter 1
ACRO — Addr 0x0040 ACR1 — Addr 0x0044 ACR3 — Addr 0x0044
7(/6/5/4/3/2|1/0| |7/6/5]4/3/2]1/0| |7[/6[/5]/4/3/2\1/0
AMRO — Addr 0x0050 AMR1 — Addr 0x0044 AMR3 — Addr 0x0044
7(6/5/4/3/2\1/0| |7/6[/5]/4/3/2]1/0| |7/6/5]/4/3/2\1/0
Orlow) +t /alaid O/M)/ 0 N/e);4a\)— Q)N)4/o
ir IMINININ/AINIAQIN) [QS aE | didja |i)
G |G/adjaldjajaja| jaajaix|a\g a9 moO | oo oo
Lb TRRIQAA RAVAN (AAaSs asia
W |O\o\agjajgiaja) jaidajdjdia aja
Filter 2
ACR2 — Addr 0x0048 ACR3 — Addr 0x004C
7(/6/5/4/3/2|1/0| |7/6[/5/4/3/2\/1/0
AMR2 — Addr 0x0058 AMR3 — Addr 0x005C
7/6/5/4/3/2/1)0] |7/6/5/4/3|2]1]0
b NAAM A QNN gase
G |Aagaljdiadjaja |jdjaid/e
+ IRINA VAN (RABs Sasa
ui |O/a\a ajajgjiaja) jagjaldjdid aja
Figure 18-9. Dual Filter Mode

18.5.7 Error Management

The TWAI protocol requires that each TWAI noce maintains the Transmit Error Count (TEC) and Receive Error
Count (REC). The value of both error counts determine the current error state of the TWAI controller (i.e., Error
Active, Error Passive, Bus-Off). The TWAI controller stores the TEC and REC values in the
TWAITX_ERR_CNT_REG and TWAI_RX_ERR_CNT_REG respectively, and can be read by the CPU at anytime.
In addition to the error states, the TWAI controller also offers an Error Warning Limit (EWL) feature that can warn
the user regarding the occurrence of severe bus errors before the TWAI controller enters the Error Passive
state.

The current error state of the TWAI controller is indicated via a combination of the following values and status bits:
TEC, REC, TWAIERR_ST, and TWAI_BUS_OFF_ST. Certain changes to these values and bits will also trigger

403
Submit Documentation Feedback

Espressif Systems ESP32-S2 TRM (Preliminary V0.4)
18. TWAI

 

interrupts, thus allowing the users to be notified of error state transitions (see section 18.5.3). The following figure
18-10 shows the relation between the error states, values and bits, and error state related interrupts.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Error Warning Limit 497
TEC,REC © (defauit96) TEC > 255 Note 3
Error Active Error Passive Bus Off
=—
Error Warning Error Passive Error Warning Error Warning
Interrupt Interrupt Interrupt Interrupt
Error status | 0 1
Bus status | 0 1
TEC : Tx Error Counter
REC : Rx Error Counter

 

 

 

Figure 18-10. Error State Transition

18.5.7.1. Error Warning Limit

The Error Warning Limit (EWL) feature is a configurable threshold value for the TEC and REC, where if exceeded,
will trigger an interrupt. The EWL is intended to serve as a warning about severe TWAI bus errors, and is
triggered before the TWAI controller enters the Error Passive state. The EWL is configured in the
TWAILERR_WARNING_LIMIT_REG and can only be configured whilst the TWAI controller is in Reset Mode. The
TWAILERR_WARNING_LIMIT_REG has a default value of 96. When the values of TEC and/or REC are larger than
or equal to the EWL value, the TWAI_ERR_ST bit is immediately set to 1. Likewise, when the values of both the
TEC and REC are smaller than the EWL value, the TWAI_ERR_ST bit is immediately reset to 0. The Error Warning
Interrupt is triggered whenever the value of the TWAI_ERR_ST bit (or the TWALBUS_OFF_ST) changes.

18.5.7.2 Error Passive

The TWAI controller is in the Error Passive state when the TEC or REC value exceeds 127. Likewise, when both
the TEC and REC are less than or equal to 127, the TWAI controller enters the Error Active state. The Error
Passive Interrupt is triggered whenever the TWAI controller transitions from the Error Active state to the Error
Passive state or vice versa.

18.5.7.3 Bus-Off and Bus-Off Recovery

The TWAI controller enters the Bus-Off state when the TEC value exceeds 255. On entering the Bus-Off state,
the TWAI controller will automatically do the following:

* Set REC to 0

® Set TEC to 127

® Set the TWAl_BUS_OFF_ST bit to 1
* Enter Reset Mode

The Error Warning Interrupt is triggered whenever the value of the TWAILBUS_OFF_ST bit (or the TWAI_ERR_ST
bit) changes.

Espressif Systems 404 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

To return to the Error Active state, the TWAI controller must undergo Bus-Off recovery. Bus-Off recovery requires
the TWAI controller to observe 128 occurrences of 11 consecutive Recessive bits on the bus. To initiate Bus-Off
recovery (after entering the Bus-Off state), the TWAI controller should enter Operation Mode by setting the
TWAIRESET_MODE bit to 0. The TEC tracks the progress of Bus-Off recovery by decrementing the TEC each
time the TWAI controller observes 11 consecutive Recessive bits. When Bus-Off recovery has completed (i.e.,
TEC has decremented from 127 to 0), the TWAILBUS_OFF_ST bit will automatically be reset to 0, thus triggering
the Error Warning Interrupt.

18.5.8 Error Code Capture

The Error Code Capture (ECC) feature allows the TWAI controller to record the error type and bit position of a
TWAI bus error in the form of an error code. Upon detecting a TWAI bus error, the Bus Error Interrupt is triggered
and the error code is recorded in the TWAI_ERR_CODE_CAP_REG. Subsequent bus errors will trigger the Bus
Error Interrupt, but their error codes will not be recorded until the current error code is read from the
TWALERR_CODE_CAP_REG.

The following Table 80 shows the fields of the TWALERR_CODE_CAP_REG:

Table 80: Bit Information of TWAl_ERR_CODE_CAP_REG; TWAI Address 0x30

 

 

 

 

 

 

 

 

 

 

 

 

 

Bit 31-8 Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0
Reserved | ERRC.1! | ERRC.O! | DIR? SEG.4° SEG.3° SEG.2 SEG.13 SEG.08
Notes:

e® ERRC: The Error Code (ERRC) indicates the type of bus error: 00 for bit error, 01 for form error, 10 for stuff
error, 11 for other type of error.

* DIR: The Direction (DIR) indicates whether the TWAI controller was transmitting or receiving when the bus
error: O for Transmitter, 1 for Receiver.

® SEG: The Error Segment (SEG) indicates which segment of the TWAI message (i.e., bit position) the bus
error occurred at.

The following Table 81 shows how to interpret the SEG.O to SEG.4 bits.

Table 81: Bit Information of Bits SEG.4 - SEG.O

 

Bit SEG.4 Bit SEG.3 Bit SEG.2 Bit SEG.1 Bit SEG.O Description
0

 

oO

start of frame
ID.28 to ID.21
ID.20 to ID.18
bit SRTR*

bit IDE?

ID.17 to ID.13
ID.12 to ID.5
ID.4 to ID.O
bit RTR
reserved bit 1

 

 

 

 

 

 

 

 

 

 

reserved bit 0

 

data length code
data field

 

OLOlOSO/O}/O;/Ol/Os;O;/oOs;o];ol;o
jaf/eal;fAf/]f]]Aay ay o;/o;o;o;o
o1roljo;-;7;A};-;/-f}/ef}/Aal}aAayasyo
jSalAaylol;oy;o;A]s]/AayAl;o;o;A]ayA
O};AlAalAayoso;A-lAalAalo;o;o;Aa

 

 

 

 

 

 

 

 

Espressif Systems 405 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

 

Bit SEG.4

Bit SEG.3

Bit SEG.2

Bit SEG.1

Bit SEG.O

Description

 

0

oO

CRC sequence

 

CRC delimiter

 

acknowledge slot

 

acknowledge clelimiter

 

end of frame

 

intermission

 

active error flag

 

passive error flag

 

tolerate dominant bits

 

error delimiter

 

oa}of/oafo} uf] af oa] oa] af] ui

 

alolololo|ofa}]Aa}slAajalsa

 

 

jaye 7/O!}])/O;oOy;O;oO};o;o!;o

 

o};Aafaflalo}Aalalalolo

 

O;F7; ey /o;+7/;/oy;o];-]Ay}o;o

 

overload flag

 

Notes:

e Bit RTR: under Standard Frame Format.

© Identifier Extension Bit: O for Standard Frame Format.

18.5.9 Arbitration Lost Capture
The Arbitration Lost Capture (ALC) feature allows the TWAI controller to record the bit position where it loses
arbitration. When the TWAI controller loses arbitration, the bit position is recorded in the TWAILARB LOST
CAP_REG and the Arbitration Lost Interrupt is triggered.

Subsequent loses in arbitration will trigger the Arbitration Lost Interrupt, but will not be recorded in the TWAI_ARB

LOST CAP_REG until the current Arbitration Lost Capture is read from the TWAI_ERR_CODE_CAP_REG.

Table 82 illustrates the bit fields of the TWAIERR_CODE_CAP_REG whilst Figure 18-11 illustrates the bit
positions of a TWAI message.

Table 82: Bit Information of TWAlL ARB LOST CAP_REG; TWAI Address 0x2c

 

 

 

 

 

 

 

 

 

Bit 31-5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0
Reserved BITNO.41 BITNO.3! BITNO.2? BITNO.1 BITNO.O1
Notes:

¢ BITNO: Bit Number (BITNO) indicates the nth bit of a TWAl message where arbitration was lost.

 

Extended frame messages

 

 

 

bitO bit1 bit2 ...

bitlo bitl1 bit12

bit13 biti4 ...

bit30_bit31

 

SOF

 

 

 

Identifier
ID28-ID18

 

SRTR

IDE

 

 

Identifier
ID17-IDO

RTR

 

 

 

Figure 18-11. Positions of Arbitration Lost Bits

Espressif Systems

406

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 

 
18. TWAI

 

18.6 Register Summary

 

Name

Description

Address | Access

 

Configuration Registers

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

TWAILMODE_REG Mode Register Ox0000 | R/W
TWAIBUS_TIMING_O_REG Bus Timing Register 0 0x0018 | RO | RAV
TWAILBUS_TIMING_1_REG Bus Timing Register 1 O0x001C | RO | RAV
TWAIERR_WARNING_LIMIT_REG Error Warning Limit Register 0x0034 | RO | RAV
TWAIL DATA_O_REG Data Register 0 0x0040 | WO | RAV
TWAILDATA_1_REG Data Register 1 0x0044 | WO | RAV
TWAIL DATA_2_REG Data Register 2 0x0048 | WO | RAV
TWAIL DATA_3 REG Data Register 3 Ox004C | WO | RAV
TWAILDATA_4_REG Data Register 4 0x0050 | WO | RAV
TWAILDATA_5 REG Data Register 5 0x0054 | WO | RAV
TWAILDATA_6_REG Data Register 6 0x0058 | WO | RAV
TWAILDATA_7_REG Data Register 7 Ox005C | WO | RAV
TWAIL DATA_8 REG Data Register 8 Ox0060 | WO | RO
TWAILDATA_9_ REG Data Register 9 0x0064 | WO | RO
TWAI DATA_10_REG Data Register 10 O0x0068 | WO | RO
TWAILDATA_11_REG Data Register 11 Ox006C | WO | RO
TWAILDATA_12_REG Data Register 12 0x0070 | WO1RO
TWAIL CLOCK_DIVIDER_REG Clock Divider Register Ox007C | varies
Control Registers

TWAICMD_REG Command Register 0x0004 | WO
Status Registers

TWAISTATUS_REG Status Register 0x0008 | RO
TWAIARB LOST CAP_REG Arbitration Lost Capture Register O0x002C | RO
TWAIERR_CODE_CAP_REG Error Code Capture Register 0x0030 | RO
TWAIRX_ERR_CNT_REG Receive Error Counter Register O0x00388 | RO | RAV
TWAITX_ERR_CNT_REG Transmit Error Counter Register Ox003C | RO | RAV
TWAIRX_MESSAGE_CNT_REG Receive Message Counter Register 0x0074 | RO
Interrupt Registers

TWAILINT_RAW_REG Interrupt Register Ox000C | RO
TWAL INT ENA_REG Interrupt Enable Register 0x0010 | RAV

 

Espressif Systems

407

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
18. TWAI

18.7 Register Description

Register 18.1: TWAl_MODE_REG (0x0000)

 

 

TWAI RESET MODE This bit is used to configure the operating mode of the TWAI Controller. 1:
Reset mode; 0: Operating mode (R/W)

TWAIL LISTEN_ONLY MODE 1: Listen only mode. In this mode the nodes will only receive messages
from the bus, without generating the acknowledge signal nor updating the RX error counter. (RAV)

TWAI SELF_TEST MODE. 1: Self test mode. In this mode the TX nodes can perform a successful
transmission without receiving the acknowledge signal. This mode is often used to test a single
node with the self reception request command. (RAW)

TWAIL RX_FILTER_MODE This bit is used to configure the filter mode. 0: Dual filter mode; 1: Single
filter mode (RAW)

Register 18.2: TWAI_BUS_TIMING_O_REG (0x0018)

© YQ
»
& S Dd

& ws er ws e
x

[1 16 [15 [13 o|

 

 

fo 0 0 9 0 0 0 0 0 00 00 0 0 of of | x00 |Reset

 

TWAI BAUD PRESC Baud Rate Prescaler, determines the frequency dividing ratio. (RO | R/V)

TWAIL SYNC _JUMP_WIDTH Synchronization Jump Width (SUW), 1 ~ 14 Tq wide. (RO | R/V)

Espressif Systems 408 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Register 18.3: TWAIL_BUS_TIMING_1_REG (0x001C)

 

 

g Y \
S SF
7 7 Ky
& ws x
@ wy ey yy
& SS oS
31 8 7 6 4/3 oO
00000000000 00000000 00 0 0 ofa x0 x0 Reset

 

 

 

 

 

 

TWAL TIME_SEG1_ The wictth of PBS1. (RO )
TWAL TIME_SEG2_ The wictth of PBS2. (RO )

TWAL TIME_SAMP_ Thenumber of sample points. 0: the bus is sampled once; 1: the bus is sampled
three times (RO )

Register 18.4: TWAI_ERR_WARNING_LIMIT_REG (0x0034)

 

 

 

[oo 0000000000000 000000 00 9 0x60 |Reset

 

TWAILERR_WARNING_LIMIT Error warning threshold. In the case when any of a error counter value
exceeds the threshold, or all the error counter values are below the threshold, an error warning
interrupt will be triggered (given the enable signal is valid). (RO )

Espressif Systems 409 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Register 18.5: TWAI_DATA_0_REG (0x0040)

 

 

 

 

 

 

 

 

yr
YQ
io
So
es
§
Oo
Oo
Ss
&
Ke
s
& °
7
€ we
| 31 8 | 7 0 |
[oo 0000000000000 000000 00 9 x0 |Reset
TWAIL TX_BYTE_0 Stored the Oth byte information of the data to be transmitted under operating
mode. (WO)
TWAIL ACCEPTANCE CODE _0 Stored the Oth byte of the filter code under reset mode. (R/W)
Register 18.6: TWAI_DATA_1_REG (0x0044)
&
&
ee
e
&
S
Oo
al
we
~»
&
& °
& we
| 31 8 | 7 0 |
foo 00000000000000090000 00 0 xO |Reset
TWAIL TX_BYTE_1 Stored the 1st byte information of the data to be transmitted under operating
mode. (WO)
TWAIL ACCEPTANCE CODE 1 Stored the 1st byte of the filter code under reset mode. (RAW)
Espressif Systems 410 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
18. TWAI

 

Register 18.7: TWAI_DATA_2_REG (0x0048)

 

 

 

 

 

 

 

 

Y
yr
YQ
io
So
es
§
Oo
Oo
Ss
<
Y
a
N Q
& N “
ES wv
| 31 8 | 7 0 |
[oo 0000000000000 000000 00 9 xO |Reset
TWAL TX_BYTE_2 Stored the 2nd byte information of the data to be transmitted under operating
mode. (WO)
TWAIL ACCEPTANCE CODE 2 Stored the 2nd byte of the filter code under reset mode. (RAV)
Register 18.8: TWAL DATA_3_ REG (0x004C)
%
X
S
ee
e
&
S
Oo
al
<
%
a
ie °
& we
| 31 8 | 7 0 |
foo 00000000000000090000 00 0 Ox0 |Reset
TWAL TX_BYTE_3 Stored the 3rd byte information of the data to be transmitted under operating
mode. (WO)
TWAL ACCEPTANCE CODE _3 Stored the Srd byte of the filter code under reset mode. (RAV)
Espressif Systems 411 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
18. TWAI

 

Register 18.9: TWAI_DATA_4 REG (0x0050)

 

 

 

 

 

 

 

 

9
aw
w
“ee
ss
“re
§
&
a
s
> a
7
& wv
| 31 8 | 7 0 |
foo 00000000000000090000 00 0 xO |Reset
TWAIL TX_BYTE_4 Stored the 4th byte information of the data to be transmitted under operating
mode. (WO)
TWAIL ACCEPTANCE MASK_0_ Stored the Oth byte of the filter code under reset mode. (RAW)
Register 18.10: TWAI_DATA_5 REG (0x0054)
ie
ee
S fo
es
§
&
a
&
%
ef
& °
7
EF a
| 31 8 | 7 0 |
[oo 0000000000000 000000 00 9 x0 |Reset
TWAIL TX_BYTE_5 Stored the 5th byte information of the data to be transmitted under operating
mode. (WO)
TWAL ACCEPTANCE MASK_1_ Stored the 1st byte of the filter code under reset mode. (R/W)
Espressif Systems 412 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
18. TWAI

 

Register 18.11: TWAI_DATA_6_ REG (0x0058)

 

 

 

 

 

 

 

 

Y
aw
w
“ee
ss
“re
§
&
a
Se
> a
7
& wv
| 31 8 | 7 0 |
foo 00000000000000090000 00 0 xO |Reset
TWAIL TX_BYTE_6 Stored the 6th byte information of the data to be transmitted under operating
mode. (WO)
TWAL ACCEPTANCE MASK_2. Stored the 2nd byte of the filter code under reset mode. (RAV)
Register 18.12: TWAI_DATA_7 REG (0x005C)
%
NO”
ee
S fo
es
§
&
a
<
eo
, é
& N “
EF a
| 31 8 | 7 0 |
[oo 0000000000000 000000 00 9 x0 |Reset
TWAIL TX_BYTE_7 Stored the 7th byte information of the data to be transmitted under operating
mode. (WO)
TWAL ACCEPTANCE MASK_3_ Stored the 3rd byte of the filter code under reset mode. (R/W)
Espressif Systems 413 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
18. TWAI
Register 18.13: TWAI_DATA_8 REG (0x0060)

Q
& ow
&

[oo 0000000000000 000000 00 9 OxO |Reset

TWAIL TX_BYTE_8 Stored the 8th byte information of the data to be transmitted under operating

 

 

 

mode. (WO)
Register 18.14: TWAIL DATA_9 REG (0x0064)
9
a
& °
7
€ we
[1 al o|
joo 9 0000000900000 090090000 00 9 x0 |Reset

 

TWAIL TX_BYTE_9 Stored the 9th byte information of the data to be transmitted under operating

 

 

 

mode. (WO)
Register 18.15: TWAL DATA_10_REG (0x0068)
«
> a

7

& wv
[a1 al o|

foo 00000000000000090000 00 0 xO |Reset

 

TWAIL TX_BYTE_10 Stored the 10th byte information of the data to be transmitted under operating
mode. (WO)

Espressif Systems 414 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Register 18.16: TWAI_DATA_11_REG (0x006C)

 

 

 

Ky
s
& Sv
S
ES ws
[1 al7 o|
[oo 0000000000000 000000 00 9 oxo |Reset

 

TWAIL TX_BYTE_11 Stored the 11th byte information of the data to be transmitted under operating

 

 

mode. (WO)
Register 18.17: TWAI DATA_12_REG (0x0070)
xv
a
eo °
& we

31 el 7 o

000 00 00 0060 00 00 00 00 0 0 0 0 6 0 0 0x0 Reset

 

 

 

 

TWAIL TX_BYTE_12 Stored the 12th byte information of the data to be transmitted under operating

 

 

 

mode. (WO)
Register 18.18: TWAlLCLOCK_DIVIDER_REG (0x007C)
&
ov
Qo
& & &
Ww
é & &
[1 o| 8 [7 o|
[oo 0 0000000000009 00000 0 0 oo] Oxo |Reset

 

TWAI_CD These bits are used to configure frequency dividing coefficients of the external CLKOUT
pin. (RAY)

TWAI CLOCK_OFF This bit can be configured under reset mode. 1: Disable the external CLKOUT
pin; 0: Enable the external CLKOUT pin (RO )

Espressif Systems 415 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

Register 18.19: TWAl_CMD_REG (0x0004)

 

 

TWAIL TX_REQ_ Set the bit to 1 to allow the driving nodes start transmission. (WO)
TWAI ABORT_TX Set the bit to 1 to cancel a pending transmission request. (WO)
TWAI RELEASE BUF Set the bit to 1 to release the RX buffer. (WO)
TWAICLR_OVERRUN Set the bit to 1 to clear the data overrun status bit. (WO)

TWAI SELF_RX_REQ Self reception request command. Set the bit to 1 to allow a message be
transmitted and received simultaneously. (WO)

Register 18.20: TWAIL STATUS_REG (0x0008)

 

31 os} ee} 7]e6]s5 4/3 ]2 1 °

 

0 0 0000 000 00 00 0 0 0 0 0 0 0 0 0 0)/0)/0]/0]}0]/0/1]17410] 0 JReset

 

 

 

 

 

 

 

 

 

 

 

 

TWAI RX_BUF_ST 1: The data in the RX buffer is not empty, with at least one received data packet.
(RO)

TWAILOVERRUN_ST 1: The RX FIFO is full and data overrun has occurred. (RO)
TWAIL TX_BUF_ST 1: The TX buffer is empty, the CPU may write a message into it. (RO)

TWAL TX_COMPLETE 1: The TWAI controller has successfully received a packet from the bus. (RO)

TWAIL RX_ST 1: The TWAI Controller is receiving a message from the bus. (RO)
TWAL TX_ST 1: The TWAI Controller is transmitting a message to the bus. (RO)

TWAILERR_ST 1: At least one of the RX/TX error counter has reached or exceeded the value set in
register TWAILERR_WARNING_LIMIT_REG. (RO)

TWAILBUS_OFF_ST 1: In bus-off status, the TWAI Controller is no longer involved in bus activities.
(RO)

TWAIL MISS_ST This bit reflects whether the data packet in the RX FIFO is complete. 1: The current
packet is missing; 0: The current packet is complete (RO)

Espressif Systems 416 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Register 18.21: TWAl_ARB LOST CAP_REG (0x002C)

 

 

 

[oo 0000000000090 00000900000000 0 OxO |Reset

 

TWAILARB_LOST_CAP This register contains information about the bit position of lost arbitration.
(RO)

Register 18.22: TWAlL_ERR_CODE_CAP_REG (0x0030)

 

31 Bl7 6} 5 |4 °

 

 

 

 

 

 

000000000 0000060060 00 0 06 6 06 0 0 Of ox | 0 Ox0 Reset

 

TWAIL ECC SEGMENT This register contains information about the location of errors, see Table 80
for details. (RO)

TWAI ECC DIRECTION This register contains information about transmission direction of the node
when error occurs. 1: Error occurs when receiving a message; 0: Error occurs when transmitting
a message (RO)

TWAI ECC TYPE This register contains information about error types: 00: bit error; 01: form error;
10: stuff error; 11: other type of error (RO)

Register 18.23: TWAI_RX_ERR_CNT_REG (0x0038)

 

 

 

 

TWAI RX_ERR_CNT The Rx error counter register, reflects value changes under reception status.
(RO )

Espressif Systems 417 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

Register 18.24: TWAIL TX_ERR_CNT_REG (0x003C)

 

 

 

&
eS
& °
& we
[1 al7 o|
[oo 0000000000000 000000 00 9 0x0 |Reset

 

TWAIL TX_ERR_CNT The TX error counter register, reflects value changes under transmission status.
(RO )

Register 18.25: TWAI_RX_MESSAGE_CNT_REG (0x0074)

TWAI RX_MESSAGE_COUNTER This register reflects the number of messages available within the
RX FIFO. (RO)

418 ESP32-S2 TRM (Preliminary V0.4)

Espressif Systems
Submit Documentation Feedback
18. TWAI

 

Register 18.26: TWAI_INT_RAW_REG (0x000C)

 

 

 

 

TWAIL RX_INT_ST Receive interrupt. If this bit is set to 1, it indicates there are messages to be
handled in the RX FIFO. (RO)

TWAL TX_INT_ST Transmit interrupt. If this bit is set to 1, it indicates the message transmitting mis-
sion is finished and a new transmission is able to execute. (RO)

TWAILERR_WARN_INT_ST_ Error warning interrupt. If this bit is set to 1, it indicates the error status
signal and the bus-off status signal of Status register have changed (e.g., switched from 0 to 1 or
from 1 to 0). (RO)

TWAILOVERRUN_INT_ST Data overrun interrupt. If this bit is set to 1, it indicates a data overrun
interrupt is generated in the RX FIFO. (RO)

TWAIERR_PASSIVE_INT_ST Error passive interrupt. If this bit is set to 1, it indicates the TWAI
Controller is switched between error active status and error passive status due to the change of
error counters. (RO)

TWAILARB_LOST_INT_ST Arbitration lost interrupt. If this bit is set to 1, it indicates an arbitration
lost interrupt is generated. (RO)

TWAILBUS_ERR_INT_ST Error interrupt. If this bit is set to 1, it indicates an error is detected on the
bus. (RO)

Espressif Systems 419 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
18. TWAI

 

Register 18.27: TWAL INT ENA_REG (0x0010)

 

 

 

0 |Reset

 

 

 

 

 

 

 

 

 

 

TWAIL RX_INT_ENA Set this bit to 1 to enable receive interrupt. (RW)

TWAL TX_INT_ENA Set this bit to 1 to enable transmit interrupt. (RAM)

TWAILERR_WARN_INT_ENA Set this bit to 1 to enable error warning interrupt. (RAM)

TWAILOVERRUN_INT_ENA Set this bit to 1 to enable data overrun interrupt. (R/V)

TWAIERR_PASSIVE_INT_ENA Set this bit to 1 to enable error passive interrupt. (R/V)

TWAILARB_LOST_INT_ENA Set this bit to 1 to enable arbitration lost interrupt. (RAV)

TWAI BUS_ERR_INT_ENA Set this bit to 1 to enable error interrupt. (RAM)

Espressif Systems

420

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
19. AES Accelerator

 

19. AES Accelerator

19.1 Introduction

ESP32-S2 integrates an Advanced Encryption Standard (AES) Accelerator, which is a hardware device that
speeds up AES Algorithm significantly, compared to AES algorithms implemented solely in software. The AES
Accelerator integrated in ESP32-S2 has two working modes, which are Typical AES and DMA-AES.

19.2 Features
The following functionality is supported:

* Typical AES working mode
— AES-128/AES-192/AES-256 encryption and decryption
— Four variations of key endianness and four variations of text endianness
¢ DMA-AES working mode
— Block mode
* ECB (Electronic Codebook)
* CBC (Cipher Block Chaining)
* OFB (Output Feedback)
* CTR (Counter)
* CFB8 (8-bit Cipher Feedback)
* CFB128 (128-bit Cipher Feedback)
— GCM (Galois/Counter Mode)

— Interrupt on completion of computation

19.3. Working Modes
The AES Accelerator integrated in ESP32-S2 has two working modes, which are Typical AES and

DMA-AES.

* Typical AES Working Mode: supports AES-128/AES-192/AES-256 encryption and decryption under NIST
FIPS 197. In this working mode, the plaintext and ciphertext is written and read via CPU directly.

* DMA-AES Working Mode: supports block cipher algorithms ECB/CBC/OFB/CTR/CFB8/CFB128 under
NIST SP 800-38A, and GCM mode of operation under NIST SP 800-38D. In this working mode, the
plaintext and ciphertext is written and read via crypto DMA. An interrupt will be generated when operation
completes.

Users can choose the working mode for AES accelerator by configuring the AES_DMA_ENABLE_REG register
according to Table 84 below.

Table 84: AES Accelerator Working Mode

 

AES_DMA_ENABLE REG Working Mode |

 

Espressif Systems 421 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
19. AES Accelerator

 

 

0 Typical AES
DMA-AES

 

 

 

 

 

For detailed introduction on these two working modes, please refer to Section 19.4 and Section 19.5
below.

 

Notice:
ESP32-S2’s Digital Signature and External Memory Manual Encryption modules also call the AES accelerator.
Therefore, users cannot access the AES accelerator when these modules are working.

 

 

 

19.4 Typical AES Working Mode
In the Typical AES working mode, the AES accelerator is capable of using cryptographic keys of 128, 192, and

256 bits to encrypt and decrypt data, i.e. AES-128/AES-192/AES-256 encryption and decryption. Users can
choose the operation type for AES accelerator working in Typical AES working mode by configuring the
AES_MODE_REG register according to Table 85 below.

Table 85: Operation Type under Typical AES Working Mode

 

AES_MODE_REG/2:0] Operation Type

AES-128 encryption
AES-192 encryption
AES-256 encryption
AES-128 decryption
AES-192 decryption
AES-256 decryption

 

 

 

 

 

 

O;ayR] rm!) -]|o

 

 

 

 

Users can check the working status of the AES accelerator by inquiring the AES_STATE_REG register and
comparing the return value against the Table 86 below.

Table 86: Working Status under Typical AES Working Mode

 

 

 

 

 

 

 

AES_STATE_REG Status Description
0 IDLE The AES accelerator is idle or completed operation.
1 WORK The AES accelerator is in the middle of an operation.

 

In the Typical AES working mode, the AES accelerator requires 11 ~ 15 clock cycles to encrypt a message block,
and 21 or 22 clock cycles to decrypt a message block.

19.4.1 Key, Plaintext, and Ciphertext
The encryption or decryption key is stored in AES_KEY_n_REG, which is a set of eight 32-bit registers.

* For AES-128 encryption/decryption, the 128-bit key is stored in AES _KEY_O_REG~ AES KEY_3 REG.
* For AES-192 encryption/decryption, the 192-bit key is stored in AES _KEY_O_REG~ AES KEY_5 REG.

* For AES-256 encryption/decryption, the 256-bit key is stored in AES_KEY_O_ REG ~ AES KEY_7_REG.

Espressif Systems 422 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
19. AES Accelerator

 

The plaintext and ciphertext are stored in AES_TEXT_IN_m_REG and AES_TEXT_OUT_m_REG, which are two
sets of four 32-bit registers.

° For AES-128/AES-192/AES-256 encryption, the AES_TEXT_IN_™_REG registers are initialized with
plaintext. Then, the AES Accelerator stores the ciphertext into AES_TEXT_OUT_m_REG after operation.

© For AES-128/AES-192/AES-256 decryption, the AES_TEXT_IN_m_REG registers are initialized with
ciphertext. Then, the AES Accelerator stores the plaintext into AES_TEXT_OUT_m_REG after operation.

19.4.2 Endianness

Text Endianness

In Typical AES working mode, the AES Accelerator uses cryptograchic keys to encrypt and decrypt data in
blocks of 128 bits. The Bit 2 and Bit 3 of the AES _ENDIAN_REG register define the endianness of input text,
while the Bit 4 and Bit 5 define the endianness of output text. To be more specific, Bit 2 and Bit 4 control how the
four bytes are stored in each word, and Bit 3 and Bit 5 control how the four words are stored in each message
block.

Users can choose one of the four text endianness types provided by the AES Accelerator by configuring the
AES_ENDIAN_REG register. Details can been seen in Table 87.

Table 87: Text Endianness Types for Typical AES

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Word Endian Contrall Endian Control
jordEndian Controlling | Byte Endian Controlling ae,
Bit Bit
c
Statet
0 1 2 3
5 5 0 AES_TEXT_«_8_REG[S124] AES_TEXT_<_2_REG[S1.24] AES_TEXT_x_1_REGI31.24] AES_TEXT_x_0_REG[31.24]
1 AES_TEXT_«_8_REGI23:16] AES_TEXT_x_2_REG(23:16] AES_TEXT_x_1_REGI23:16] AES_TEXT_x_0_REG(23:16]
. 2 AES_TEXT_« 8 REGLIS “3 AES_TEXT_x_2_REGUIS:S] AES_TEXT_x_1_REG[I5 3 AES_TEXT_x_0_REG(1S.8]
3 AES_TEXT_« 8 REGI AES_TEXT_«_2 REGI7.0 AES_TEXT_x_1_REGI7: AES_TEXT_x_0_REGI7.0]
c
State
0 1 2 3
5 1 0 AES_TEXT_« 8 REGI AES_TEXT_«_2 REGI7.0 AES_TEXT_x_1_REGI7: AES_TEXT_x_0_REGI7.
1 AES_TEXT_« 8 REGLIS 5 AES_TEXT_x_2_REGUIS:S] AES_TEXT_x_1_REG[I5 a SSS 8
2 AES_TEXT_«_8_REGI23:16] AES_TEXT_x_2_REG(23:16] AES_TEXT_x_1_REGI23:16] AES_TEXT_x_0_REG(23:16]
3 AES_TEXT_«_8_REG[S124] AES_TEXT_<_2_REG[S1.24] AES_TEXT_x_1_REGI31.24] AES_TEXT_x_0_REG[31.24]
c
State
0 1 2 3
1 5 0 AES_TEXT_x_0_REG[S1.24] AES_TEXT_x_1_REGIS1.24] AES_TEXT_x_2 REGIS1.24] AES_TEXT_x_8_REG(S1.24]
1 AES_TEXT_x_0_REGI23:16] AES_TEXT_x_1_REG(23:16] AES_TEXT_x_2 REGI23. 16] AES_TEXT_x_8_REG(23:16]
2 AES_TEXT x0 REGLI5S 3 AES_TEXT_x_1_REGIIS.S] AES_TEXT_x_2 REG(I5 3 SS gy
3 AES_TEXT_x_0_REGI? AES_TEXT_x_1_REGI7.0 AES_TEXT_x_2 REGI’, AES_TEXT_x_8_REGI7.
c
State
0 1 2 3
1 1 0 AES_TEXT_«_0_REGI? AES_TEXT_«_1_REGI7.0 AES_TEXT_x_2_ REGI’: AES_TEXT_x_8_ REGI7.0]
1 AES_TEXT_«_0_REG[I5S 5 AES_TEXT_x_1_REG(IS.8] AES_TEXT_x_2 REG[I5 a AES_TEXT_«_8 REGU15.8]
2 AES_TEXT_«_0_REGI23:16] AES_TEXT_x_1_REG(23:16] AES_TEXT_x_2 REGI23:16] AES_TEXT_«_8 REG(23:16]
3 AES_TEXT_«_0_REGIS1.24] AES_TEXT_«_1_REGIS1.24] AES_TEXT_x_2 REGI31.24] AES_TEXT_«_8 REG[31.24]

 

Espressif Systems

423
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
19. AES Accelerator

 

 

Note:
1. The definition of “State” is described in Section 3.4 The State in NIST FIPS 197.

2. Where,
e When x = IN, the Word Endian and Byte Endian controlling bits of AES_TEXT_IN_m_REG are the Bit 2 and
Bit 3 of AES_ENDIAN_REG, respectively;
e When x = OUT, the Word Endian and Byte Endian controlling bits of AES_TEXT_OUT_m_REG are the Bit 4
and Bit 5 of AES_ENDIAN_REG, respectively.

 

 

 

Key Endianness
In Typical AES working mode, Bit O and bit 1 in AES_ENDIAN_REG define the key endianness.

Users can choose one of the four key endianness types provided by the AES accelerator by configuring the
AES_ENDIAN_REG register. Details can been seen in Table 88, Table 89, and Table 90.

Espressif Systems 424 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
yoeqnsej uoTejuSuND0g Wwgqns

suayshs jisseudsy

Sev

(POA Areulwliaid) WHL 2S-Zedsa

Table 88: Key Endianness Types for AES-128 Encryption and Decryption

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

AES_ENDIAN_REG[!] AES_ENDIAN_REG{O] Bit? w{O] w(t] wi2] wig}t
[81:24] AES_KEY_3_REGI31:24] AES_KEY_2_REG[31:24] AES_KEY_1_REG[31:24] AES_KEY_O_REG[S1:24]

5 5 (23:16) AES_KEY_8 REG[23.16] AES_KEY_2_REG[23.16] AES_KEY_1_REGI23:16] AES_KEY_0_REG[23: 16]
(15 a AES_KEY_8 REG[15:8] AES_KEY_2_REG[15:8] AES_KEY_1_REGIS: 3 AES_KEY_0_REG[I5:6]
(7 AES_KEY_3 REGI7.0 AES_KEY_2_REGI7.0] AES_KEY_1_REGI? AES_KEY_0_REGI?.0
[81:24] AES_KEY_8 REG[7.0 AES_KEY_2_REG[7.0 AES_KEY_1_REGI? AES_KEY_0_REGI?:0

5 1 [23:16] AES_KEY_8 REG[15.8] AES_KEY_2_REG[15.8] AES_KEY_1_REGIS: 5 AES_KEY_0_REG(I5:6]
88) AES_KEY_8 REG[23.16] AES_KEY_2_REG[23.16] AES_KEY_i_REGI23.16] AES_KEY_0_REG[23. 16]
(7 AES_KEY_8 REG[S1.24] AES_KEY_2_REG[31.24] AES_KEY_i_REG[S1:24] AES_KEY_0_REG[S1:24]
[81:24] AES_KEY_0_REG[31:24] AES_KEY_1_REG[31:24] AES_KEY_2_REG[31:24] AES_KEY_8_REG[31:24]

1 5 [23:16] AES_KEY_0_REG[23.16] AES_KEY_i_REG[23.16] AES_KEY_2_REGI23.16] AES_KEY_& REG[23: 16]
(15 a AES_KEY_0_REG[15:8] AES_KEY_1_REG[15.8] AES_KEY_2_REGIS: a AES_KEY_& REG(I5:6]
(7 AES_KEY_0_REG[7.0 AES_KEY_i_REG{7.0] AES_KEY_2_REGI? AES_KEY_& REGO
[81:24] AES_KEY_0_REGI7.0 AES_KEY_i_REGI7:0] AES_KEY_2_REGI? AES_KEY_8 REGI7.0

1 1 (23:16) AES_KEY_0_REG[15:8] REGII5:8) AES_KEY_2_REGIS: 5 AES_KEY_&_REG(I5:6]
8, 8] AES_KEY_0_REG[23.16] REG(23:16) AES_KEY_2_REGI23:16] AES_KEY_8 REG[23: 16]
(7 AES_KEY_0_REG[31:24] /_REGIS1:24] AES_KEY_2_REG[31:24] AES_KEY_8_REG[31:24]

 

 

 

 

 

Note:

1. w[0] ~ w[3] are “the first Nk words of the expanded key” as specified in Section 5.2 Key Expansion in NIST FIPS 197.

“Column Bit” specifies the bytes of each word stored in w[O] ~ w[3].

 

 

Table 89: Key Endianness Types for AES-192 Encryption and Decryption

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

AES_KEY_0_REG[31:24]

 

AES_KEY_1_REG[31.24)

 

AES_KEY_2_REG[31.24)

 

AES_KEY_3_REG[31:24)

 

AES_KEY_4 REG[31:24)

 

AES_ENDIAN_REGUI]| AES_ENDIAN_REG[O]| Bit? w{0] w(t] w(2] wi] wid] wi5}t
(31:24) | AES_KEY_5_REG(31:24) | AES_KEY_4_REG[31:24) | AES_KEY_3_REGI31:24) | AES_KEY_2_REG[31:24) | AES_KEY_1_REG[31:24) | AES_KEY_0_REG[31:24]

5 5 (23:16) | AES_KEY_5_REG(23:16) | AES_KEY_4_REG[23.16] | AES_KEY_8_REG[23.16] | AES_KEY_2_REG[23.16] | AES_KEY_1_REG[23:16] | AES_KEY_0_REG[23.16]
os 8) AES_KEY_5_REGI5:8] [| AES_KEY_4 REGUS) | AES_KEY_8 REGIS:8] | AES_KEY_2.REG[IS8) | AES_KEY_1_REG[I5:8] | AES_KEY_O0_REG[IS a
17, AES_KEY_5_REGI?.0 AES_KEY_4_REGI7.0] AES_KEY_3 REGI7.0 AES_KEY_2_REG[7.0 AES_KEY_1_REGI7, a AES_KEY_0_REGI7’
(31:24) [| AES_KEY_5 REG[?.0} AES_KEY_4_REG[7.0 AES_KEY_8 REG[7.0 AES_KEY_2_REG[7.0 AES_KEY_1_REGI7’ AES_KEY_0_REG[7’

5 1 [23:16] | AES_KEY_SREGIIS.8] | AES_KEY_4 REG[I58) | AES_KEY_SREGIS6] | AES_KEY_2.REG[IS8) | AES_KEY_1_REGIS: a AES_KEY_0_REG[T5. a
a g) AES_KEY_5_REG(23.16] | AES_KEY_4 REG23.16] | AES_KEY_8 REG(23.16] | AES_KEY_2_REG23.16] | AES_KEY_1_REGI23.16] | AES_KEY_0_REG[23:16]
7: AES_KEY_5_REG(S1.24] | AES_KEY_4 REG[S1.24] | AES_KEY_8_REG(S1.24] | AES_KEY_2_REG[S1.24 | AES_KEY_1_REG(31.24] | AES_KEY_0_REG[S1.24]
(31:24) | AES_KEY_O_REG(S1:24) [| AES_KEY_i_REG[31:24) | AES_KEY_2_REG[31:24] | AES_KEY_3_REG[31:24) [ AES_KEY_4_REG[31:24] | AES_KEY_5_REG[31:24]

1 5 [23:16] | AES_KEY_0_REG(23.16] [| AES_KEY_1_REG23.16] | AES_KEY_2_REG(23.16] [| AES_KEY_3_REG23.16] | AES_KEY_4_REG[23:16] | AES_KEY_5_REG[23.16]
a g) AES_KEY_O_REGI5:8] | AES_KEY_1_REG[I58) | AES_KEY_2 REGIS] | AES_KEY_S_REG[IS8) | AES_KEY4 REGIS] | AES_KEY_S_REG[IS a
7: AES_KEY_0_REGI? 0 AES_KEY_1_REG{7.0] AES_KEY_2_REG[7.0 AES_KEY_8_REG[7.0 AES_KEY_4_REGI7, a AES_KEY_5_REGI7,
(31:24) | AES_KEY_O_REGI7.0} AES_KEY_1_REGI7.0 AES_KEY_2_REGI7.0 AES_KEY_3_REGI7.0 AES_KEY_4_REGI7, AES_KEY_5_REGI7,

1 1 (23:16) | AES_KEY_O_REGIIS;8) [| AES_KEY_1_REG[I58) | AES_KEY_2REGIS.8] [| AES_KEY_@-REG[IS8) | AES_KEY_4 REGIS: 5 AES_KEY_5_REG[I5: 5
os 8) AES_KEY_0_REG(23.16) | AES_KEY_1_REGI23.16] | AES_KEY_2 REG(23.16) | AES_KEY_3_REG[23.16] | AES_KEY_4_REG[23.16] | AES_KEY_5_REG[23.16]
U7, [ [ [ [ [ [

AES_KEY_5_REG[31:24)

 

 

 

 

Note:

1. w[0] ~ w{5] are “the first Nk words of the expanded key” as specified in Chapter 5.2 Key Expansion in NIST FIPS 197.

“Column Bit” specifies the bytes of each word stored in w[O] ~ w[5].

 

 

 

Joyesaje00V SAV ‘61
yoeqnsej uoTejuSuND0g Wwgqns

suayshs jisseudsy

9er

(POA Areulwliaid) WHL 2S-Zedsa

Table 90: Key Endianness Types for AES-256 Encryption and Decryption

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

AES_ENDIAN_REGUI]| AES_ENDIAN_REG[O]| Bit? w{0] wit] w(2] wi] wi4] wid] wid] wir
(31:24) | AES_KEY_7_REG(S1:24) | AES_KEY_6_REG[31:24] | AES_KEY_5_REGIS1:24) | AES_KEY_4_REG[31:24] | AES_KEY_3_REG[S1:24) | AES_KEY_2_REG[31:24] | AES_KEY_1_REGIS1:24) | AES_KEY_0_REGI[31:24]

5 5 (23:16) | AES_KEY_7_REG(23:16] [| AES_KEY_6_REG[23.16] | AES_KEY_5_REGI23.16] | AES_KEY_4_REG[23.16] | AES_KEY_8_REG(23.16] | AES_KEY_2_REG[23.16] [ AES_KEY_1_REG[23.16) | AES_KEY_0_REG[23:16]
[158) AES_KEY_7_REG(I5:6) | AES_KEY_6-REG[ISS) | AES_KEY_S5REGIIS6] | AES_KEY_4 REG[IS8) | AES_KEY_8 REGIIS6] | AES_KEY_2.REG[I58) [ AES_KEY_1_REGIIS: a AES_KEY_0_REG[T5: a
(7:0) AES_KEY_7_REGI?.0 AES_KEY_6_REGI? 0 AES_KEY_5_REGI7.0] AES_KEY_4_REGI7.0 AES_KEY_3 REG[7.0 AES_KEY_2_REGI7, a AES_KEY_1_REGI7, AES_KEY_0_REGI7’
(31:24) | AES_KEY_7_REG[?.0} AES_KEY_6_REGI?.0 AES_KEY_5_REG[7.0 AES_KEY_4_REG[7.0 AES_KEY_3 REG[7.0 AES_KEY_2_REGI7, AES_KEY_1_REGI7’ AES_KEY_0_REG[7’

5 1 (23:16) | AES_KEY_7_REGTIS:6) [| AES_KEY_6.REG[TS8] | AES_KEY_S_REG(ISi8) | AES_KEY_4_REG[IS8]) | AES_KEY_3_REG[ISi8) | AES_KEY_2_REGITS: a AES_KEY_1_REG[TS: a AES_KEY_0_REG[T5: a
[1538] AES_KEY_7_REG(23.16] | AES_KEY_6_REG23.16] | AES_KEY_5_REG(23.16] | AES_KEY_4 REG23.16] | AES_KEY_8 REG(23.16) | AES_KEY_2_REG[23.16] [ AES_KEY_1_REGI23.16) | AES_KEY_0_REG[23.16]
(7:0) AES_KEY_7_REG(S1.24] | AES_KEY_6_REG[S1.24] | AES_KEY_5_REG(S1.24] | AES_KEY_4 REG[S1.24 | AES_KEY_8 REG(S1.24] | AES_KEY_2_REG[S1.24 | AES_KEY_1_REG(S1.24] | AES_KEY_0_REG[S1.24]
(31:24) | AES_KEY_O_REG[S1:24) [| AES_KEY_i_REG[31:24] | AES_KEY_2_REG[S1:24) [| AES_KEY_3 REG[31:24] | AES_KEY_4_REG[S1:24] [| AES_KEY_5_REG[31.24] [ AES_KEY_6_REGIS1:24) | AES_KEY_7_REGI[31:24]

1 5 (23:16) | AES_KEY_0_REG(23:16] [| AES_KEY_1_REG[23.16] | AES_KEY_2_REG(23.16] [| AES_KEY_3 REG23.16] | AES_KEY_4_REG(23.16] [| AES_KEY_5_REG[23.16] [ AES_KEY_6_REG(23.16) | AES_KEY_?_REG[23.16]
[1538] AES_KEY_O_REG(I5:6) | AES_KEY_1_REG[IS8) | AES_KEY_2REGIIS.6) | AES_KEY_3-REG[ISS) | AES_KEY_4 REGIS] | AES_KEY_S-REG[I58) | AES_KEY_6_REGIS: a AES_KEY_7_REG[TS. a
(7:0) AES_KEY_0_REGI?.0 AES_KEY_i_REG(? 0 AES_KEY_2_REGI7.0] AES_KEY_8 REGO AES_KEY_4_REG[7.0 AES_KEY_5_REGI7, a AES_KEY_6_REGI’’ AES_KEY_7_REG[7’
(31:24) | AES_KEY_O_REGI?.0} AES_KEY_1_REGI?.0 AES_KEY_2_REGI7.0 AES_KEY_3 REGI7.0 AES_KEY_4_REGI7.0 AES_KEY_5_REGI7, AES_KEY_6_REGI7, AES_KEY_7_REGI7,

1 1 (23:16) | AES_KEY_O_REGTIS:6) [| AES_KEY_i_REG[IS:8]) | AES_KEY_2.REGIISi8) | AES_KEY_S REG(IS8]) | AES_KEY_4 REG[I5:8) | AES_KEY_5_REGITS: 5 AES_KEY_6_REGIT5: 5 AES_KEY_7_REG[I5: 5
[158) AES_KEY_0_REG(23:16] | AES_KEY_1_REGI23.16] | AES_KEY_2_REG(23.16) | AES_KEY_3 REG[23.16] | AES_KEY_4 REG(23.16] | AES_KEY_5_REG[23.16] [ AES_KEY_6_REGI23.16) | AES_KEY_7_REG[23.16]
(7:0) AES_KEY_0_REG(S1.24) | AES_KEY_1_REG[31.24] | AES_KEY_2_REG[S1.24) | AES_KEY_3 REG[S1.24] [| AES_KEY_4_REG(S1:.24) | AES_KEY_5_REG[31.24) [ AES_KEY_6_REG(S1:.24) | AES_KEY_7_REG[S1.24]

 

 

 

 

Note:

1. w[0] ~ w{7] are “the first Nk words of the expanded key” as specified in Chapter 5.2 Key Expansion in NIST FIPS 197.

“Column Bit” specifies the bytes of each word stored in w[O] ~ w{7].

 

 

 

Joyesaje00V SAV ‘61
19. AES Accelerator

 

19.4.3 Operation Process
Single Operation

1.

2.

5.

Write 0 to the AES_DMA_ENABLE_REG register.

Initialize registers AES_MODE_REG, AES_KEY_n_REG, AES_TEXT_IN_/m_REG, and AES_ENDIAN_REG.

. Start operation by writing 1 to the AES_TRIGGER_REG register.

. Wait till the content of the AES_STATE_REG register becomes 0, which indicates the operation is

completed.

Read results from the AES_TEXT_OUT_m_REG register.

Consecutive Operations

In consecutive operations, primarily the input AES_TEXT_IN_m_REG and output AES_TEXT_OUT_m_REG
registers are being written and read, while the content of AES_DMA_ENABLE_REG, AES_MODE_REG,
AES_KEY_n_REG, and AES_ENDIAN_REG is kept unchanged. Therefore, the initialization can be simplified
during the consecutive operation.

1.

Write 0 to the AES_DMA_ENABLE_ REG register before starting the first operation.

2. Initialize registers AES_MODE_REG, AES_KEY_n_REG, and AES_ENDIAN_REG before starting the first
operation.

3. Update the content of AES_TEXT_IN_m_REG.

4. Start operation by writing 1 to the AES_TRIGGER_REG register.

5. Wait till the content of the AES_STATE_REG register becomes 0, which indicates the operation completes.

6. Read results from the AES_TEXT_OUT_m_REG register, and return to Step 3 to continue the next
operation.

Espressif Systems 427 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
19. AES Accelerator

 

19.5 DMA-AES Working Mode

In the DMA-AES working mode, the AES accelerator supports six block operation including
ECB/CBC/OFB/CTR

/CFB8/CFB128 as well as GCM operation. Users can choose the operation type for AES accelerator working in
the DMA-AES working mode by configuring the AES_BLOCK_MODE_REG register according to Table 91
below.

Table 91: Operation Type under DMA-AES Working Mode

 

AES_BLOCK_MODE_REG[2:0] Operation Type

ECB (Electronic Codebook)

CBC (Cipher Block Chaining)

OFB (Output Feedback)

CTR (Counter)

CFB8 (8-bit Cipher Feedback)
CFB128 (128-bit Cipher Feedback)
GCM (Galois/Counter Mode)

 

 

 

 

 

 

 

O}ayR] a! rm]s-|o

 

 

 

 

Users can check the working status of the AES accelerator by inquiring the AES_STATE_REG register and
comparing the return value against the Table 92 below.

Table 92: Working Status under DMA-AES Working mode

 

 

 

 

AES_STATE_REG Status Description

0 IDLE The AES accelerator is idle.

1 WORK The AES accelerator is in the middle of an operation.
2 DONE The AES accelerator completed operations.

 

 

 

 

 

When working in the DMA-AES working mode, the AES accelerator supports interrupt on the completion of
computation. To enable this function, write 1 to the AES_INT_ENA REG register. By default, the interrupt
function is enabled. Also, note that the interrupt should be cleared by software after use.

19.5.1 Key, Plaintext, and Cipertext
Block Operation

During the block operations, the AES Accelerator reads source data (in_stream) from DMA, and write result data
(out_stream) to DMA as well, after the computation.

® For encryption, DMA reads plaintext from memory, then passes it to AES as source data. After
computation, AES passes ciphertext as result data back to DMA to write into memory.

® For decryption, DMA reads ciphertext from memory, then passes it to AES as source data. After
computation, AES passes plaintext as result data back to DMA to write into memory.

During block operations, the lengths of the source data and result data are the same. The total computation time
is reduced because the DMA data operation and AES computation can happen concurrently.

The length of source data for AES Accelerator under DMA-AES working mode must be 128 bits or the integral
multiples of 128 bits. Otherwise, trailing zeros will be added to the original source data, so the length of source

Espressif Systems 428 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
19. AES Accelerator

 

data equals to the nearest integral multiples of 128 bits. Please see details in Table 93 below.

Table 93: TEXT-PADDING

 

Function : TEXT-PADDING( )
Input : X, bit string.
Output : Y = TEXT-PADDING(X), whose length is the nearest integral multiples of 128 bits.

 

 

Steps

Let us assume that X is a data-stream that can be split into n parts as following:

X= X1||X2l| ue |Xn—1]|Xn

Here, the lengths of X1, X2,--- ,Xn-1 all equal to 128 bits, and the length of X,, is ¢
(O<=f<=127).

lft = 0, then
TEXT-PADDING(X) = X;
If0<¢<= 127, define a 128-bit block, X%, and let X% = X,,||0128~, then

n?

TEXT-PADDING(X) = X1||X2||--~||Xn—1|[X% = X||ol28-t

 

 

 

19.5.2 Endianness

Under the DMA-AES working mode, the transmission of source data and result data for AES Accelerator is solely
controlled by DMA. Therefore, the AES Accelerator cannot control the Endianness of the source data and result

data, but does have requirement on how these data should be stored in memory and on the length of the
data.

For example, let us assume DMA needs to write the following data into memory at address 0x0280.
* Data represented in hexadecimal:

-— 01020304050607 08090AODBOCODOEOF 101 112131415161718191A1B1C1D1E1F20

* Data Length:
— Equals to 2 blocks.

Then, this data will be stored in memory as shown in Table 94 below.

Table 94: Text Endianness for DMA-AES

 

 

 

 

 

 

 

 

 

Address Byte Address Byte Address Byte Address Byte
0x0280 0x01 0x0281 0x02 0x0282 0x03 0x0283 0x04
0x0284 Ox05 0x0285 0x06 0x0286 Ox07 0x0287 0x08
0x0288 0x09 0x0289 Ox0A Ox028A Ox0B 0x028B Ox0C
O0x028C Ox0D 0x028D OxOE 0x028E OxOF Ox028F 0x10
0x0290 Ox11 0x0291 0x12 0x0292 0x18 0x0293 Ox14
0x0294 Ox15 0x0295 0x16 0x0296 Ox17 0x0297 0x18
0x0298 0x19 0x0299 Ox1A Ox029A 0x1B 0x029B Ox1C
0x029C O0x1D 0x029D Ox1E 0x029E Ox1F Ox029F 0x20

 

 

 

 

 

 

 

 

 

 

DMA can access both internal memory and PSRAM outside ESP32-S2. When you use DMA to access external
PSRAM, please use base addresses that meet the requirements for DMA. When you use DMA to access internal
memory, base addresses do not have such requirements.

Espressif Systems 429 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
19. AES Accelerator

 

19.5.3 Standard Incrementing Function

AES accelerator provides two Standard Incrementing Functions for the CTR block operation, which are INC32
and INC 2g Standard Incrementing Functions. By setting the AES_INC_SEL_REG register to 0 or 1, users can
choose the INC32 or INCi2g functions respectively. For details on the Standard Incrementing Function, please see
Chapter B.1 The Standard Incrementing Function in NIST SP 800-38A.

19.5.4 Block Number

Register AES_BLOCK_NUM_REG stores the Block Number of plaintext P or cipertext C. The length of this
register equals to length(TEXT-PADDING(P))/128 or length(TEXT-PADDING(C})/1 28. The AES Accelerator only
uses this register when working in the DMA-AES mode.

19.5.5 Initialization Vector

AES_|V_MEM is a 16-byte memory, which is only available for AES Accelerator working in block operations. For
CBC/OFB/CFB8/CFB128 operations, the AES_IV_MEM memory stores the Initialization Vector (IV). For the CTR
operation, the AES_IV_MEM memory stores the Initial Counter Block (ICB).

Both lV and ICB are 128-bit strings, which can be divided into ByteO, Byte1, Byte2 - -- Byte15 (from left to right).
AES_|V_MEM stores data following the Endianness pattern presented in Table 94, i.e. the most significant (i-e.,
left-most) byte ByteO is stored at the lowest address while the least significant (i.e., right-most) byte Byte15 at the
highest address.

For more details on IV and ICB, please refer to NIST SP 800-38A.

19.5.6 Block Operation Process
1. Write 0 to the CRYPTO_DMA_AES SHA _SELECT_REG register.

2. Configure Crypto DMA chained list and start DMA.
3. Initialize the AES accelerator-related registers:

° Write 1 to the AES DMA ENABLE REG register.

Configure the AES_INT_ENA_ REG register to enable or disable the interrupt function.

Initialize registers AES_MODE_REG, AES_KEY_n_REG, and AES_ENDIAN_REG.

Select operation type by configuring the AES_BLOCK_MODE_REG register. For details, see Table 91.

Initialize the AES_BLOCK_NUM_REG register. For details, see Section 19.5.4.

Initialize the AES_INC_SEL_REG register (only needed when AES Accelerator is working under CTR
block operation).

Initialize the AES_IV_MEM memory (only needed when AES Accelerator is working under ECB block
operation).

4. Start operation by writing 1 to the AES_TRIGGER_REG register.

5. Wait for the completion of computation, which happens when the content of AES_STATE_REG becomes 2
or the AES interrupt occurs.

6. Check if DMA completes data transmission from AES to memory. At this time, DMA had already written the
result data in memory, which can be accessed directly.

Espressif Systems 430 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
19. AES Accelerator

 

7. Clear interrupt by writing 1 to the AES_INT_CLR_REG register, if any AES interrupt occured during the

computation.

8, Release the AES Accelerator by writing 0 to the AES_DMA_EXIT_REG register. After this, the content of the

AES_STATE_REG register becomes 0. Note that, you can release DMA earlier, but only after Step 5 is
completed.

19.5.7 GCM Operation Process

1.

2.

Write 0 to the CRYPTO_DMA_AES_SHA_SELECT_REG register.

Configure Crypto DMA chained list and start DMA.

3. Initialize the AES accelerator-related registers:

° Write 1 to the AES DMA ENABLE REG register.

Configure the AES_INT_ENA_ REG register to enable or disable the interrupt function.

Initialize registers AES_MODE_REG and AES_KEY_n_REG AES_ENDIAN_REG.

Write 6 to the AES_BLOCK_MODE_REG register.

Initialize the AES_BLOCK_NUM_REG register. Details about this register are described in Section
19.5.4,

Initialize the AES_AAD_ BLOCK _NUM_REG register. Details about this register are described in
Section 19.6.4.

Initialize the AES_REMAINDER_BIT_NUM_REG register. Details about this register is described in
Section 19.6.5.

4. Start operation by writing 1 to the AES_TRIGGER_REG register.

5. Wait for the completion of computation, which happens when the content of AES_STATE_REG becomes 2.
For details on the working status of AES Accelerator, please refer to Table 92. At this step, no interrupt
occurs.

6. Obtain the H value from the AES_H_MEM memory.

7. Generate Jo and write it to the AES_JO_MEM memory.

8. Continue operating by writing 1 to the AES_CONTINUE_REG register.

9, Wait for the completion of computation, which happens when the content of AES_STATE_REG becomes 2
or the AES interrupt occurs. For details on the working status of AES Accelerator, please refer to Table 92.

10. Obtain To by reading AES_TO_MEM, which is already ready at this step.

11. Check if DMA completes data transmission from AES to memory. At this time, DMA had already written the
result data in memory, which can be accessed directly.

12. Clear interrupt by writting 1 to the AES_INT_CLR_REG register, if any AES interrupt occured during the
computation.

13. Exit DMA by writing 1 to the AES DMA _EXIT_REG register. After this, the content of the AES_STATE_REG
becomes 0. Note that, you can exit DMA earlier, but only after Step 9 is completed.

Espressif Systems 431 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
19. AES Accelerator

 

19.6 GCM Algorithm

ESP32-S2’s AES accelerator fully supports GCM Algorithm. In reality, the AAD, C and P that are longer than
2°2_4 bits are seldom used. Therefore, we specify that the length of AAD, C and P should be no longer than

2°24 here. Figure 19-12 below demonstrates how GCM encryption is implemented in the AES Accelerator of

ESP32-S2.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

[len(A)],.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

[len(C)],q

 

 

 

 

 

 

 

 

 

 

0128 ‘

 

 

 

 

 

 

 

 

 

 

 

Figure 19-12. GCM Encryption Process

GCM encryption can be implemented as follows:

 

1. Hardware executes the ECB Algorithm to obtain the Hash subkey H, which is needed in the Hash

computation.

2. Hardware executes the GHASH Algorithm to perform Hash computation with the padded AAD.

3. Hardware gets ready for CTR encryption by obtaining the result of applying Standard Incrementing

Function INC32 to Jo.

4. Harcware executes the GCTR Algorithm to encrypt the padded plaintext P, then executes the GHASH

Algorithm to perform Hash computation on the padded cipertext C’.

5. Harcware executes the GHASH Algorithm to perform Hash computation on AAD Blocks, obtaining a

Espressif Systems 432
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
19. AES Accelerator

 

128-bit Hash result.
6. Harcware executes the GCTR Algorithm to encrypt Jo, obtaining To.

7. Software obtains the result To from hardware, and execute MSB; Algorithm to obtain the final result
Authenticated Tag T.

The only difference between GCM decryption and GCM encryption lies in Step 4 in Figure 19-12. To be more
specific, instead of executing GCTR Algorithm to encrypt the padded plaintext, the AES Accelerator executes the
same Algorithm to decrypt the padded cipertext in GCM decryption. For details, please see NIST SP

800-38D.

19.6.1 Hash Subkey

During GCM operation, the Hash subkey H is a 128-bit value computed by hardware, which is demonstrated in
Step 1 in Figure 19-12. Also you can find more information about Hash subkey at “Step 1. Let H = CIPH,(0175)”
in Chapter 7 GCM Specification of NIST SP 800-38D.

Just like all other Endianness, the Hash subkey # is stored in the AES_H_MEM memory with its most significant
(i.e., left-most) byte ByteO stored at the lowest address and least significant (i-e., right-most) byte Byte15 at the
highest address. For details, see Table 94.

19.6.2 Jy

The Jo is a 128-bit value computed by hardware, which is required during Step 3 and Step 6 of the GCM
process in Figure 19-12. For details on the generation of Jo, please see Chapter 7 GCM Specification in NIST SP
800-38D Specification.

The Jo is stored in the AES_JO_MEM memory as Endianness. Just like all other Endianness, its most significant
(i.e., left-most) byte ByteO is stored at the lowest address in the memory while least significant (i-e., right-most)
byte Byte15 at the highest address. For details, see Table 94.

19.6.3 Authenticated Tag
Authenticated Tag (Tag for short) is one of the key results of GCM computation, which is demonstrated in Step 7
of Figure 19-12. The value of Tag is determined by the length of Authenticated Tag ¢ (1 <=t <= 128):

e When ¢ = 128, the value of Tag equals to To, a 128-bit string that is stored in the AES_TO_MEM as
Endianness. Just like all other Endianness, its most significant (i.e., left-most) byte ByteO is stored at the
lowest address in the memory while least significant (i.e., right-most) byte Byte15 at the highest address.
For details, see Table 94.

e When 1 <= t < 128, the value of Tag equals to the ¢ most significant (i.e., left-most) bits of Z. In this case,
Tag is represented as MSB,(To), which returns the ¢ most significant bits of T>. For example,
MSB,4(111011010) = 1110 and MSB;(1 1010011010) = 11010. For details on the MSB,()} function, please
refer to Chapter 6 Mathematical Components of GCM in the NIST SP 800-38D specification.

19.6.4 AAD Block Number

Register AES_AAD_ BLOCK _NUM_REG stores the Block Number of Additional Authenticated Data (AAD). The
length of this register equals to length(TEXT-PADDING(A AD))/1 28. AES Accelerator only uses this register when
working in the DMA-AES mode.

Espressif Systems 433 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
19. AES Accelerator

 

19.6.5 Remainder Bit Number

Register AES_REMAINDER_BIT_NUM_REG stores the Remainder Bit Number, which indicates the number of
effective bits of incomplete blocks in plaintext/cipertext. The value stored in this register equals to length(P)%128
or length(C)%128. AES Accelerator only uses this register when working in the DMA-AES mode.

Register AES_REMAINDER_BIT_NUM_REG does not affect the results of plaintext or cipertext, but does impact
the value of To, therefore the Tag value too.

The GCM Algorithm can be viewed as the combination of GCTR operation and GHASH operation, among which,
the GCTR performs the encryption and decryption, while the GHASH sloves the Tag.

Note that the AES _REMAINDER_BIT_NUM_REG register is only effective for GCM encryption. To be more
specific:

* For GCM encryption, the Hardware firstly computes C, then passes it in the form of TEXT-PADDING(C) as
the input of GHASH operation. In this case, hardware determines how many trailing “O” should be added
based on the content of AES_REMAINDER_BIT_NUM_REG.

* For GCM decrpytion, the padding is completed with the TEXT-PADDING(C) function. In this case, the
AES_REMAINDER_BIT_NUM_REG register is not effective.

19.7. Base Address

Users can access AES with two base addresses, which can be seen in Table 95. For more information about
accessing peripherals from different buses please see Chapter 1 System and Memory.

Table 95: AES Accelerator Base Address

 

 

 

Bus to Access Peripheral Base Address
PeriBUS1 OxSF43A000
PeriBUS2 Ox6003A000

 

 

 

 

19.8 Memory Summary
Both the starting address and ending address in the following table are relative to AES base addresses provided
in Section 19.7.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Length Starting Address | Ending Address | Access
AES_IV_MEM Memory IV 16 bytes 0x0050 OxO05F RAW
AES_H_MEM Memory H 16 bytes Ox0060 OxO06F RO
AES_JO_MEM Memory JO 16 bytes 0x0070 Ox007F RAW
AES_TO_MEM Memory TO 16 bytes O0x0080 Ox008F RO
19.9 Register Summary
The addresses in the following table are relative to AES base addresses provided in Section 19.7.
Name | Description Address Access
Key Registers
AES_KEY_O_REG AES key register 0 O0x0000 RAW
AES_KEY_1_REG AES key register 1 0x0004 RAW

 

 

 

Espressif Systems

434

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
19. AES Accelerator

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address Access
AES_KEY_2_REG AES key register 2 0x0008 RAW
AES_KEY_3 REG AES key register 3 Ox000C RAW
AES_KEY_4_REG AES key register 4 0x0010 RAW
AES_KEY_5_ REG AES key register 5 O0x001 4 RAW
AES_KEY_6_REG AES key register 6 0x0018 RAW
AES_KEY_7_REG AES key register 7 0x001C RAW
TEXT_IN Registers
AES_TEXT_IN_O_REG Source data register 0 0x0020 RAW
AES_TEXT_IN_1_REG Source data register 1 0x0024 RAW
AES_TEXT_IN_2_REG Source data register 2 0x0028 RAW
AES_TEXT_IN_3_ REG Source data register 3 0x002C RAW
TEXT_OUT Registers
AES_TEXT_OUT_O_REG Result data register O 0x0030 RO
AES_TEXT_OUT_1_REG Result data register 1 0x0034 RO
AES_TEXT_OUT_2_REG Result data register 2 0x0038 RO
AES_TEXT_OUT_3_ REG Result data register 3 O0x003C RO
Configuration Registers
AES_MODE_REG AES working mode configuration register 0x0040 RAW
AES_ENDIAN_REG Endian configuration register 0x0044 RAW
AES_DMA_ENABLE_REG DMA enable register Ox0090 RAW
AES_BLOCK_MODE_REG Block operation type register 0x0094 RAW
AES_BLOCK_NUM_REG Block number configuration register 0x0098 RAW
AES_INC_SEL_REG Standard incrementing function register Ox009C RAW
AES_AAD_BLOCK_NUM_REG AAD block number configuration register Ox00A0 RAW
AES_REMAINDER_BIT_NUM_REG] Remainder bit number of plaintext/ciphertext | OxOO0A4 RAW
Controlling / Status Registers
AES_TRIGGER_REG Operation start controlling register 0x0048 WO
AES_STATE_REG Operation status register 0x004C RO
AES_CONTINUE_REG Operation continue controlling register Ox00A8 WO
AES_DMA_EXIT_REG Operation exit controlling register Ox00B8 WO
Interruption Registers
AES_INT_CLR_REG DMA-AES interrupt clear register OxO0AC WO
AES_INT_ENA_REG DMA-AES interrupt enable register Ox00BO RAW
Espressif Systems 435 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
19. AES Accelerator

 

19.10 Registers

Register 19.1: AES_KEY_»_REG (: 0-7) (0x0000+4*/)

 

 

| 0x000000000 | Reset

 

AES_KEY_»_REG (»: 0-7) Stores AES keys. (R/W)

Register 19.2: AES_TEXT_IN_™_REG (/n: 0-3) (0x0020+4*)

 

31 °

 

0x000000000 Reset

 

 

 

AES_TEXT_IN_™_REG (m: 0-3) Stores the source data when the AES Accelerator operates in the
Typical AES working mode. (RAW)

Register 19.3: AES_TEXT_OUT__REG (/: 0-3) (0x0030+4*/)

E "|

| 0000000000 | Reset

 

 

 

AES_TEXT_OUT_m_REG (m: 0-3) Stores the result data when the AES Accelerator operates in the
Typical AES working mode. (RO)

Register 19.4: AES_-MODE_REG (0x0040)

 

 

 

X,
S &
és =
& ©
| 31 3 | 2 o |
| 0x00000000 | 0 | Reset

 

AES MODE Defines the operation type of the AES Accelerator operating under the Typical AES work-
ing mode. For details, see Table 85. (R/W)

Espressif Systems 436 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
19. AES Accelerator

 

Register 19.5: AES_ENDIAN_REG (0x0044)

 

 

 

Ss
» <
s oF
Ww ©
| 31 6 | 5 0 |
| 0x0000000 | 0 0 0 0 0 0 |Reset

 

AES_ENDIAN Defines the endianness of input and output texts. For details, please see Table 87.
(RAV)

Register 19.6: AES_DMA_ENABLE_REG (0x0090)

 

 

 

 

 

 

 

 

 

 

 

 

&
a
& 3
& O/
€ ©
[1 | 0 |
| 000000000 [0 |Reset
AES_DMA_ENABLE Defines the working mode of the AES Accelerator. For details, see Table 84.
(RAV)
Register 19.7; AES BLOCK_MODE_REG (0x0094)
&
Rs
S Se
2 wa
és 22
& ©
| 31 3 | 2 0 |
| 0x00000000 | 0 | Reset
AES BLOCK_MODE Defines the operation type of the AES Accelerator operating under the DMA-
AES working mode. For details, see Table 91. (RAN)
Register 19.8: AES BLOCK_NUM_REG (0x0098)
[1 o|
| 0x00000000 |Reset
AES BLOCK_NUM Stores the Block Number of plaintext or cipertext when the AES Accelerator
operates under the DMA-AES working mode. For details, see Section 19.5.4. (RAV)
Espressif Systems 437 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
19. AES Accelerator

 

Register 19.9: AES_INC_SEL_REG (0x009C)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

xy
S oF
§ s
& G7
Ri G
[1 | 0 |
| 000000000 [0 |Reset
AES_INC_SEL Defines the Standard Incrementing Function for CTR block operation. Set this bit to
0 or 1 to choose INC32 or INCi28. (RAV)
Register 19.10: AES AAD BLOCK _NUM_REG (0x00A0)
[a1 o|
| 0x00000000 | Reset
AES _ AAD BLOCK_NUM Stores the ADD Block Number for the GCM operation. (R/W) For details,
see Section 19.6.4.
Register 19.11: AES REMAINDER_BIT_NUM_REG (0x00A4)
>
S
>
Sy
S
e
& <&
ES eC
| 31 7 | 6 o |
| 0000000 | 0 | Reset
AES_REMAINDER_BIT_NUM Stores the Remainder Bit Number for the GCM operation. For details,
see Section 19.6.5. (RAV)
Register 19.12: AES _TRIGGER_REG (0x0048)
S
K
& &
& 7
€ ©
[a1 1 0 |
| 0x00000000 | x |Reset
AES TRIGGER Set this bit to 1 to start AES operation. (WO)
Espressif Systems 438 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
19. AES Accelerator

 

Register 19.13: AES_STATE_REG (0x004C)

 

 

 

S ee
& ov 7
RG
| 31 2 | 1 o |
| 0x00000000 | Oxo |Reset

 

AES STATE Stores the working status of the AES Accelerator. For details, see Table 86 for Typical
AES working mode and Table 92 for DMA AES working mode. (RO)

Register 19.14: AES_CONTINUE_REG (0x00A8)

 

 

 

 

 

 

 

 

 

 

 

 

¥
&
S\ S
sf ?
€ e
[1 | 0 |
| 000000000 [ x ]Reset
AES CONTINUE Set this bit to 1 to continue AES operation. (WO)
Register 19.15: AES DMA _EXIT_REG (0x00B8)
&
> 3
é 3S
[1 1 0 |
| 0x00000000 | x |Reset
AES DMA EXIT Set this bit to 1 to exit AES operation. This register is only effective for DMA-AES
operation. (WO)
Register 19.16: AES _INT_CLR_REG (0x00AC)
g
Ww
S\ 7
e $
& ©
[a1 1 0 |
| 0x00000000 | x |Reset
AES_INT_CLR Set this bit to 1 to clear AES interrupt. (WO)
Espressif Systems 439 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
19. AES Accelerator

 

Register 19.17: AES_INT_ENA_REG (0x00BO0)

 

 

 

 

w
S 6?
gf oS
& ©
lf if
| 0x00000000 | QO |Reset
AES_INT_ENA Set this bit to 1 to enable AES interrupt and 0 to disable interrupt. (RAV)
Espressif Systems 440 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
20. SHA Accelerator

 

20. SHA Accelerator

20.1 Introduction
ESP32-S2 integrates an SHA accelerator, which is a hardware device that speeds up SHA algorithm significantly,

compared to SHA algorithm implemented solely in software. The SHA accelerator integrated in ESP32-S2 has
two working modes, which are Typical SHA and DMA-SHA.

20.2 Features

The following functionality is supported:

¢ All the hash algorithms introduced in FIPS PUB 180-4 Spec.
- SHA-1
- SHA-224
— SHA-256
— SHA-384
- SHA-512
— SHA-512/224
— SHA-512/256
— SHA-512/t

* Two working modes
— Typical SHA
—- DMA-SHA

® Interleave function when working in Typical SHA working mode

® Interrupt function when working in DMA-SHA working mode

20.3 Working Modes
The SHA accelerator integrated in ESP32-S2 has two working modes: Typical SHA and DMA-SHA.

* Typical SHA Working Mode: all the cata is written and read via CPU directly.

* DMA-SHA Working Mode: all the data is read via crypto DMA. That is, users can configure the DMA
controller to read all the data needed for hash operation, thus releasing CPU for completing other tasks.

Users can start the SHA accelerator with different working modes by configuring registers SHA_START_REG and
SHA_DMA_START_REG. For details, please see Table 98.

Espressif Systems 444 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

 

Table 98: SHA Accelerator Working Mode

 

 

 

Working Mode Configuration Method
Typical SHA Set SHA_START_REG to 1
DMA-SHA Set SHA_DMA_START_REG to 1

 

 

 

 

Users can choose hash algorithms by configuring the SHA_MODE_REG register. For details, please see Table
99.

Table 99: SHA Hash Algorithm

 

Hash Algorithm SHA_MODE_REG Configuration
SHA-1
SHA-224
SHA-256
SHA-384
SHA-512
SHA-512/224
SHA-512/256
SHA-512/t

 

 

 

 

 

 

 

 

 

 

 

NN] OO] Oa?) @] mel] o

 

 

Notice:

ESP32-S2’s Digital Signature and HMAC modules also call the SHA accelerator. Therefore, users cannot

 

access the SHA accelerator when these modules are working.

 

20.4 Function Description
SHA accelerator can generate the message digest via two steps: the Preprocessing and Hash operation.

20.4.1 Preprocessing
Preprocessing consists of three steps: padding the message, parsing the message into message blocks and
setting the initial hash value.

20.4.1.1 Padding the Message

The SHA accelerator can only process message blocks of 512 or 1024 bits, depending on the algorithm. Thus,
all the messages should be padded to a multiple of 512 or 1024 bits before the hash computation.

Suppose that the length of the message M is m bits. Then M shall be padded as introduced below:
° SHA-1, SHA-224 and SHA-256
1. First, append the bit “1” to the end of the message;

2. Second, append k zero bits, where & is the smallest, non-negative solution to the equation
m+1+k= 448 mod 512;

8. Last, append the 64-bit block that is equal to the number m expressed using a binary representation.

Espressif Systems 442 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback

 
20. SHA Accelerator

 

° SHA-384, SHA-512, SHA-512/224, SHA-512/256 and SHA-512/t
1. First, append the bit “1” to the end of the message;

2. Second, append k zero bits, where & is the smallest, non-negative solution to the equation
m+1+k = 896 mod 1024;

3. Last, append the 128-bit block that is equal to the number m expressed using a binary representation.

For more details, please refer to Section “5.1 Padding the Message” in FIPS PUB 180-4 Spec.

20.4.1.2 Parsing the Message

The message and its padding must be parsed into N 512-bit or 1024-bit blocks.

° For SHA-1, SHA-224 and SHA-256: the message and its padding are parsed into N 512-bit blocks, M™,
M®),...,. M&), Since the 512 bits of the input block may be expressed as sixteen 32-bit words, the first
82 bits of message block z are denoted MoO, the next 32 bits are Me, and so on up to Me.

° For SHA-384, SHA-512, SHA-512/224, SHA-512/256 and SHA-51 2/t: the message and its padding are
parsed into N 1024-bit blocks. Since the 1024 bits of the input block may be expressed as sixteen 64-bit
words, the first 64 bits of message block 7 are denoted Mo, the next 64 bits are Me, and so on up to Vie

In Typical SHA working mode, all the message blocks are written into the SHA_M_n_REG, following the rules
below:

° For SHA-1, SHA-224 and SHA-256: M\ is stored in SHA _M_O_REG, M“) stored in SHA M_1_REG, ...,
and M(’ stored in SHA_M_15_REG.

* For SHA-384, SHA-512, SHA-51 2/224 and SHA-51 2/256: the most significant 32 bits and the least
significant 32 bits of Mo are stored in SHA_M_O_REG and SHA_M_1_REG, respectively, ..., the most
significant 32 bits and the least significant 32 bits of Me are stored in SHA_M_30_REG and
SHA_M_31_REG, respectively.

 

Note:

For more information about “message block”, please refer to Section “2.1 Glossary of Terms and Acronyms” in FIPS PUB
180-4 Spec.

 

 

 

In DMA-SHA working mode, please complete the following configuration:
1. Create an external linked list;

2. Configure this linked list based on the instruction described in Chapter DMA Controller, including but not
limited to assigning the starting address of the input message to the buffer address pointer of the linked list;

3. Configure the CRYPTO_DMA_OUTLINK_ADDR to the first out-link linked list;
4. Write 1 to register CRYPTO_DMA_OUTLINK_START, so the DMA starts to move data;

5. Write 1 to register CRYPTO_DMA AES SHA_SELECT_REG, so the SHA accelerator gets to use the DMA
resource shared by AES and SHA accelerators.

Espressif Systems 443 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

 

20.4.1.3 Initial Hash Value

Before hash computation begins for each of the secure hash algorithms, the initial Hash value H® must be set
based on different algorithms, among which the SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224,
and SHA-512/256 algorithms use the initial Hash values (constant C) stored in the hardware.

However, SHA-512/t requires a distinct initial hash value for each operation for a given value of ¢. Simply put,
SHA-512/t is the generic name for a t-bit hash function based on SHA-512 whose output is truncated to t bits. ¢
is any positive integer without a leading zero such that #<512, and ¢ is not 384. The initial hash value for
SHA-512/t for a given value of ¢ can be calculated by performing SHA-512 from hexadecimal representation of
the string “SHA-512/?’. It’s not hard to observe that when determining the initial hash values for SHA-512/t
algorithms with different ¢, the only difference lies in the value of ¢.

Therefore, we have specially developed the following simplified method to calculate the initial hash value for
SHA-512/t:

1. Generate t_string and t_length: t_string is a 32-bit data that stores the input message of 7. t_length is a
7-bit data that stores the length of the input message. The t_string and t_length are generated in methods
described below, depending on the value of t:

© lfl <=t <= 9, then t_length = 7'h48 and t_string is padded in the following format:

 

8'A3to | 1bl | 23/60

 

where to = t.
For example, if ¢ = 8, then tp = 8 and t_string = 32'h38800000.

© If 10 <=t <= 99, then t_length = 7'h50 and t_string is padded in the following format:

 

| 8/A3t, | 8 A3ty | bl | 15/0

 

where, to = t%10 and t) = t/10.
For example, if f= 56, then to = 6, t, = 5, and t_string = 32'h35368000.

© If 100 <=t < 512, then t_length = 7'h58 and t_string is padded in the following format:

 

| sn3t2 | vast, — | s'h3to — | vei | 70

 

where, to = t%10, t1 = (£/10)%10, and tz = ¢/100.
For example, if f= 231, then tp = 1, t, = 8, t2 = 2, and t_string = 32'h32333180.

2. Initialize relevant registers: Initialize SHA_T_STRING_REG and SHA_T_LENGTH_REG with the
generated t_string and t_length in the previous step.

3. Obtain initial hash value: Set the SHA_MODE_REG register to 7. Set the SHA_START_REG register to 1
to start the SHA accelerator. Then poll register SHA_BUSY_REG until the content of this register becomes
O, indicating the calculation of initial hash value is completed.

Please note that the initial value for SHA-512/t can be also calculated according to the Section “5.3.6 SHA-512/?”
in FIPS PUB 180-4 Spec, that is performing SHA-512 operation (with its initial hash value set to the result of
8-bitwise XOR operation of C and Oxad) from the hexacecimal representation of the string “SHA-512/?”.

Espressif Systems 444 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

 

20.4.2 Hash Computation Process

After the preprocessing, the ESP32-S2 SHA accelerator starts to hash a message M and generates message
digest of different lengths, depending on different hash algorithms. As described above, the ESP32-S2 SHA
accelerator supports two working modes, which are Typical SHA and DMA-SHA. The operation process for the
SHA accelerator under two working modes is described in the following subsections.

20.4.2.1 Typical SHA Process

ESP32-S2 SHA accelerator supports “interleave” functionality when working under Typical SHA mode:

* Type “alone”: Users do not insert any new computation before the SHA accelerator completes all the
message blocks.

* Type “interleave”: Users can insert new computations (both Typical SHA task and DMA-SHA task) every
time the SHA accelerator completes one message block. To be more specific, users can store the message
digest in registers SHA_H_?_REG after completing each message block, and assign the accelerator with
other higher priority tasks. After the inserted task completes, users can put the message digest stored
back to registers SHA_H_n_REG, and resume the accelerator with the previously paused computation.

Typical SHA Process (except for SHA-51 2/7)

1. Select a hash algorithm.

® Select a hash algorithm by configuring the SHA_MODE_REG register. For cletails, please refer to Table
99.

2. Process the current message block.
(a) Write the current message block in registers SHA_M_n_REG;
(6) Start the SHA accelerator !:

® If this is the first time to execute this step, set the SHA_START_REG register to 1 to start the SHA
accelerator. In this case, the accelerator uses the initial hash value stored in hardware for a given
algorithm configured in Step 1 to start the computation;

® If this is not the first time to execute this step, set the SHA_CONTINUE_REG register to 1 to start
the SHA accelerator. In this case, the accelerator uses the hash value stored in the
SHA_H_n_REG register to start computation.

(c) Poll register SHA_BUSY_REG until the content of this register becomes 0, indicating the accelerator
has completed the computation for the current message block and now is in the “idle” status. Then,
go to step 3.

3. Decide if you want to insert other computations.
* If yes, please get ready for handing over the SHA accelerator for the new task:

(a) Read and store the hash algorithm selected for the current computation stored in the
SHA_MODE_REG register;

(b) Read and store the message digests stored in registers SHA_H_n_REG;

(c) Last, please go to perform the inserted computation. For the detailed process of the inserted
computation, please refer to Typical SHA or DMA-SHA, depending on the working mode.

Espressif Systems 445 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

 

* Otherwise, please continue to execute Step 4.

4. Decide if you have more message blocks following the previous computation:
* If yes, please go back to 2.
* Otherwise, go to Step 5.

5. Decide if you need to return the SHA accelerator to a previous computation (i.e., decide whether the
current task is an inserted task or not):

* If yes, please get ready to return the SHA accelerator for the previous computation:
(a) Write the previously stored hash algorithm back to register SHA_MODE_REG;
(b) Write the previously stored message digests back to registers SHA_H_n_REG;
(c} Then, go to Step 2.
* Otherwise, there is no need to return SHA Control. Therefore, please go to Step 6 directly.
6. Obtain the message digests:

* Read the message digests from registers SHA_H_n_REG.

Typical SHA Process (SHA-51 2//)

1. Select a hash algorithm.
® Select SHA-512/ algorithm by configuring the SHA_MODE_REG register to 7.
2. Calculate the initial hash value.

(a) Calculate t_stiring and t_length and initialize SHA_T_STRING_REG and SHA_T_LENGTH_REG with
the generated t_string and t_length. For details, please refer to Section 20.4.1.3.

(b) Set the SHA_START_REG register to 1 to start the SHA accelerator.

(c) Poll register SHA_BUSY_REG until the content of this register becomes 0, indicating the calculation of
initial hash value is completed.

3. Process the current message block.
(a) Write the current message block in registers SHA_M_n_REG;
(0) Start the SHA accelerator !:

® Set the SHA_CONTINUE_REG register to 1 to start the SHA accelerator. In this case, the
accelerator uses the hash value stored in the SHA_H__REG register to start computation.

(c) Poll register SHA_BUSY_REG until the content of this register becomes 0, indicating the accelerator
has completed the computation for the current message block and now is in the “idle” status. Then,
go to step 4.

4. Decide if you want to insert other computations.
* If yes, please get ready for handing over the SHA accelerator for the new task:

(a) Read and store the hash algorithm selected for the current computation stored in the
SHA_MODE_REG register;

(b) Read and store the message digests stored in registers SHA_H_n_REG;

Espressif Systems 446 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

(c) Last, please go to perform the inserted computation. For the detailed process of the inserted
computation, please refer to Typical SHA or DMA-SHA, depending on the working mode.

* Otherwise, please continue to execute Step 5.

5. Decide if you have more message blocks following the previous computation:
* If yes, please go back to 3.
* Otherwise, go to Step 6.

6. Decide if you need to return the SHA accelerator to a previous computation (i.e., decide whether the
current task is an inserted task or not):

* If yes, please get ready to return the SHA accelerator for the previous computation:
(a) Write the previously stored hash algorithm back to register SHA_MODE_REG;
(b) Write the previously stored message digests back to registers SHA_H_n_REG;
(c) Then, go to Step 3.
* Otherwise, there is no need to return SHA Control. Therefore, please go to Step 7 directly.
7. Obtain the message digests:

* Read the message digests from registers SHA_H_n_REG.

 

Note:
1. In Step 2b, the software can also write the next message block (to be processed) in registers SHA_M_n_REG, if
any, while the hardware starts SHA computation, to save time.

 

 

 

20.4.2.2 DMA-SHA Process

ESP32-S2 SHA accelerator does not support type “interleave” computation, which means you cannot insert new
computation before the whole DMA-SHA process completes. In this mode, users who need task insertion are
recommended to divide your message blocks and perform several DMA-SHA computations, instead of trying to

compute all the messages in one go.

In contrast to the Typical SHA working mode, when the SHA accelerator is working under the DMA-SHA mode,
all data read are completed via crypto DMA.

Therefore, users are required to configure the DMA controller as instructed in Subsection 20.4.1.2.
DMA-SHA process (except SHA-512/t)
1. Select a hash algorithm.

® Select a hash algorithm by configuring the SHA_MODE_REG register. For cletails, please refer to Table
99.

2. Configure the SHA_INT_ENA REG register to enable or disable interrupt (Set 1 to enable).

3. Configure the number of message blocks.

° Write the number of message blocks M to the SHA_DMA_ BLOCK _NUM_REG register.

4. Start the DMA-SHA computation.

Espressif Systems 447 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

 

® If the current DMA-SHA computation follows a previous computation, firstly write the message digest
from the previous computation to registers SHA_H_n_REG, then write 1 to register
SHA_DMA_CONTINUE_REG to start SHA accelerator;

* Otherwise, write 1 to register SHA_DMA_START_REG to start the accelerator.
5. Wait till the completion of the DMA-SHA computation, which happens when:
* The content of SHA_BUSY_REG register becomes 0, or

* An SHA interrupt occurs. In this case, please clear interrupt by writing 1 to the SHA_INT_ CLEAR REG
register.

6. Obtain the message digests:
* Read the message digests from registers SHA_H_n_REG.
DMA-SHA process for SHA-512/t
1. Select a hash algorithm.
® Select SHA-512/ algorithm by configuring the SHA_MODE_REG register to 7.
2. Configure the SHA_INT_ENA REG register to enable or disable interrupt (Set 1 to enable).
8. Calculate the initial hash value.

(a) Calculate t_stiring and t_length and initialize SHA_T_STRING_REG and SHA_T_LENGTH_REG with
the generated t_string and t_length. For details, please refer to Section 20.4.1.3.

(b) Set the SHA_START_REG register to 1 to start the SHA accelerator.

(c) Poll register SHA_BUSY_REG until the content of this register becomes 0, indicating the calculation of
initial hash value is completed.

4. Configure the number of message blocks.

° Write the number of message blocks M to the SHA_DMA_ BLOCK _NUM_REG register.
5. Start the DMA-SHA computation.

° Write 1 to register SHA_DMA_CONTINUE_REG to start the accelerator.
6. Wait till the completion of the DMA-SHA computation, which happens when:

* The content of SHA_BUSY_REG register becomes 0, or

* An SHA interrupt occurs. In this case, please clear interrupt by writing 1 to the SHA_INT_ CLEAR REG
register.

7. Obtain the message digests:

* Read the message digests from registers SHA_H_n_REG.

20.4.3 Message Digest

After the hash computation completes, the SHA accelerator writes the message cigests from the computation to
registers SHA_H_n_REG(7: 0~15). The lengths of the generated message digest are different depending on
different hash algorithms. For details, see Table 103 below:

Table 103: The Storage and Length of Message Digests from Different Algorithms

 

Espressif Systems 448 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

. Length of Message Di-

Hash Algorithm — Storage +
gest (in bits)

SHA-1 160 SHA_H_O_REG ~ SHA_H_4 REG
SHA-224 224 SHA_H_O_REG ~ SHA_H_6_REG
SHA-256 256 SHA_H_O_REG ~ SHA_H_7_REG
SHA-384 384 SHA_H_O_REG ~ SHA_H_11_REG
SHA-512 512 SHA_H_O_REG ~ SHA_H_15 REG
SHA-512/224 224 SHA_H_O_REG ~ SHA_H_6_REG
SHA-512/256 256 SHA_H_O_REG ~ SHA_H_7_REG
SHA-512/i 2 t SHA_H_O_REG ~ SHA_H_x_REG
Note:

1. The message digests are stored in registers from most significant bits to the least significant bits, with the first word
stored in register SHA_H_O_REG and the second word stored in register SHA_H_1_REG... For details, please see
subsection 20.4.1.2.

2. The registers used for SHA-512/t algorithm depend on the value of t. x+1 indicates the number of 32-bit registers
used to store ¢ bits of message digest, so that x = roundup(t/32)-1. For example:
e When t = 8, then x = 0, indicating that the 8-bit long message digest is stored in the most significant 8 bits of
register SHA_H_O_REG;
e When t = 32, then x = 0, indicating that the 32-bit long message digest is stored in register SHA_H_O_REG;

e When?t= 132, then x = 4, indicating that the 132-bit long message digest is stored in registers SHA_H_O_REG,
SHA_H_1_REG, SHA_H_2_REG, SHA_H_3_REG, and SHA_H_4_REG.

 

 

 

20.4.4 Interrupt

SHA accelerator supports interrupt on the completion of computation when working in the DMA-SHA mode. To
enable this function, write 1 to register SHA_INT_ENA_REG. Note that the interrupt should be cleared by
software after use via setting the SHA_INT_CLEAR_REG register to 1.

Espressif Systems 449 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
20. SHA Accelerator

 

20.5 Base Address

Users can access SHA with two base addresses, which can be seen in Table 104. For more information about

accessing peripherals from different buses, please see Chapter 1 System and Memory.

Table 104: Base Address

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Bus Base Address
PeriBUS1 Ox3F438BO000
PeriBUS2 Ox6003BO000
20.6 Register Summary
Name | Description Address | Access
Control/Status registers
Continues SHA operation (only effective in Typi-
SHA_CONTINUE_ REG 0x0014 | WO
cal SHA mode)
SHA_BUSY_REG Indicates if SHA Accelerator is busy or not 0x0018 | RO
Starts the SHA accelerator for DMA-SHA oper-
SHA_DMA_START_REG . 0x001C | WO
ation
Starts the SHA accelerator for Typical SHA op-
SHA_START_REG . 0x0010 | WO
eration
Continues SHA operation (only effective in DMA-
SHA_DMA_ CONTINUE REG 0x0020 | WO
SHA mode)
SHA_INT_CLEAR_REG DMA-SHA interrupt clear register 0x0024 | WO
SHA_INT_ENA_ REG DMA-SHA interrupt enable register 0x0028 | RAV
Version Register
SHA_DATE_REG Version control register Ox002C | RAV
Configuration Registers
SHA_MODE_REG Defines the algorithm of SHA accelerator Ox0000 | RAV
String content register for calculating initial Hash
SHA_T_STRING_REG } O0x0004 | RAV
Value (only effective for SHA-512/t)
String length register for calculating initial Hash
SHA_T_LENGTH_REG . 0x0008 | RAV
Value (only effective for SHA-512/t)
Memories
Block number register (only effective for DMA-
SHA_DMA_ BLOCK _NUM_REG Ox000C | RAV
SHA)
SHA_H_O_REG Hash value 0x0040 | RAV
SHA_H_1_REG Hash value 0x0044 | RAV
SHA_H_2 REG Hash value 0x0048 | RAV
SHA_H_3 REG Hash value Ox004C | RAV
SHA_H_4 REG Hash value Ox0050 =| RAV
SHA_H_5 REG Hash value 0x0054 | RAV
SHA_H_6 REG Hash value O0x0058 | RAV
SHA_H_7_REG Hash value Ox005C_ | RAV
SHA_H_8 REG Hash value Ox0060 | RAV
SHA_H_9_REG Hash value Ox0064 | RAV
Espressif Systems 450 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
20. SHA Accelerator

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
SHA_H_10_REG Hash value Ox0068 | RAV
SHA_H_11_REG Hash value Ox006C_ | RAV
SHA_H_12_REG Hash value 0x0070 | RAV
SHA_H_13_REG Hash value 0x0074 | RAV
SHA_H_14_REG Hash value 0x0078 | RAV
SHA_H_15_ REG Hash value Ox007C | RAV
SHA_M_O_REG Message Ox0080 | RAV
SHA_M_1_REG Message 0x0084 | RAV
SHA_M_2 REG Message O0x0088 | RAV
SHA_M_3_REG Message Ox008C | RAV
SHA_M_4 REG Message Ox0090 | RAV
SHA_M_5_ REG Message 0x0094 | RAV
SHA_M_6_REG Message Ox0098 | RAV
SHA_M_7_REG Message Ox009C | RAV
SHA_M_8 REG Message OxO0AO | RAV
SHA_M_9_REG Message OxO0A4 | RAV
SHA_M_10_REG Message OxO0A8 | RAV
SHA_M_11_REG Message OxOOAC | RAV
SHA_M_12_REG Message OxO0BO | RAV
SHA_M_138_ REG Message Ox00B4 | RAV
SHA_M_14_ REG Message Ox00B8 | RAV
SHA_M_15 REG Message OxOOBC | RAV
SHA_M_16_REG Message Ox00CO | RAV
SHA_M_17_REG Message Ox00C4 | RAV
SHA_M_18 REG Message Ox00C8 | RAV
SHA_M_19_REG Message Ox00CC | RAV
SHA_M_20_REG Message OxOO0DO | RAV
SHA_M_21_REG Message Ox00D4 | RAV
SHA_M_22 REG Message Ox00D8 | RAV
SHA_M_23 REG Message OxOODC | RAV
SHA_M_24 REG Message OxOOEO | RAV
SHA_M_25 REG Message OxO0E4 | RAV
SHA_M_26_REG Message OxO0E8 | RAV
SHA_M_27_REG Message OxOOEC | RAV
SHA_M_28 REG Message OxOOFO | RAV
SHA_M_29 REG Message OxOOF4 | RAV
SHA_M_S30_REG Message OxOOF8 | RAV
SHA_M_31_REG Message OxOOFC | RAV
Espressif Systems 451 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
20. SHA Accelerator

 

20.7 Registers

Register 20.1: SHA_START_REG (0x0010)

 

 

 

 

SHA_START Write 1 to start Typical SHA calculation. (WO)

Register 20.2: SHA_CONTINUE_REG (0x0014)

 

Je]

 

0 9 0] 0 |Reset

 

SHA_CONTINUE Write 1 to continue Typical SHA calculation. (WO)

Register 20.3: SHA_BUSY_REG (0x0018)

 

 

 

 

SHA_BUSY_STATE Indicates the states of SHA accelerator. (RO) 1’7hO: idle 1’h1: busy

Register 20.4: SHA_DMA_START_REG (0x001C)

 

 

joo 00000000000000000000009000 0 0

0

 

SHA_DMA_START Write 1 to start DMA-SHA calculation. (WO)

452
Submit Documentation Feedback

Espressif Systems

ESP32-S2 TRM (Preliminary V0.4)
20. SHA Accelerator

 

Register 20.5: SHA_DMA_CONTINUE_REG (0x0020)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

¥y
<
&
& ow
& ee
[1 1] o |
joo 0000000900000 0000000 00 00 00 0 0 0 0] 0 Reset
SHA_DMA_CONTINUE Write 1 to continue DMA-SHA calculation. (WO)
Register 20.6: SHA_INT_CLEAR_REG (0x0024)
S
&
eS
& *
& sw
31 1 oO
0000000000000 00000000 00 00 00 0 0 0 Of 0 IReset
SHA_CLEAR_INTERRUPT Clears DMA-SHA interrupt. (WO)
Register 20.7: SHA_INT_ENA_REG (0x0028)
w
&
CS
S &
sf Ss
LP we
& s
[1 if o |
jo0 0000090090000 09 09009 009 00 09 00 0 0 0 0] 0 Reset
SHA_INTERRUPT_ENA Enables DMA-SHA interrupt. (R/W)
Register 20.8: SHA_DATE_REG (0x002C)
> &
és os
& Ss
[1 30 9 o|
[o o| 0x20190402 |Reset
SHA_DATE Version control register. (RAM)
Espressif Systems 453 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
20. SHA Accelerator

 

Register 20.9: SHA_MODE_REG (0x0000)

 

31 3] 2 °

 

000000000006 006006060060 000060060060 06 06 0 0 0 0 6] oO IReset

 

 

 

 

SHA_MODE Defines the SHA algorithm. For details, please see Table 99. (RAV)

Register 20.10: SHA_T_STRING_REG (0x0004)

 

 

| 0x000000 | Reset

 

SHA_T_STRING Defines t_string for calculating the initial Hash value for SHA-512/t. (RAW)

Register 20.11: SHA_T_LENGTH_REG (0x0008)

 

 

 

 

 

 

 

 

S
& y
<$ ay
& a
[1 aE o|
[oo 0 0090000000000 900900000000 0 9 xO |Reset
SHA_T_LENGTH Defines t_length for calculating the initial Hash value for SHA-512/t. (RAV)
Register 20.12: SHA_DMA_BLOCK_NUM_REG (0x000C)
RN
»S
ov
oO
YY
S we
>
& ea
[a1 o[s o|
joo 0000000000000 000000 000 0 9 Ox0 |Reset
SHA_DMA_BLOCK_NUM Defines the DMA-SHA block number. (RAV)
Espressif Systems 454 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
20. SHA Accelerator

 

Register 20.13: SHA_H_»_REG (7: 0-15) (0x0040+4*n)

o
Ss

31 °

 

 

 

 

©x000000 Reset

 

SHA_H_/ Stores the nth 32-bit piece of the Hash value. (RAM)

Register 20.14: SHA_M_»_REG (: 0-31) (0x0080+4*")

o
Ss

 

 

| 0x000000 | Reset

 

SHA_M_/ Stores the nth 32-bit piece of the message. (R/W)

Espressif Systems 455 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
21. RSA Accelerator

 

21. RSA Accelerator

21.1 Introduction

The RSA Accelerator provides hardware support for high precision computation used in various RSA asymmetric
cipher algorithms by significantly reducing their software complexity. Compared with RSA algorithms
implemented solely in software, this hardware accelerator can speed up RSA algorithms significantly. Besides,
the RSA Accelerator also supports operands of different lengths, which provides more flexibility during the
computation.

21.2 Features
The following functionality is supported:

e Large-number modular exponentiation with two optional acceleration options
° Large-number modular multiplication

° Large-number multiplication

* Operands of different lengths

® Interrupt on completion of computation

21.3 Functional Description

The RSA Accelerator is activated by setting the DPORT_PERIP_CLK_EN1_REG bit in the
DPORT_CRYPTO_RSA_CLK_EN peripheral clock and clearing the DPORT_RSA_PD bit in the
DPORT_RSA_PD_CTRL_REG register. This releases the RSA Accelerator from reset.

The RSA Accelerator is only available after the RSA-related memories are initialized. The content of the
RSA_CLEAN_REG register is 0 during initialization and will become 1 after the initialization is done. Therefore, it is
advised to wait until RSA_CLEAN_REG becomes 1 before using the RSA Accelerator.

The RSA_INTERRUPT_ENA REG register is used to control the interrupt triggered on completion of
computation. Write 1 or 0 to this register to enable or disable interrupt. By default, the interrupt function of the
RSA Accelerator is enabled.

 

Notice:
ESP32-S2’s Digital Signature module also calls the RSA accelerator. Therefore, users cannot access the RSA
accelerator when Digital Signature is working.

 

 

 

Espressif Systems 456 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
21. RSA Accelerator

21.3.1 Large Number Modular Exponentiation

Large-number modular exponentiation performs Z = XY mod M. The computation is based on Montgomery
multiplication. Therefore, aside from the X, Y, and M arguments, two additional ones are needed — 7 and M’,
which need to be calculated in advance by software.

RSA Accelerator supports operands of length N = 32 x x2, where x € {1,2,3,...,128}. The bit lengths of
arguments Z, X, Y, M, and? can be arbitrary N, but all numbers in a calculation must be of the same length.
The bit length of /’ must be 32.

To represent the numbers used as operands, let us define a base-b positional notation, as follows:

b= 2

Using this notation, each number is represented by a sequence of base-b digits:

N

nz

32
(Zn—-1Zn—2 a Zo)b

Z=
X = (Xy-1Xn-2--- Xo)s
Y = (Yn-1¥n-2-+ Yo)o
M = (My-1Mn-2---Mo)o

T= (Fn—1?P n—2 aa -Fo)b

Each of the n values in Z,-1--- Zo, Xn—-1---X0; Yn—-1--- Yo, Mn-1--- Mo, Fn—1---7Fo represents one base-b
digit (a 82-bit word).

Zn-1; Xn—-1; Yn—1, Mn—1 and ?,_1 are the most significant bits of Z, X, Y, M, while Zp, Xo, Yo, Mo and 7» are
the least significant bits.

If we define R = b”, the additional arguments can be calculated as F = R? mod M, where R = b”.

The following equation in the form compatible with the extended binary GCD algorithm can be written as

M+xM+1=RxR1
M'=M~'modb

Large-number modular exponentiation can be implemented as follows:
1. Write 1 or 0 to the RSA_INTERRUPT_ENA REG register to enable or disable the interrupt function.
2. Configure relevant registers:
(a) Write (4s — 1) to the RSA_MODE_REG register.
(b) Write MM’ to the RSA_M_PRIME_REG register.
(c) Configure registers related to the acceleration options, which are cescribed later in Section 21.3.4.

3. Write X;, ¥;, M; and 7; for 2 € {0,1,...,n} to memory blocks RSA_X_MEM, RSA_Y_MEM, RSA_M_MEM
and RSA_Z MEM. The capacity of each memory block is 128 words. Each word of each memory block

Espressif Systems 457 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
21. RSA Accelerator

 

can store one base-b digit. The memory blocks use the little endian format for storage, i.e. the least
significant cigit of each number is in the lowest address.

Users need to write data to each memory block only according to the length of the number; data beyond
this length are ignored.

4. Write 1 to the RSA_MODEXP_START_REG register to start computation.

5. Wait for the completion of computation, which happens when the content of RSA_IDLE_REG becomes 1
or the RSA interrupt occurs,

6. Read the result Z; forz € {0,1,...,} from RSA_Z_ MEM.
7. Write 1 to RSA_CLEAR_INTERRUPT_REG to clear the interrupt, if you have enabled the interrupt function.

After the computation, the RSA_MODE_REG register, memory blocks RSA_Y_MEM and RSA_M_MEM, as well
as the RSA_M_PRIME_REG remain unchanged. However, X; in RSA_X_MEM and 7; in RSA_Z_MEM
computation are overwritten, and only these overwritten memory blocks need to be re-initialized before starting
another computation.

21.3.2 Large Number Modular Multiplication
Large-number modular multiplication performs Z = X x Y mod M. This computation is based on Montgomery
multiplication. The same values 7 and M’ are clerived by software.

The RSA Accelerator supports large-number modular multiplication with operands of 128 different lengths.
The computation can be executed as follows:
1. Write 1 or 0 to the RSA_INTERRUPT_ENA REG register to enable or disable the interrupt function.
2. Configure relevant registers:
(a) Write (s — 1) to the RSA_MODE_REG register.
(b) Write M’ to the RSA_M_PRIME_REG register.

3. Write X;, Y;, Mj, and; fori € {0,1,...,n} to registers RSA_X_MEM, RSA_Y_MEM, RSA_M_MEM and
RSA_Z_MEM. The capacity of each memory block is 128 words. Each word of each memory block can
store one base-b digit. The memory blocks use the little endian format for storage, i.e. the least significant
digit of each number is in the lowest address.

Users need to write data to each memory block only according to the length of the number; data beyond
this length are ignored.

4. Write 1 to the RSA_-MODMULT_START_REG register.

5. Wait for the completion of computation, which happens when the content of RSA_IDLE_REG becomes 1
or the RSA interrupt occurs,

6. Read the result Z; forz € {0,1,...,} from RSA_Z_ MEM.
7. Write 1 to RSA_CLEAR_INTERRUPT_REG to clear the interrupt, if you have enabled the interrupt function.

After the computation, the length of operands in RSA_MODE_REG, the X; in memory RSA_X_MEM, the ¥; in
memory RSA_Y_MEM, the M; in memory RSA_M_MEM, and the MM’ in memory RSA_M_PRIME_REG remain
unchanged. However, the ¥; in memory RSA_Z MEM has already been overwritten, and only this overwritten

memory block needs to be re-initialized before starting another computation.

Espressif Systems 458 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
21. RSA Accelerator

 

21.3.3 Large Number Multiplication

Large-number multiplication performs Z = X x Y. The length of result Z is twice that of operand X and operand
Y. Therefore, the RSA Accelerator only supports Large Number Multiplication with operand length N = 32 x a,
where x € {0,1,...,64}. The length N of result Z is 2x N.

The computation can be executed as follows:
1. Write 1 or 0 to the RSA_INTERRUPT_ENA REG register to enable or disable the interrupt function.

2. Write (x —1), Le. (4 — 1) to the RSA_MODE_REG register.

16
3. Write X; and Y; for € {0,1,...,} to registers RSA_X_MEM and RSA_Z_MEM. The capacity of each
memory block is 128 words. Each word of each memory block can store one base-b digit. The memory
blocks use the little endian format for storage, i.e. the least significant digit of each number is in the lowest
address. nis ¥.

Write X; for i € {0,1,...,n} to the address of the 7 words of the RSA_X_MEM register. Note that Y; for
i € {0,1,...,n} will not be written to the address of the i words of the RSA_Z_MEM register, but the
address of the n + i words, i.e. the base address of the RSA_Z_MEM memory plus the address offset
4x (n+i).

Users need to write data to each memory block only according to the length of the number; data beyond
this length are ignored.

4. Write 1 to the RSA_MULT_START_REG register.

5. Wait for the completion of computation, which happens when the content of RSA_IDLE_REG becomes 1
or the RSA interrupt occurs,

6. Read the result Z; forz € {0,1,...,n} from the RSA_Z_MEM register. f is 2 x n.
7. Write 1 to RSA_CLEAR_INTERRUPT_REG to clear the interrupt, if you have enabled the interrupt function.

After the computation, the length of operands in RSA_MODE_REG and the X; in memory RSA_X_MEM remain
unchanged. However, the ¥; in memory RSA_Z MEM has already been overwritten, and only this overwritten
memory block needs to be re-initialized before starting another computation.

21.3.4 Acceleration Options

ESP32-S2 RSA provides two acceleration options for the large-number modular exponentiation, which are
SEARCH Option and the CONSTANT_TIME Option. These two options are both disabled by default, but can be
enabled at the same time.

When neither of these two options are enabled, the time required to calculate Z = X¥ mod M is solely
determined by the lengths of operands. However, when either one of these two options is enabled, the time
required is also correlated with the 0/1 distribution of Y.

To better illustrate the acceleration options, first assume Y is represented in binaries as

Y¥ = (Yy-1¥v-2-- Yin ¥i¥i-1---Yo)e

where,

® N is the length of Y,

Espressif Systems 459 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
21. RSA Accelerator

 

* ¥,is1,

° Yn-1, Yn—2, .

ws Year are all equal to 0,

* and Yi-1, Yi_9, bes Yo are either O or 1 but exactly m bits should be equal to 0 and t-m bits 1, i.e. the
Hamming weight of ¥i_1¥;_2, te Yo ist—m.

When the acceleration options are enabled, the RSA accelerator:

* SEARCH Option

— The accelerator ignores the bit positions of Y;, where i > a. Search position a is set by configuring
the RSA_SEARCH_POS_REG register. The maximum value of a is N-1, which leads to the same
result when this accleration option is disabled. The best acceleration performance can be achieved by
setting @ to t, in which case, all the Vues Yn—ay os Yiga of Os are ignored during the calculation.
Note that if you set @ to be less than ¢, then the result of the modular exponentiation Z = XY mod M
will be incorrect.

¢ CONSTANT_TIME Option

— The accelerator speeds up the calculation by simplifying the calculation concerning the 0 bits of Y.
Therefore, the higher the proportion of bits 0 against bits 1, the better the acceleration performance is.

We provide an example to demonstrate the performance of the RSA Accelerator when different acceleration
options are enabled. Here we perform Z = X¥ mod M with N = 3072 and Y = 65537. Table 106 below
demonstrates the time costs when different acceleration options are enabled. It’s obvious that the time cost can
be dramatically reduced when acceleration option(s) is enabled. Here, we should also mention that, a is set to 16
when the SEARCH option is enabled.

Table 106: Acceleration Performace

 

 

 

 

 

 

 

 

 

 

 

SEARCH Option | CONSTANT_TIME Option | Time Cost Acceleration Performance by Percentage
Disabled Disabled 376.405 ms | 0%
Enabled Disabled 2.260 ms 99.41%
Disabled Enabled 1.203 ms 99.68%
Enabled Enabled 1.165 ms 99.69%
Espressif Systems 460 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
21. RSA Accelerator

 

21.4 Base Address

Users can access RSA with two base addresses, which can be seen in Table 107. For more information about

accessing peripherals from different buses please see Chapter 1 System and Memory.

Table 107: RSA Base Address

 

 

 

 

 

Bus to Access Peripheral Base Address
PeriBUS1 OxSF43C000
PeriBUS2 Ox6003C000

 

 

21.5 Memory Summary

Both the starting address and ending address in the following table are relative to RSA base addresses provided

in Section 21.4.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Size (byte) | Starting Address | Ending Address | Access
RSA_M_MEM Memory M 512 Ox0000 Ox01FF WO
RSA_Z MEM Memory Z 512 0x0200 OxOSFF R/AW
RSA_Y_MEM Memory Y 512 0x0400 OxO5FF WO
RSA_X_MEM Memory X 512 Ox0600 Ox07FF WO
21.6 Register Summary
The addresses in the following table are relative to RSA base addresses provided in Section 21.4.
Name | Description Address Access
Configuration Registers
RSA_M_PRIME_REG Register to store M’ Ox0800 RAW
RSA_MODE_REG RSA length mode 0x0804 RAW
RSA_CONSTANT_TIME_REG The constant_time option 0x0820 RAW
RSA_SEARCH_ENABLE_REG The search option 0x0824 RAW
RSA_SEARCH_POS_REG The search position 0x0828 RAW
Status/Control Registers
RSA_CLEAN_REG RSA clean register Ox0808 RO
RSA_MODEXP_START_REG Modular exponentiation starting bit Ox080C WO
RSA_MODMULT_START_REG Modular multiplication starting bit 0x0810 WO
RSA_MULT_START_REG Normal multiplication starting bit 0x081 4 WO
RSA_IDLE_REG RSA idle register 0x0818 RO
Interupt Registers
RSA_CLEAR_INTERRUPT_REG RSA clear interrupt register 0x081C WO
RSA_INTERRUPT_ENA REG RSA interrupt enable register Ox082C RAW
Version Register
RSA_DATE_REG Version control register O0x0830 RAW

 

 

 

Espressif Systems

461
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
21. RSA Accelerator

21.7 Registers

Register 21.1: RSA_M_PRIME_REG (0x800)

 

| 0x000000000 | Reset

RSA_M_PRIME_REG Stores M’.(R/W)

Register 21.2: RSA_MODE_REG (0x804)

 

31 7/6 °

 

 

 

000000000000000809808908O090 0 ;0800 0 0 0 0/0 0 0 0 0 0 O]Reset

 

 

RSA_MODE Stores the mode of modular exponentiation. (RAV)

Register 21.3: RSA_CLEAN_REG (0x0808)

e &

& ee
[z Te]

joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset

RSA_CLEAN The content of this bit is 1 when memories complete initialization. (RO)

Register 21.4: RSA_MODEXP_START_REG (0x080C)

 

31

 

 

0 0 00 0 00 00 00 0 00 00 00 0 00 00 00 0 0 0 0 0 O} O Reset

 

 

 

RSA_MODEXP_START Set this bit to 1 to start the modular exponentiation. (WO)

Espressif Systems 462 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
21. RSA Accelerator

 

Register 21.5: RSA_MODMULT_START_REG (0x0810)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Kj
“f
S
4a?7
ww
& &
& Pe
© &
31 1 oO
0000000000000 00000000 00 00 00 0 0 0 Of 0 IReset
RSA_MODMULT_START Set this bit to 1 to start the modular multiplication. (WO)
Register 21.6: RSA_MULT_START_REG (0x081 4)
A
A
S
S se
of s
& wy
€ &
[1 1] o |
joo 0000000900000 0000000 00 00 00 0 0 0 0] 0 Reset
RSA_MULT_START Set this bit to 1 to start the multiplication. (WO)
Register 21.7: RSA_IDLE_REG (0x0818)
& s”
2 y
& &
[1 ‘]o |
joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset
RSA_IDLE The content of this bit is 1 when the RSA accelerator is idle. (RO)
Register 21.8: RSA_CLEAR_INTERRUPT_REG (0x081C)
Ss
&
S
& S
& Py
€ &
[1 ‘]o |
joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset
RSA_CLEAR_INTERRUPT Set this bit to 1 to clear the RSA interrupts. (WO)
Espressif Systems 463 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
21. RSA Accelerator

 

Register 21.9: RSA_CONSTANT_TIME_REG (0x0820)

 

 

 

 

w&
Wr
A
©
& S&
@ SL
& &
lf if
joo 0 0 0000090000000 9 00900000 00 0 0 0 0 0 0[1 IReset
RSA_CONSTANT_TIME_REG Set this bit to 0 to enable the acceleration option of constant_time for
modular exponentiation. Set to 1 to disable the acceleration (by default). (R/V)
Register 21.10: RSA_SEARCH_ENABLE_REG (0x0824)
&
we
N07
O
gs
& &
& ok

 

 

 

 

RSA_SEARCH_ENABLE Set this bit to 1 to enable the acceleration option of search for modular
exponentiation. Set to 0 to disable the acceleration (by default). (RAV)

Register 21.11: RSA_SEARCH_POS_REG (0x0828)

e gS
eC &

[a1 wu o|

 

 

 

foo 0 0000000000000 00 0 0 0x00 |Reset

 

RSA_SEARCH_POS ls used to configure the starting address when the acceleration option of search
is used. (RAW)

Espressif Systems 464 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
21. RSA Accelerator

 

Register 21.12: RSA_INTERRUPT_ENA_REG (0x082C)

 

 

 

 

 

 

 

 

 

 

w
gr
©
S S
sf Ss
& es
€ &
[1 1 0 |
joo 0 0 0000090000000 9 00900000 00 0 0 0 0 0 0[1 IReset
RSA_INTERRUPT_ENA Set this bit to 1 to enable the RSA interrupt. This option is enabled by default.
(RW)
Register 21.13: RSA_DATE_REG (0x0830)
s &
g 5
e L
31 30 | 29 0
0 0 0x201 90425 Reset
RSA_DATE Version control register. (RAM)
Espressif Systems 465 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
22. Random Number Generator

 

22. Random Number Generator

22.1 Introduction
The ESP82-S2 contains a true random number generator, which generates random numbers that can be used

for cryptographical operations, among other things.

22.2 Features

The random number generator generates true random numbers, which means no number generated within the
specified range is more or less likely to appear than any other number.

22.3 Functional Description

When used correctly, every 32-bit value that the system reads from the RNG_DATA_REG register of the random
number generator is a true random number. These true random numbers are generated based on the thermal
noise in the system.

Either the high-speed ADC, SAR ADC, or both can be used as the noise source for the random number
generator.

 

Random bit
seeds XOR

Random
> RNG_DATA REG
Generator

Figure 22-1. Noise Source

SAR ADC

 

 

 

 

 

 

 

 

 

High Speed | Random bit
ADC

 

 

 

When there is noise coming from the high-speed ADC, the random number generator is fed with a 2-bit entropy
in one APB clock cycle, which is normally 80 MHz. Thus, it is advisable to read the RNG_DATA_REG register at a
maximum rate of 5 MHz to obtain the maximum entropy.

When there is noise coming from the SAR ADC, the random number generator is fed with a 2-bit entropy in one
clock cycle of 8 MHz, which is generated from an internal RC oscillator (see Reset and Clock for details). Thus, it
is advisable to read the RNG_DATA_REG register at a maximum rate of 500 kHz to obtain the maximum
entropy.

A data sample of 2 GB, which is read from the random number generator at a rate of 5 MHz with only the
high-speed ADC being enabled, has been tested using the Dieharder Random Number Testsuite (version 3.31.1).
The sample passed all tests.

 

Note:

When the Wi-Fi module is enabled, the value read from the high-speed ADC can be saturated in some extreme cases,
which lowers the entropy. Thus, it is advisable to enable the SAR ADC as the noise source for the random number
generator when the Wi-Fi module is enabled.

 

 

 

Espressif Systems 466 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
22. Random Number Generator

 

To facilitate the generation of random numbers, a system API for generating random numbers will be provided.
It’s advisable to call this API directly.

22.4 Base Address

Users can access the random number generator with two base addresses, which can be seen in Table 110. For
more information about accessing peripherals trom different buses, please see Chapter 1 System and
Memory.

Table 110: Random Number Generator Base Address

 

Bus Base Address
PeriBUS1 Ox3F435000
PeriBUS2 Ox60035000

 

 

 

 

 

 

22.5 Register Summary
The addresses in the following table are relative to the random number generator base addresses provided in
Section 22.4,

 

Name Description Address Access
RNG_DATA_REG Random number cata 0x0110 RO

 

 

 

 

 

 

 

22.6 Register

The address in this section is relative to the random number generator base addresses provided in Section
22.4,

Register 22.1: RNG_DATA_REG (0x0110)

 

 

| 0x00000000 | Reset

 

RNG_DATA Random number source. (RO)

Espressif Systems 467 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
23. External Memory Encryption and Decryption

 

23. External Memory Encryption and Decryption

23.1 Overview

The ESP82-S2 SoC implements an External Memory Encryption and Decryption module that secures users’
application code and data stored in the external memory (flash and external RAM). The encryption and
decryption algorithm complies with the XTS-AES standard specified in IEEE Std 1619-2007. Users can store
proprietary firmware and sensitive data (for example credentials for gaining access to a private network) to the
external flash, and general data to the external RAM.

23.2 Features
* General XTS-AES algorithm, compliant with IEEE Std 1619-2007

* Software-based manual encryption
* High-speed hardware auto encryption
* High-speed hardware auto decryption

* Encryption and decryption functions jointly determined by register configuration, eFuse parameters, and
boot mode

23.3 Functional Description

The External Memory Encryption and Decryption module consists of three blocks, namely the Manual Encryption
block, Auto Encryption block, and Auto Decryption block. The module architecture is shown in Figure

23-1.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

ee
: External Memory |
| Eneryption/Decryption|
I :
\ :
: I
SYSTEM_ENABLE_SP|_MANUAL ENCRYPT | EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT
SYSTEM_ENABLE_DOWNLOAD_MANUAL_ENGRYPT »| _Manual ]
| Encryption Menon fnorroreromenng
> !
!
I :
I
I eFuse
System SYSTEM_ENABLE_DOWNLOAD_DB_ENCRYPT ! | Auto ! Controller
Register cele Encryption i
| I
__..Boot Mode i | |
|
| »| e---! weeeneee weeed
I Auto 1
SYSTEM_ENABLE_DOWNLOAD_GOCB_DECRYPT | Decryption : EFUSE_SP|_BOOT_CRYPT_CNT
H T
Leen. ne:

 

 

 

Figure 23-1. Architecture of the External Memory Encryption and Decryption Module

The Manual Encryption block can encrypt instructions and data which will then be written to the external flash as
ciphertext through SPI1.

Espressif Systems 468 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
23. External Memory Encryption and Decryption

 

When the CPU writes the external RAM through cache, the Auto Encryption block automatically encrypts the
data first, and the data is written to the external RAM as ciphertext.

When the CPU reads the external flash or RAM through cache, the Auto Decryption block automatically decrypts
the ciphertext to retrieve instructions and data.

In the peripheral System Register, four bits in the
SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG register are relevant to external memory
encryption and decryption:

¢ SYSTEM_ENABLE_DOWNLOAD_MANUAL_ENCRYPT
* SYSTEM_ENABLE_ DOWNLOAD _GOCB_DECRYPT

* SYSTEM_ENABLE_ DOWNLOAD _DB_ENCRYPT

© SYSTEM_ENABLE_SPILMANUAL_ENCRYPT

The External Memory Encryption and Decryption module fetches two parameters from the peripheral eFuse
Controller. These parameters are: EFUSE_DIS_DOWNLOAD MANUAL ENCRYPT and
EFUSE_SPI_BOOT_CRYPT_CNT.

23.3.1 XTS Algorithm

The manual encryption, auto encryption, and auto decryption operations use the same algorithm, i.e., XTS
algorithm. In real-life implementation, the XTS algorithm is characterized by “data unit” of 1024 bits. The “data
unit” is defined in the XTS-AES Tweakable Block Cipher standard, section XTS-AES encryption procedure. More
information on the XTS-AES algorithm can be found in IEEE Std 1619-2007.

23.3.2 Key
The Manual Encryption block, Auto Encryption block, and Auto Decryption block share the same key to perform
XTS algorithm. The key is provided by the eFuse hardware and protected from user access.

The key can be either 256 bits or 512 bits long. The key is determined by the content in one or two eFuse blocks
from BLOCK4 ~ BLOCk®. For easy description, define:

® Block, which refers to the block that has the key purpose set to
EFUSE_KEY_PURPOSE_XTS_AES_256_KEY_1. Block, contains 256-bit Key.

® Blocks, which refers to the block that has the key purpose set to
EFUSE_KEY_PURPOSE_XTS_AES_256_KEY_2. Blockg contains 256-bit Keyp.

* Blockg, which refers to the block that has the key purpose set to
EFUSE_KEY_PURPOSE_XTS_AES_128_KEY. Blocke contains 256-bit Keyc.

Table 112 shows how the Key is generated, depending on whether Block, Blockg, and Blockge exists or

 

 

 

 

 

 

 

 

 

 

 

 

not.
Table 112: Key
Block, | Blockg Blocke Key Key Length (bit)

Yes Yes Don’t care | Keya||Keyp 512

Yes No Don't care | Keya||0?°6 512

No Yes | Don’tcare | 075°||Keyp 512

No No Yes Keyo 256
Espressif Systems 469 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
23. External Memory Encryption and Decryption

 

 

Block, | Blockg Blocke Key Key Length (bit)
No No No 256 256

 

 

 

 

 

 

 

 

“Yes” indicates that the block exists; “No” indicates that the block does not exist; “075%” indicates a bit string that
consists of 256-bit zeros; “||” is a bonding operator for joining one key string to another.

For more information on setting of key purposes, please refer to Chapter 16 eFuse Controller.

23.3.3 Target Memory Space

The target memory space refers to a continuous address space in the external memory where the encrypted
result is stored. The target memory space can be uniquely determined by three relevant parameters: type, size,
and base_addr. They are clefined as follows:

* type: the type of the external memory, either flash or external RAM. Value O indicates flash, 1 indicates
external RAM.

® size: the size of the target memory space, in unit of bytes. One single encryption operation supports either
16, 32, or 64 bytes of data.

* base_addr: the base address of the target memory space. It is a physical address aligned to size, i.e.,

base_addr%size == 0.

Assume encrypted 16 bytes written to address 0x130 ~ Ox13F in the external flash, then, the target memory
space is Ox130 ~ Ox13F, type is O (flash), size is 16 (bytes), and base_addr 0x10.

The encryption of any length (must be multiples of 16 bytes) of data can be completed separately in multiple
operations. Each operation can have individual target memory space and the relevant parameters.

For auto encryption and auto decryption, these parameters are automatically defined by hardware. For manual
encryption, these parameters should be configured manually by users.

23.3.4 Data Padding

For auto encryption and auto decryption, data padding is automatically completed by hardware. For manual
encryption, data padding should be completed manually by users. The Manual Encryption block is equipped with
16 registers, i.e., XTS_AES PLAIN_n_REG (7: 0-15), that are dedicated to data padding and can store up to 512
bits of plaintext at a time.

Actually, the Manual Encryption block does not care where the plaintext comes from, but only where the
ciphertext is to be stored. Because of the strict correspondence between plaintext and ciphertext, in order to
better describe how the plaintext is stored in the register heap, it is assumed that the plaintext is stored in the
target memory space in the first place and replaced by ciphertext after encryption. Therefore, the following
description no longer has the concept of “plaintext”, but uses “target memory space” instead. However, users
should note that the plaintext can come from anywhere, and that they should understand how the plaintext is
stored in the register heap.

How mapping works between target memory space and registers:

Assume a word is stored in address, define of fset = address%64, n = offset then the word will be stored in
register XTS_AES_PLAIN_n_REG.

For example, if the size of the target memory space is 64, then all the 16 registers will be used for data storage.
The mapping between of fset and registers is shown in Table 113.

Espressif Systems 470 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
23. External Memory Encryption and Decryption

 

Table 113: Mapping Between Offsets and Registers

 

 

 

 

 

 

 

 

 

of fset | Register of fset | Register
0x00 | XTS_AES PLAIN_O_REG 0x20 | XTS_AES PLAIN 8 REG
0x04 | XTS_AES PLAIN_1_REG 0x24 | XTS_AES PLAIN 9 REG
0x08 | XTS_AES PLAIN 2 REG 0x28 | XTS_AES PLAIN _10_REG
OxOC | XTS_AES PLAIN 3 REG Ox2C | XTS_AES_ PLAIN_11_REG
Ox10 | XTS_AES PLAIN 4 REG 0x30 | XTS_AES PLAIN 12 REG
Ox14 | XTS_AES PLAIN_5 REG 0x34 | XTS_AES PLAIN 13 REG
0x18 | XTS_AES PLAIN 6 REG 0x38 | XTS_AES PLAIN 14 REG
Ox1C | XTS_AES PLAIN_7_ REG Ox3C | XTS_AES PLAIN_15 REG

 

 

 

 

 

 

23.3.5 Manual Encryption Block

The Manual Encryption block is a peripheral module. It is equipped with registers that can be accessed by the
CPU directly. Registers embedded in this block, System registers, eFuse parameters, and boot mode jointly
configure and control this block. Please note that currently the Manual Encryption block can only encrypt
flash.

The manual encryption requires software participation. The steps are as follows:
1. Configure XTS_AES:
® Set XTS_AES DESTINATION_REG register to type = 0.
® Set XTS_AES_ PHYSICAL_ADDRESS_REG register to base_addr.
® Set XTS_AES LINESIZE REG register to size |
For definitions of type, base_addr, size, please refer to Section 23.3.3.

2. Fill registers XTS_AES_ PLAIN_n_REG (7: 0-15) in with plaintext (refer to Section 23.3.4). Registers that are
not used can be written into any value.

3. Poll XTS_AES STATE_REG until it reads 0 that indicates the Manual Encryption block is icle.
4. Activate encryption by writing 1 to XTS_AES_ TRIGGER_REG register.

5. Wait for the encryption to complete. Poll register XTS_AES_ STATE_REG until it reads 2.
Steps 1 ~ 5 complete the encryption operation, where Key is used.

6. Grant SPI1 access to the encrypted result by writing 1 to XTS_AES_ RELEASE_REG register.
XTS_AES_STATE_REG will read 3 afterwards.

7. Call SPI1 and write the encrypted result to the external flash.

8. Destroy the encrypted result by writing 1 to XTS_AES DESTROY_REG. XTS_AES_STATE_REG register will
read O afterwards.

Repeat the steps above to complete multiple encryption operations.

The Manual Encryption block is operational only with granted permission. The operating conditions
are:

® In SPI Boot mode
If bit SYSTEM_ENABLE_SPILMANUAL_ ENCRYPT in register

Espressif Systems 471 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
23. External Memory Encryption and Decryption

 

SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG is 1, the Manual Encryption block
is granted permission. Otherwise, it is not operational.

* In Download Boot mode
If bit SYSTEM ENABLE _DOWNLOAD_MANUAL_ ENCRYPT in register
SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG is 1 and the eFuse parameter
EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT is 0, the Manual Encryption block is granted permission.
Otherwise, it is not operational.

 

Note:

e Even though the CPU can skip cache and get the encrypted result directly by reading the external memory, software
can by no means access Key.

e The Manual Encryption block needs to call the AES accelerator to perform encryption. Therefore, users cannot

 

 

access AES accelerator during the process.

 

23.3.6 Auto Encryption Block

The Auto Encryption block is not a conventional peripheral, and is not equipped with registers. Therefore, the
CPU cannot directly access this block. The System Register, eFuse parameters, and boot mode jointly control
this block.

The Auto Encryption block is operational only with granted permission. The operating conditions are:

® In SPI Boot mode
If the 83-bit parameter SPILBOOT_CRYPT_CNT has 1 or 3 bits set to 1, then the Auto Encryption block is
granted permission. Otherwise, it is not operational.

* In Download Boot mode
If bit SYSTEM _ENABLE_DOWNLOAD_DB_ENCRYPT in register
SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG is 1, the Auto Encryption block is
granted permission. Otherwise, it is not operational.

 

Note:

¢ When the Auto Encryption block is operational, the CPU will read data from the external RAM via the cache. The
Auto Encryption block automatically encrypts the data and write it to the external RAM. The entire encryption pro-
cess does not need software participation and is transparent to the cache. Software cannot access the encryption
Key.

e When the Auto Encryption block is not operational, it will ignore the CPU’s request to access cache and do not
process the data. Therefore, data will be written to the external RAM as plaintext.

 

 

 

23.3.7 Auto Decryption Block

The Auto Decryption block is not a conventional peripheral, and is not equipped with registers. Therefore, the
CPU cannot directly access this block. The System Register, eFuse parameters, and boot mode jointly control
and configure this block.

The Auto Decryption block is operational only with granted permission. The operating conditions are:

® In SPI Boot mode

Espressif Systems 472 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
23. External Memory Encryption and Decryption

 

If the 83-bit parameter SPILBBOOT_CRYPT_CNT has 1 or 3 bits set to 1, then the Auto Decryption block is
granted permission. Otherwise, it is not operational.

* In Download Boot mode
If bit SYSTEM_ENABLE_ DOWNLOAD _GOCB_DECRYPT in register
SYSTEM_EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL_REG is 1, the Auto Decryption block is
granted permission. Otherwise, it is not operational.

 

Note:

e When the Auto Decryption block is operational, the CPU will read instructions and data from the external memory
via cache. The Auto Decryption block automatically decrypts and retrieves the instructions and data. The entire
decryption process does not need software participation and is transparent to the cache. Software cannot access
the decryption Key.

e When the Auto Decryption block is not operational, it does not have any effect on the contents stored in the external
memory, be they encrypted or unencrypted. What the CPU reads via cache is the original information stored in the

 

 

external memory.

 

23.4 Base Address

Users can access the Manual Encryption block with two base addresses, which can be seen in the following
table. For more information about accessing peripherals from different buses please see Chapter 1 System and
Memory.

Table 114: Manual Encryption Block Base Address

 

 

 

Bus to Access Peripheral | Base Address
PeriBUS1 OxSF43A000
PeriBUS2 Ox6003A000

 

 

 

 

23.5 Register Summary
The addresses in the following table are relative to the Manual Encryption block’s base addresses provided in
Section 28.4,

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access
Plaintext Register Heap

XTS_AES_PLAIN_O_REG Plaintext register O Ox0100 | RAV
XTS_AES_PLAIN_1_REG Plaintext register 1 O0x0104 | RAV
XTS_AES_PLAIN_2_REG Plaintext register 2 O0x0108 | RAV
XTS_AES_PLAIN_3 REG Plaintext register 3 Ox010C | RAV
XTS_AES_PLAIN_4_REG Plaintext register 4 0x0110 | RAV
XTS_AES_PLAIN_5 REG Plaintext register 5 0x0114 | RAV
XTS_AES_PLAIN_6_REG Plaintext register 6 0x0118 | RAV
XTS_AES_PLAIN_7_REG Plaintext register 7 Ox011C | RAV
XTS_AES_PLAIN_8 REG Plaintext register 8 0x0120 | RAV
XTS_AES_PLAIN_9_ REG Plaintext register 9 0x0124 | RAV
XTS_AES_PLAIN_10_REG Plaintext register 10 0x0128 | RAV

 

 

 

 

Espressif Systems

Submit Documentation Feedback

473

ESP32-S2 TRM (Preliminary V0.4)

 
23. External Memory Encryption and Decryption

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
XTS_AES_PLAIN_11_REG Plaintext register 11 O0x012C | RAV
XTS_AES_PLAIN_12_REG Plaintext register 12 0x0130 | RAV
XTS_AES_PLAIN_138 REG Plaintext register 13 0x0134 | RAV
XTS_AES_PLAIN_14_REG Plaintext register 14 0x0138 | RAV
XTS_AES_PLAIN_15_REG Plaintext register 15 Ox013C | RAV
Configuration Registers
XTS_AES_LINESIZE_REG Configures the size of target memory space 0x0140 | RAV
XTS_AES_DESTINATION_REG Configures the type of the external memory 0x0144 | RAV
XTS_AES_PHYSICAL_ADDRESS_REG | Physical address 0x0148 | RAV
Control/Status Registers
XTS_AES_TRIGGER_REG Activates AES algorithm Ox014C | WO
XTS_AES_RELEASE_REG Release control O0x0150 | WO
XTS_AES_DESTROY_REG Destroys control 0x0154 | WO
XTS_AES_STATE_REG Status register 0x0158 | RO
Version Register
XTS_AES_DATE_REG Version control register Ox015C | RO
23.6 Registers
Register 23.1: XTS_AES PLAIN_»_REG (7: 0-15) (0x0100+4*/)
ys
Ov
&
er
& if
[1
| 0x000000 | Reset
XTS_AES REG_PLAIN_) This register stores nth 32-bit piece of plaintext. (RAV)
Register 23.2: XTS_AES LINESIZE REG (0x0140)
&
a
»
Or
S o>
&
ES &

 

 

 

 

XTS_AES REG_LINESIZE Configures the data size of a single encryption. 0: 128 bits; 1: 256 bits;

2: 512 bits. (RAW)

Espressif Systems

474

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
23. External Memory Encryption and Decryption

 

Register 23.3: XTS_AES DESTINATION_REG (0x01 44)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Se
wr
Ss
a
Or
S o>
&
EF &
[a1 1 0 |
joo 0000000900000 0000000 00 00 00 0 0 0 0] 0 Reset
XTS_AES REG_DESTINATION Configures the type of the external memory. Currently, it must be
set to 0, as the Manual Encryption block only supports flash encryption. Errors may occur if users
write 1. 0: flash; 1: external RAM. (R/W)
Register 23.4: XTS_AES PHYSICAL_ADDRESS_REG (0x01 48)
S
S
SY
Ss
ey
&
x
or
S oF
i
ES we
31 30 | 29 0
0 0 0x000000 Reset
XTS_AES REG_PHYSICAL_ ADDRESS Physical address. (RAW)
Register 23.5: XTS_AES TRIGGER_REG (0x014C)
S&F
&
Or
& eg
gs oy
& £
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
XTS_AES REG_TRIGGER Set to enable manual encryption. (WO)
Espressif Systems 475 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
23. External Memory Encryption and Decryption

Register 23.6: XTS_AES RELEASE_REG (0x0150)

 

 

 

 

 

 

 

 

 

 

x
S
Se
or
S o>
&
ES &
[1 | 0 |
jo0 0000090090000 09 09009 009 00 09 00 0 0 0 0] 0 Reset
XTS_AES REG_RELEASE Set to grant SPI1 access to encrypted result. (WO)
Register 23.7: XTS_AES DESTROY_REG (0x0154)
oh
x
oo
¢
> S
of
ES ee
31 1 oO
0000000 0000000000000 00 0 0 0 0 0 0 0 0 OO IReset
XTS_AES REG _DESTROY Set to destroy encrypted result. (WO)
Register 23.8: XTS_AES STATE_REG (0x0158)
a
gr
S s
& ee

 

XTS_AES REG_STATE Indicates the status of the Manual Encryption block. (RO)
* Ox0 (XTS_AES_IDLE): idle;
* Ox1 XTS_AES BUSY): busy with encryption;

© Ox2 (XTS_AES DONE): encryption is completed, but the encrypted result is not accessible to
SPI;

* Ox3 XTS_AES RELEASE): encrypted result is accessible to SPI.

Espressif Systems 476 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
23. External Memory Encryption and Decryption

 

Register 23.9: XTS_AES_ DATE_REG (0x015C)

 

 

 

 

s&
or
& oF

ES ee
| 31 30 | 29 0 |
[o 0] 0x20190514 |Reset

XTS_AES REG_DATE Version control register. (RO)

Espressif Systems 477 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

24. Permission Control

24.1 Overview

In ESP32-S2, different type of buses and modules can have different permissions to access the memory. The
permission control module is used to manage all the access permissions through corresponding permission
control registers.

24.2 Features

* Permission controls for the CPU buses to access the internal memory
— SRAM partially adopts unified permission control and partially adopts split permission control.
— RTC FAST SRAM adopts split permission control.
— RTC SLOW SRAM adopts split permission control.

* Access to the external memory is managed by both the memory management unit (MMU) and the
permission control module.

24.3 Functional Description

24.3.1 Internal Memory Permission Controls
The internal memory resources in ESP32-S2 include ROM, SRAM, RTC FAST Memory, and RTC SLOW Memory.
The breakdown of each memory is as follows:

° The total ROM size is 128 KB and consists of two 64 KB blocks.

® The total SRAM size is 320 KB and consists of four 8 KB blocks and eighteen 16 KB blocks, numbered
Block 0 ~ 21. The offset address range of each block is shown in Table 116. For the base addresses
accessed by different buses please refer to Section 24.3.1.1, 24.3.1.2, and 24.3.1.3. Each of the four 8 KB
blocks (Block 0 ~ 3) is equipped with an independent permission control register. The eighteen 16 KB
blocks (Block 4 ~ 21) are regarded as a large storage space as a whole, which is managed in split parts
(i.e., the storage space is split into high and low areas with separate permission controls). The split address
cannot fall within the address range of Block 4 ~ 5,

RTC FAST Memory acopts split permission control. The high and low areas have independent permission
control registers.

* RTC SLOW Memory also adopts split permission control. The high and low areas have independent
permission control registers.

The following sections describe the buses and modules in ESP382-S2 that can access the above-mentioned
internal memory resources.

Table 116: Offset Address Range of Each SRAM Block

 

 

 

 

 

 

 

 

 

SRAM Block Offset Start Address | Offset End Address
Block 0 Ox0000 Ox1 FFF
Block 1 0x2000 Ox3FFF
Block 2 0x4000 Ox5FFF
Espressif Systems 478 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

SRAM Block Offset Start Address | Offset End Address
Block 3 Ox6000 Ox7FFF
Block 4 0x8000 OxBFFF
Block 5 OxC000 OxFFFF
Block 6 0x10000 0x1 3FFF
Block 7 0x14000 0x1 7FFF
Block 8 0x18000 0x1 BFFF
Block 9 0x1C000 Ox1 FFFF
Block 10 0x20000 Ox23FFF
Block 11 0x24000 Ox27FFF
Block 12 Ox28000 Ox2BFFF
Block 13 Ox2C000 Ox2FFFF
Block 14 O0x30000 Ox33FFF
Block 15 0x34000 Ox37FFF
Block 16 0x38000 Ox3BFFF
Block 17 Ox38C000 Ox3FFFF
Block 18 0x40000 Ox43FFF
Block 19 0x44000 Ox47FFF
Block 20 0x48000 Ox4BFFF
Block 21 Ox4C000 Ox4FFFF

 

 

 

 

 

24.3.1.1. Permission Control for the Instruction Bus (IBUS)

The address range on IBUS that requires permission control is Ox4002_0000 ~ 0x4007_1FFF, where SRAM
memory blocks and RTC FAST Memory are located. Access to different memory blocks is controlled by
independent permission control registers which are configured by software.

The permission control registers related to IBUS are also controlled by the PMS_PRO_IRAMO_LOCK signal.
When this signal is set to 1, the values configured in the permission control registers will be locked and cannot be
changed. At the same time, the value of the PMS_PRO_IRAMO_LOCK signal will also remain at 1 and cannot be
changed. The value of the PMS_PRO_IRAMO_LOCK signal is reset to 0 only when the CPU is reset.

SRAM Memory Blocks

Through IBUS, the CPU can Read (data) from SRAM, Write (data) to SRAM, and eXecute (an instruction),
indicated as RAWV/X, respectively. The base address of SRAM accessed by the CPU is 0x4002_0000. Software
can configure valid access types to each SRAM block in advance. The configuration of the permission control
registers is shown in Table 117.

Table 117: Permission Control for IBUS to Access SRAM

 

 

 

Register Bit Positions | Description
PMS_PRO_IRAMO_1_REG [11:9] Configure the permission for IBUS to access SRAM Block 3
(from high to low as W/R/X)
[8:6] Configure the permission for IBUS to access SRAM Block 2
(from high to low as W/R/X)

 

 

 

 

 

Espressif Systems 479 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

 

 

 

 

 

 

Register Bit Positions | Description
[5:3] Configure the permission for IBUS to access SRAM Block 1
(from high to low as W/R/X)
[2:0] Configure the permission for IBUS to access SRAM Block O
(from high to low as W/R/X)
PMS_PRO_IRAMO_2_ REG [22:20] Configure the permission for IBUS to access the high address
range in SRAM Block 4 ~ 21 (from high to low as W/R/X)
[19:17] Configure the permission for IBUS to access the low address
range in SRAM Block 4 ~ 21 (from high to low as W/R/X)
[16:0] Configure the split address of IBUS in the SRAM Block 4 ~ 21
address range. The base address is Ox4000_0000. See below
for instructions on how to configure split address.

 

 

 

 

 

Note:
Configuring split address:

Split address is 32 bits in width and equal to base address plus the configured field value multiplied by 4. For example,
if Ox10000 is written to PMS_PRO_IRAMO_2_REG [16:0], the split address of IBUS in the SRAM Block 4 ~ 21 address
range is equal to 0x4004_0000. Note that the split address on IBUS and DBUSO cannot fall within the address range of
Block 0 ~ 5.

 

 

 

If the type of access initiated by the CPU to SRAM through IBUS does not match the configured access type, the
permission control module will directly deny this access. For example, if software allows the IBUS bus to only
read and write SRAM Block5, but the CPU initiates an instruction fetch, the permission control module will deny
this fetch access.

An access denial does not block the access initiated by the CPU, which means:
* The write operation will not take effect and will not change the data in the memory block.
* Read and fetch operations will get invalid data.

If the interrupt that indicates an illegitimate access to SRAM via IBUS is enabled, the permission control module
will record the current access address and access type, and give an interrupt signal at the same time. If the
access is denied repeatedly, the hardware only records the first error message. The access error interrupt is a
level signal and needs to be cleared by software. When the interrupt is cleared, the related error record is also
cleared at the same time.

RTC FAST Memory

The CPU can perform R/W/X access to the RTC FAST Memory through IBUS. As RTC FAST Memory adopts
split permission control, software needs to configure access permissions for the high and low address ranges,
respectively. The configuration of the permission control registers is shown in Table 118.

Table 118: Permission Control for IBUS to Access RTC FAST Memory

 

Register Bit Positions | Description

 

PMS_PRO_IRAMO_3_ REG [16:14] Configure the permission for IBUS to access the high address
range in RTC FAST Memory (from high to low as W/R/X)

 

 

 

 

 

Espressif Systems 480 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

 

 

 

Register Bit Positions | Description
[13:11] Configure the permission for IBUS to access the low address
range in RTC FAST Memory (from high to low as W/R/X)
[10:0] Configure the user-configurable split address of IBUS in the RTC

FAST address range. The base address is 0x4007_0000. For
how to configure the user-configurable split address, please re-
fer to the instructions above.

 

 

 

 

 

If the type of access initiated by the CPU to RTC Fast Memory through IBUS does not match the configured
access type, the permission control module will directly deny this access. If the interrupt that indicates an
illegitimate access to the RTC Fast Memory via IBUS is enabled, the permission control module will record the
current access address and access type, and give an interrupt signal at the same time. If the access is denied
repeatedly, the hardware only records the first error message. The access error interrupt is a level signal and
needs to be cleared by software. When the interrupt is cleared, the related error record is also cleared at the
same time.

24.3.1.2 Permission Control for the Data Bus (DBUSO)

The CPU can access two address ranges through DBUSO: Ox8FFB_O000 ~ Ox3FFF_FFFF and Ox8FF9_E000 ~
Ox3FF9_FFFF, where SRAM memory blocks and RTC FAST Memory are located. Access to different memory
blocks is controlled by independent permission control registers which are configured by software.

The permission control registers related to DBUSO are also controlled by the PMS_PRO_DRAMO_LOCK signal.
When this signal is set to 1, the configured values of the permission control registers will be locked and cannot be
changed. The value of the PMS_PRO_DRAMO_LOCK signal will also remain at 1 and cannot be changed. The
value of the PMS_PRO_DRAMO0_LOCK signal is reset to O only when the CPU is reset.

SRAM Memory Blocks

The CPU can perform R/W access to SRAM via DBUSO, with the based address OxSFFB_O000. Software can
configure allowed access types initiated by DBUSO to each SRAM block in advance. The configuration of the
permission control registers is shown in Table 119.

Table 119: Permission Control for DBUSO to Access SRAM

 

 

 

 

Register Bit Positions | Description
PMS_PRO_DRAMO_1_REG [28:27] Configure the permission for DBUSO to access the high address
range in SRAM Block 4 ~ 21 (from high to low as W/R)
[26:25] Configure the permission for DBUSO to access the low address
range in SRAM Block 4 ~ 21 (from high to low as W/R)
[24:8] Configure the user-configurable split address of DBUSO in the

SRAM Block 4 ~ 21 address range. The base address is
Ox8FFB_O0000. For how to configure the user-configurable split
address, please refer to the instructions in Section 24.3.1.1.

 

 

[7:6] Configure the permission for DBUSO to access SRAM Block3
(from high to low as W/R)
[5:4] Configure the permission for DBUSO to access SRAM Block2

 

 

(from high to low as W/R)

 

Espressif Systems 481 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback

 
24. Permission Control

 

 

 

 

 

 

 

Register Bit Positions | Description
[3:2] Configure the permission for DBUSO to access SRAM Block1
(from high to low as W/R)
[1:0] Configure the permission for DBUSO to access SRAM BlockO
(from high to low as W/R)

 

 

If the type of access initiated by the CPU to SRAM through DBUSO does not match the configured access type,
the permission control module will directly deny this access. If the interrupt that indicates an illegitimate access to
SRAM via DBUS0 is enabled, the permission control module will record the current access address, access type,
and access size (in bytes, halfwords, or words), and give an interrupt signal at the same time. If the access is
denied repeatedly, the hardware only records the first error message. The access error interrupt is a level signal
and needs to be cleared by software. When the interrupt is cleared, the related error record is also cleared at the
same time.

RTC FAST Memory

The CPU can perform R/W access to RTC FAST Memory through DBUSO. As RTC FAST Memory adopts split
permission control, software needs to configure access permissions for the high and low address ranges,
respectively. The configuration of the permission control registers is shown in Table 120.

Table 120: Permission Control for DBUSO to Access RTC FAST Memory

 

 

 

 

Register Bit Positions | Description
[14:13] Configure the permission for DBUSO to access the high address
‘ range in RTC FAST Memory (from high to low as W/R)
12:11] Configure the permission for DBUSO to access the low address
range in RTC FAST Memory (from high to low as W/R)
PMS_PRO_DRAMO_2_ REG - ; ; a
Configure the user-configurable split address of DBUSO within
[10:0] the RTC FAST Memory address range. The base address is

Ox8FF9_E000. For how to configure the user-configurable split
address, please refer to the instructions in Section 24.3.1.1.

 

 

 

 

 

If the type of access initiated by the CPU to RTC FAST Memory through DBUSO does not match the configured
access type, the permission control module will directly deny this access. If the interrupt that indicates an
illegitimate access to RTC FAST Memory via DBUSO is enabled, the permission control module will record the
current access acidress, access type, and access size (in bytes, halfwords, or words), and give an interrupt signal
at the same time. If the access is denied repeatedly, the hardware only records the first error message. The
access error interrupt is a level signal and needs to be cleared by software. When the interrupt is cleared, the
related error record is also cleared at the same time.

24.3.1.3 Permission Control for On-chip DMA

The on-chip DMA can access the internal memory through Internal DMA, Copy DMA Rx (receiving) channel, or
Copy DMA TX (transmitting) channel, using the address range Ox3FFB_0000 ~ OxSFFF_FFFF (Ox3FFB_0000 is
the base address). Software can configure the type of DMA access to each SRAM block in advance. The
configuration of the permission control registers is shown in Table 121, where can be APB, TX, or RX,

Espressif Systems 482 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

corresponding to the configuration registers of Internal DMA, TX Copy DMA, and RX Copy DMA, respectively.
More details about DMA can be found in Chapter 7 DMA Controller.

The permission control registers related to DMA are also controlled by the PMS_DMA_Xx_I_LOCK signal. When
this signal is set to 1, the configured values of the permission control registers will be locked and cannot be
changed. The value of the PMS_DMA_Xx_|_LOCK signal will also remain at 1 and cannot be changed. The
PMS_DMA_XX_|_ LOCK signal value is reset to 0 only when the CPU is reset.

Table 121: Permission Control for On-chip DMA to Access SRAM

 

 

 

 

 

 

 

 

 

Register Bit Positions | Description
(28:27) Configure the permission for DMA to access the high address
range in SRAM Block 4 ~ 21 (from high to low as W/R)
(26:25) Configure the permission for DMA to access the low address
range in SRAM Block 4 ~ 21 (from high to low as W/R)
Configure the user-configurable split address of DMA in SRAM
24:8] Block 4~ 21 address range. The base address is Ox3FFB_O000.
For how to configure the user-configurable split address, please
PMS_DMA.<11_REG refer to the instructions in Section 24.3.1.1.
(7:6) Configure the permission for DMA to access SRAM Blocks (from
high to low as W/R)
[5:4] Configure the permission for DMA to access SRAM Block2 (from
high to low as W/R)
[3:2] Configure the permission for DMA to access SRAM Block1 (from
high to low as W/R)
[1:0] Configure the permission for DMA to access SRAM Block0 (from
high to low as W/R)

 

 

 

 

lf the type of access initiated by the on-chip DMA to SRAM does not match the configured access type, the
permission control module will directly deny this access. If the interrupt that indicates an illegitimate access to
SRAM via Internal DMA, TX Copy DMA, or RX Copy DMA is enabled, the permission control module will record
the current access acdidress and access type, and give an interrupt signal at the same time. If the access is
denied repeatedly, the hardware only records the first error message. The access error interrupt is a level signal
and needs to be cleared by software. When the interrupt is cleared, the related error record is also cleared at the
same time.

24.3.1.4 Permission Control for PeriBus1

The CPU can access the address range Ox8F40_0000 ~ OxGF4F_FFFF through PeriBus1, where RTC SLOW
SRAM is located. PeriBus1 can perform R/W operations. The read/write permission is controlled by
software.

Software can also configure whether PeriBus1 is allowed to access peripherals that are within the address range
Ox3F40_0000 ~ OxSF4B_FFFF.

As the CPU can initiate predictive read operations through PeriBus1, it may cause peripheral FIFO read errors. To
avoid FIFO read errors, the FIFO addresses of the corresponding peripherals have already been written in
hardware and can no longer be changed, as Table 122 shows. In addition, four software-configurable address

Espressif Systems 483 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

registers PMS_PRO_DPORT_2 ~ 5_REG are reserved for users to write into addresses read-protected from

PeriBus1 reading. The configuration of the permission control registers is shown in Table 123.

Table 122: Peripherals and FIFO Address

 

Peripherals

FIFO Address

 

ADDR_RTCSLOW

Ox6002_1000

 

ADDR_FIFO_UARTO

Ox6000_0000

 

ADDR_FIFO_UART1

0x6001_0000

 

ADDR_FIFO_UART2

Ox6002_E000

 

ADDR_FIFO_|2S0

Ox6000_FO04

 

ADDR_FIFO_|2S1

O0x6002_D004

 

ADDR_FIFO_RMT_CHO

0x6001_6000

 

ADDR_FIFO_RMT_CH1

O0x6001_6004

 

ADDR_FIFO_RMT_CH2

0x6001_6008

 

ADDR_FIFO_RMT_CH3

0x6001_600C

 

ADDR_FIFO_|l2C_EXTO

0x6001_301C

 

ADDR_FIFO_|l2C_EXT1

0x6002_701C

 

ADDR_FIFO_USB_0

0x6008_0020

 

ADDR_FIFO_USB_1_L

0x6008_1000

 

 

ADDR_FIFO_USB_1_H

 

 

O0x6009_OFFF

 

The permission control registers related to PeriBus1 are also controlled by the PMS_PRO_DPORT_LOCK signal.

When this signal is set to 1, the configured values of the permission registers will be locked and cannot be
changed. The value of the PMS_PRO_DPORT_LOCK signal will also remain at 1 and cannot be changed. The
value of the PMS_PRO_DPORT_LOCK signal is reset to 0 only when the CPU is reset.

Table 123: Permission Control for PeriBus1

 

Register

Bit Positions

Description

 

PMS_PRO_DPORT_1_REG

[19:16]

The value of each bit determines whether to enable the corre-
sponding reserved FIFO address.

 

[15:14]

Configure the permission for PeriBus1 to access the high ad-
dress range in RTC SLOW Memory (from high to low as W/R)

 

[13:12]

Configure the permission for PeriBus1 to access the low address
range in RTC SLOW Memory (from high to low as W/R)

 

[14:4]

Configure the user-configurable split address of PeriBus1 in
the RTC SLOW Memory address range. The base address is
Ox8F42_1000. For how to configure the user-configurable split
address, please refer to the instructions in Section 24.3.1.1.

 

Configure whether PeriBus1 can access the peripherals within
the address range Ox3F40_0000 ~ Ox8F4B_FFFF

 

PMS_PRO_DPORT_2_REG

[17:0]

The zeroth address unreadable to PeriBus1,
PMS_PRO_DPORT_RESERVE_FIFO_VALID [16]

enabled by

 

PMS_PRO_DPORT_3_REG

 

[17:0]

 

 

The first address unreadable to PeriBus1,
PMS_PRO_DPORT_RESERVE_FIFO_VALID [17]

enabled by

 

Espressif Systems

484 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
24. Permission Control

 

 

 

 

 

 

 

Register Bit Positions | Description

PMS_PRO_DPORT_4_ REG [17:0] The second address unreadable to PeriBus1, enabled by
PMS_PRO_DPORT_RESERVE_FIFO_VALID [18]

PMS_PRO_DPORT_5 REG [17:0] The third address unreadable to PeriBus1, enabled by

PMS_PRO_DPORT_RESERVE_FIFO_VALID [19]

 

lf PeriBus1 initiates a read access to unreadable address, or if the type of the access to RTC SLOW Memory

does not match the configured type, the permission control module will directly deny this access. If the interrupt
that indicates an illegitimate access to RTC SLOW Memory by PeriBus1 is enabled, the permission control
module will record the current access address, access type, and access size (in bytes, halfwords, or words), and

give an interrupt signal at the same time. If the access is denied repeatedly, the hardware only records the first

error message. The access error interrupt is a level signal and needs to be cleared by software. When the

interrupt is cleared, the related error record is also cleared at the same time.

24.3.1.5 Permission Control for PeriBus2

The two address ranges on PeriBus2 that require permission control are Ox5000_0000 ~ Ox5000_1FFF and
Ox6000_0000 ~ Ox600B_FFFF where RTC SLOW Memory and peripheral modules are located.

PeriBus2 supports RAW/X access to RTC SLOW Memory through two address ranges, namely RTCSlow_O and
RTCSlow_1. Software can configure the allowed access types. The configuration of the permission control

registers is shown in Table 124.

PeriBus2 does not support fetch operations on peripherals. If a fetch operation is initiated on a peripheral, invalid

data will be obtained.

The permission control registers related to PeriBus2 are also controlled by the PMS_PRO_AHB_LOCK signal.

When this signal is configured to 1, the values of the permission control registers are locked and cannot be

changed. The value of the PMS_PRO_AHB_LOCK signal will also remain at 1 and cannot be changed. The value
of the PMS_PRO_AHB_LOCK signal is reset to 0 only when the CPU is reset.

Table 124: Permission Control for PeriBus2 to Access RTC SLOW Memory

 

 

 

 

 

 

Espressif Systems

 

 

 

Register Bit Positions | Description
PMS_PRO_AHB_1_REG [16:14] Configure the permission for PeriBus2 to access the high ad-
dress range in RTCSlow_0 (from high to low as W/R/X)
[13:11] Configure the permission for PeriBus2 to access the low address
range in RTCSlow_0 (from high to low as W/R/X)
[10:0] Configure the user-configurable split address of PeriBus2 in the
RTCSlow_0O address range. The base acidress is Ox5000_1000.
For how to configure the user-configurable split address, please
refer to the instructions in Section 24.3.1.1.
PMS_PRO_AHB_2_ REG [16:14] Configure the permission for PeriBus2 to access the high ad-
dress range in RTCSlow_1 (from high to low as W/R/X)
[13:11] Configure the permission for PeriBus2 to access the low address

range in RTCSlow_1 (from high to low as W/R/X)

 

485 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 

 
24. Permission Control

 

 

Register Bit Positions | Description

 

[10:0] Configure the user-configurable split address of PeriBus2 in the
RTCSlow_1 address range. The base acidress is Ox6002_ 1000.
For how to configure the user-configurable split address, please

 

 

 

refer to the instructions in Section 24.3.1.1.

 

 

If the type of the access to RTCSlow_0O or RTCSlow_1 mace by the CPU through PeriBus2 does not match the
configured type, the permission control module will directly deny this access. If the interrupt that indicates an
illegitimate access by PeriBus2 is enabled, the permission control module will record the current access address
and access type, and give an interrupt signal at the same time. If the access is denied repeatedly, the hardware
only records the first error message. The access error interrupt is a level signal and needs to be cleared by
software. When the interrupt is cleared, the related error record is also cleared at the same time.

24.3.1.6 Permission Control for Cache

Among the SRAM blocks, only Block 0 ~ 3 can be assigned to Icache and Dcache. Icache or Dcache can
access up to 16 KB internal memory, which means, they can access up to two blocks. The 16 KB address range
accessed by Icache or Dceache is divided into two ranges: high address range (indicated by “_H” and low
address range (indicated by “_L”).

The user can allocate Block 0 ~ 3 to Icache_H, Icache_L, Dcache_H, or Deache_L by configuring the field
PMS_PRO_CACHE_CONNECT in register PMS_PRO_CACHE_1_REG. The detailed configuration is shown in
Table 125, where FIELD indicates field PMS_PRO_CACHE_CONNECT.

Table 125: Configuration of Register PMS_PRO_CACHE 1 REG

 

 

 

 

 

 

 

 

 

 

SRAM Block 0-3 Dcache_H | Dcache_L | Icache_H | Icache_L
Block 0 AIELD[3] AIELD[2] AIELD[A] AIELD[O]
Block 1 AIELDI7] AIELD[6] FAIELDIB) AIELD[A]
Block 2 AIELD[11] | AELD[AO] | FIELD[9] AIELD[8]
Block 3 AELD[15) | AELD[14] | AELD[1S) | AELD[A12]

 

 

Notes:

* One block can be assigned to only one of Dcache_H, Deache_L, Icache_H, and Icache_L, which means
that one bit at most can be set to 1 in the same row in Table 125.

* One of Dcache_H, Dceache_L, Icache_H, and Icache_L can occupy only one block, which means that one
bit at most can be set to 1 in the same column in Table 125.

* SRAM memory occupied by the cache cannot be accessed by the CPU. Non-occupied SRAM memory
can still be accessed by the CPU.

24.3.1.7 Permission Control of Other Types of Internal Memory

In ESP32-S2, software can read Trace memory to get information about the runtime status of the CPU.
Additionally, it can also be used as a debug channel to communicate with software running on the CPU. Software
can enable the Trace memory function by configuring register PMS_PRO_TRACE_1. This register is also
controlled by the PMS_PRO_TRACE_LOCK signal. When this signal is set to 1, the value configured in the

Espressif Systems 486 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

register will be locked and cannot be changed. At the same time, the value of the PMS_PRO_TRACE_LOCK
signal will also remain at 1 and cannot be changed. The value of the PMS_PRO_TRACE_LOCK signal is reset to
0 only when the CPU is reset.

After the Trace memory function is enabled, register PMS_OCCUPY_3 needs to be configured to select one
block from SRAM Block 4 ~ 21 as Trace memory. Only one block can be used as Trace memory, in which case, it
can no longer be accessed by the CPU. Register PMS_OCCUPY_3 is controlled by the PMS_OCCUPY_LOCK
signal. When this signal is configured as 1, the value configured in the register will be locked and cannot be
changed. At the same time, the value of the PMS_OCCUPY_LOCK signal will also remain at 1 and cannot be
changed. The PMS_OCCUPY_LOCK signal value is reset to 0 the CPU is reset.

When an SRAM block is selected as Trace Memory, neither IBUS, DBUS, nor DMA can access this block.

24.3.2 External Memory Permission Control
The CPU can access the external flash and SRAM by SPI1, EDMA or cache. The former two support direct
access, and the cache supports indirect access.

24.3.2.1 Cache MMU

The Cache MMU is used to control the permission for cache and EDMA to access the external memory. Its
primary function is to convert virtual addresses to physical addresses. The MMU needs to be configured before
enabling cache and EDMA. When a cache miss occurs or the data is written back to the external memory, the
cache controller will automatically access the MMU and generate a physical address to access the external
memory. When EDMA reads and writes the external SRAM, the EDMA controller also automatically accesses the
MMU and generates a physical address to access the external SRAM.

Table 126: MMU Entries

 

MMU Entries Bit Positions | Description

 

The external memory attribute indicates whether cache/EDMA ac-
cesses the external flash or SRAM. If bit 15 is set, cache/EDMA

 

 

 

SRAM [16] | ;
accesses flash. If bit 16 is set, cache/EDMA accesses SRAM. The
two bits cannot be set at the same time.

Flash [15]

Invalid [14] Cleared if MMU entry is valid.

Page number [13:0] For MMU purposes, external memory is divided in memory blocks

called ‘pages’. The page size is fixed at 64 KB. The page number
of the physical address space indicates which page is accessed by
cache/EDMA.

 

 

 

 

 

When cache or EDMA accesses an invalid MMU page or the external memory attribute is not specified in the
MMU, an MMU error interrupt will be triggered.

24.3.2.2 External Memory Permission Controls

The hardware divides the physical address of the external memory (flash + SRAM) into eight (4 + 4) areas. Each
area can be individually configured for W/R/X access. Software needs to configure the size of each area and its
access type in advance.

Espressif Systems 487 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

The eight areas correspond to eight sets of registers, and the flash and SRAM each has four sets. Each set of
registers contains three parts as follows:

1. Attribute list: APB_CTRL_X_ACS_n_ATTR_REG has 8 bits in total, which are W/R/X bits from high to low;
2. Area start address: APB_CTRL_X_ACS_n_ADDR_REG, which represents the physical address;
3. Area length: APB_CTRL_X_ACS_n_SIZE_REG in multiples of 64 KB;

Wherein “X” represents flash or SRAM, “n” represents 0 ~ 3. Note that the total size of the four areas
corresponding to flash must be 1 GB, so is the total size of the four areas corresponding to SRAM.

When the CPU directly accesses external memory, the permission control module only monitors the CPU’s write
requests, not the read requests. The control module checks whether the access type matches the configured
type according to the accessed physical address. If the area does not allow write access, the permission module
directly rejects write access, records the information about the current access, and triggers an access error
interrupt.

Cache miss, cache write back, and cache prefetch operations will trigger W/R/X requests from the cache to the
external memory. The permission control module will query for the access attributes of the area according to the
accessed physical address, and compare the the cache request against the pre-configured attributes. Only
when the two match, the permission control module will pass the request to the external memory. If the cache
initiates an R/F request, the permission control module will send the access attributes of the area to the cache for
storage. When the access request is inconsistent with the current access attributes, the hardware records the
information about the current access and triggers an access error interrupt.

When the CPU accesses the cache, the permission control module must check the attributes of the CPU access
by comparing it with the local access attribute list. Only if the two match, the CPU access is allowed. When the
access request is inconsistent with the current access attributes, the hardware records the information about the
current access and triggers an access error interrupt.

lf the access attribute check fails repeatedly, the hardware only records the first error message, and the
subsequent error messages will be discarded directly. The access error interrupt is a level signal. When software
clears the access error interrupt flag, the error record will be cleared at the same time.

24.3.3 Non-Aligned Access Permission Control

ESP32-S2 supports monitoring of non-word-aligned access. When PeriBus1 or PeriBus2 initiates a non-word
address alignment or non-word sized access to a peripheral device, an interrupt or system exception may be
triggered. The following table lists all possible access types and their corresponding results, where /V means
interrupt, EX means exceptions, and ./ means no action is triggered.

Espressif Systems 488 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

Table 127: Non-Aligned Access to Peripherals

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Accessed by Access Address | Access Unit | Read | Write
byte IN IN
OXXXXX_XXXO halfword IN IN
word J J
byte IN IN
PeriBus2 OXXXXX_XXX1 halfword J IN
word J IN
byte IN IN
OXXXXX_XXX2 halfword IN IN
word J IN
byte IN IN
OXXXXX_XXXO halfword IN IN
word J J
byte IN IN
Address range Ox3F40_0000 -
OxXXXX_XXX1 halfword EX EX
Ox3F4B_FFFF
word EX EX
byte IN IN
OXXXXX_XXX2 halfword IN IN
word EX EX
byte Vv Vv
OXXXXX_XXXO halfword J J
word J J
byte IN IN
Address range Ox3F4C_0000 -
OxXXXX_XXX1 halfword EX EX
OxGF4F_FFFF
word EX EX
byte IN IN
OXXXXX_XXX2 halfword IN IN
word EX EX

 

24.4 Base Address

Users can access the permission control module with the base address as shown in Table 128. For more
information, see Chapter System and Memory.

Table 128: Permission Control Base Address

 

Bus to Access Peripheral

Base Address

 

 

PeriBUS1

 

Ox8F4C1000

 

 

24.5 Register Summary

The address in the following table represents the address offset (relative address) with the respect to the
peripheral base address, not the absolute address. For detailed information about the permission control base

address, please refer to Section 24.4.

Espressif Systems

489

ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
24. Permission Control

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
Control Registers

PMS_PRO_IRAMO_0_REG IBUS permission control register 0. O0x0010 | RAV
PMS_PRO_DRAMO0_0_ REG DBUS permission control register 0. 0x0028 | RAV
PMS_PRO_DPORT_0O_REG PeriBus1 permission control register O. Ox0038C_ | RAV
PMS_PRO_AHB_O_REG PeriBus2 permission control register O. Ox005C_ | RAV
PMS_PRO_TRACE_O_REG Trace memory permission control register O. 0x0070 | RAV
PMS_PRO_CACHE_0_REG Cache permission control register O. 0x0078 | RAV
PMS_DMA_APB_|_0_REG Internal DMA permission control register 0. Ox008C | RAV
PMS_DMA_RX_|_O_REG RX Copy DMA permission control register 0. Ox009C | RAV
PMS_DMA_TX_|_O_REG TX Copy DMA permission control register 0. OxOOAC | RAV
PMS_CACHE_SOURCE_0O_REG Cache access permission control register 0. Ox00C4 | RAV
PMS_APB_PERIPHERAL_O_REG Peripheral access permission control register 0. | OxOOCC | RAV
PMS_OCCUPY_0O_REG Occupy permission control register O. Ox00D4 | RAV
PMS_CACHE_TAG_ACCESS_0_REG Cache tag permission control register 0. OxO0E4 | RAV
PMS_CACHE_MMU_ACCESS_0_ REG | Cache MMU permission control register 0. OxOOEC | RAV
PMS_CLOCK_GATE_REG_REG Clock gate register of permission control. O0x0104 | RAV
Configuration Registers

PMS_PRO_IRAMO_1_REG IBUS permission control register 1. 0x0014 | RAV
PMS_PRO_IRAMO_2_ REG IBUS permission control register 2. 0x0018 | RAV
PMS_PRO_IRAMO_3_ REG IBUS permission control register 3. Ox001C | RAV
PMS_PRO_DRAMO_1_REG DBUS permission control register 1. Ox002C | RAV
PMS_PRO_DRAMO_2_ REG DBUS permission control register 2. Ox0030 | RAV
PMS_PRO_DPORT_1_REG PeriBus1 permission control register 1. 0x0040 | RAV
PMS_PRO_DPORT_2_ REG PeriBus1 permission control register 2. 0x0044 | RAV
PMS_PRO_DPORT_3_REG PeriBus1 permission control register 3. 0x0048 | RAV
PMS_PRO_DPORT_4_ REG PeriBus1 permission control register 4. Ox004C | RAV
PMS_PRO_DPORT_5_REG PeriBus1 permission control register 5. Ox0050 =| RAV
PMS_PRO_AHB_1_REG PeriBus2 permission control register 1. Ox0060 | RAV
PMS_PRO_AHB_2_ REG PeriBus2 permission control register 2. Ox0064 | RAV
PMS_PRO_TRACE_1_REG Trace memory permission control register 1. 0x0074 | RAV
PMS_PRO_CACHE_1_REG Cache permission control register 1. Ox007C | RAV
PMS_DMA_APB_|_1_REG Internal DMA permission control register 1. Ox0090 | RAV
PMS_DMA_RX_I_1_REG RX Copy DMA permission control register 1. OxO0AO | RAV
PMS_DMA_TX_I_1_REG TX Copy DMA permission control register 1. OxO0BO | RAV
PMS_APB_PERIPHERAL_1_REG Peripheral access permission control register 1. | OxOODO | RAV
PMS_OCCUPY_1_REG Occupy permission control register 1. Ox00D8 | RAV
PMS_OCCUPY_3 REG Occupy permission control register 3. OxOOEO | RAV
PMS_CACHE_TAG_ACCESS_1_REG Cache tag permission control register 1. OxO0E8 | RAV
PMS_CACHE_MMU_ACCESS_1_REG_ | Cache MMU permission control register 1. OxOOFO | RAV
Interrupt Registers

PMS_PRO_IRAMO_4_ REG IBUS permission control register 4. 0x0020 =| varies
PMS_PRO_IRAMO_5 REG IBUS status register. 0x0024 | RO
PMS_PRO_DRAMO_3_ REG DBUS permission control register 3. 0x0034 | varies

 

Espressif Systems

490

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
24. Permission Control

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
PMS_PRO_DRAMO_4_ REG DBUS status register. 0x0038 | RO
PMS_PRO_DPORT_6_REG PeriBus1 permission control register 6. 0x0054 =| varies
PMS_PRO_DPORT_7_REG PeriBus1 status register. 0x0058 | RO
PMS_PRO_AHB_3_REG PeriBus2 permission control register 3. Ox0068 | varies
PMS_PRO_AHB_4_ REG PeriBus2 status register. Ox006C | RO
PMS_PRO_CACHE_2_ REG Cache permission control register 2. 0x0080_ ‘| varies
PMS_PRO_CACHE_3_ REG Icache status register. 0x0084 | RO
PMS_PRO_CACHE_4 REG Deache status register. 0x0088 | RO
PMS_DMA_APB_|_2 REG Internal DMA permission control register 2. 0x0094 | varies
PMS_DMA_APB_| 3 REG Internal DMA status register. 0x0098 | RO
PMS_DMA_RX_|_2 REG RX Copy DMA permission control register 2. OxO0A4 | varies
PMS_DMA_RX_|_3_REG RX Copy DMA status register. OxO0A8 | RO
PMS_DMA_TX_|_2 REG TX Copy DMA permission control register 2. Ox00B4 | varies
PMS_DMA_TX_|_3_REG TX Copy DMA status register. Ox00B8 | RO
PMS_APB_PERIPHERAL_INTR_REG PeriBus2 permission control register. OxO0F4 | varies
PMS_APB_PERIPHERAL_STATUS_REG| PeriBus2 peripheral access status register. OxOOF8 | RO
PMS_CPU_PERIPHERAL_INTR_REG PeriBus1 permission control register. OxOOFC | varies
PMS_CPU_PERIPHERAL_STATUS_ REG] PeriBus1 peripheral access status register. O0x0100 | RO
Version Control Register
PMsS_DATE Version control register. OxOFFC | RAV
24.6 Registers
Register 24.1: PMS_PRO_IRAMO_0 REG (0x0010)
S
&
& oe
& a
31 1| 0
000000000000 00000 00000000 0 0 0 0 0] 0 IReset

 

 

 

 

PMS_PRO_IRAMO LOCK Lock register. Setting to 1 locks IBUS permission control registers. (RAW)

Espressif Systems

491 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

Register 24.2: PMS_PRO_DRAM0_0_REG (0x0028)

 

 

 

 

 

 

 

 

Ne
O
a
RS
ve
Ss
& ge
s &?
Ce &
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
PMS _PRO_DRAMO_LOCK Lock register. Setting to 1 locks DBUSO permission control registers.
(RW)
Register 24.3: PMS_PRO_DPORT_0O REG (0x003C)
ca
AY
Ss
oS
Ss 4
sf &
Ce ~
[a1 1 0 |
joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset
PMS _PRO_DPORT_LOCK Lock register. Setting to 1 locks PeriBus1 permission control registers.
(RW)
Register 24.4: PMS_PRO_AHB_0 REG (0x005C)
Ne
SP
SQ’
S Oo
gs os
Ce ~
[a1

 

Le]

joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset

 

 

PMS_PRO_AHB LOCK Lock register.
(RAV)

Setting to 1 locks PeriBus2 permission control registers.

Espressif Systems 492

ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

Register 24.5: PMS_PRO_TRACE_0 REG (0x0070)

 

 

 

 

 

 

 

 

ca
Y
“ee
ee
or“
$
& x
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
PMS _PRO_TRACE LOCK Lock register. Setting to 1 locks trace function permission control regis-
ters. (RW)
Register 24.6: PMS_PRO_CACHE_0 REG (0x0078)
N-
O
Y
xs
ge
S Oo”
of S
€ &
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
PMS _PRO_CACHE LOCK Lock register. Setting to 1 locks cache permission control registers.
(RW)
Register 24.7: PMS DMA _APB_|_0 REG (0x008C)
Ne
O
9
ey
€
& wv
ss S
& x

 

[ Te]

joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset

PMS_DMA_APB_| LOCK Lock register. Setting to 1 locks internal DMA permission control registers.
(RAV)

Espressif Systems 493 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

Register 24.8: PMS_DMA_RX_I_0_ REG (0x009C)

 

 

 

 

 

 

 

 

 

 

 

 

ca
Y
&
s
& x
[1 | 0 |
jo0 0000090090000 09 09009 009 00 09 00 0 0 0 0] 0 Reset
PMS_DMA_RX_I_LOCK Lock register. Setting to 1 locks RX Copy DMA permission control registers.
(RW)
Register 24.9: PMS_DMA_TX_I_0 REG (Ox00AC)
N-
SF
\7
AW
er
ie x
Ce &
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
PMS_DMA_TX_I_LOCK Lock register. Setting to 1 locks TX Copy DMA permission control registers.
(RW)
Register 24.10: PMS_ CACHE SOURCE_0 REG (0x00C4)
a
Y
xe
Ss
&
wv
& oe
€ &
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
PMS CACHE SOURCE LOCK Lock register. Setting to 1 locks cache access permission control
registers. (RAV)
Espressif Systems 494 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.11: PMS_APB_PERIPHERAL_0 REG (0x00CC)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Ne
Oo
wy
“XT
&
Ss
S ”
sé os
eC &
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
PMS_APB_ PERIPHERAL LOCK Lock register. Setting to 1 locks TX Copy DMA permission control
registers. (RAV)
Register 24.12: PMS_OCCUPY_0_REG (0x00D4)
Ne
SF
7
5S
S a
f 9
& &
[a1 1 0 |
jo0 0000000900000 0000000 00 090 090 0 0 0 0] 0 Reset
PMS _OCCUPY_LOCK Lock register. Setting to 1 locks occupy permission control registers. (R/W)
Register 24.13: PMS_ CACHE TAG_ACCESS_0 REG (0x00E4)
Ne
SF
Pe
SF
&
e
oO
S S
se x
& a
31 1 oO
0 0000000000000 00 000 0000 00 0 0 0 0 0 0/0 IReset
PMS CACHE TAG_ACCESS LOCK Lock register. Setting to 1 locks cache tag permission control
registers. (RAV)
Espressif Systems 495 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.14: PMS_CACHE MMU_ACCESS_0_REG (0x00EC)

 

31 1] 0

 

0 0 00 0 00 0000 0 00 00 00 0 00 00 0 0 0 0 0 0 0 Of} O Reset

 

 

 

 

PMS _ CACHE MMU_ACCESS LOCK Lock register. Setting to 1 locks cache MMU permission con-
trol registers. (RAV)

Register 24.15: PMS_CLOCK_GATE_REG_REG (0x0104)

SS Sea
gS
Ce &

[ Te]

joo 0 0 0000090000000 9 00900000 00 0 0 0 0 0 0[1 IReset

 

 

 

PMS_CLK_EN Enable the clock of permission control module when set to 1. (RAV)

Espressif Systems 496 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

Register 24.16: PMS_PRO_IRAMO_1_REG (0x0014)

oso
S\ fs
& KES

 

[a

oS
@ O/ / 7
& Sara's
go | 8

2[u] |

 

| 0

fete [te]
|

0909900000000 0 000 0 0 oftfififift]s

 

Espressif Systems 497

PMS_PRO_IRAMO SRAM_0 F Setting to 1 grants IBUS permission to fetch SRAM Block 0. (RAW)
PMS_PRO_IRAMO SRAM_0R Setting to 1 grants IBUS permission to read SRAM Block 0. (R/W)
PMS_PRO_IRAMO SRAM_0_W Setting to 1 grants IBUS permission to write SRAM Block 0. (R/W)
PMS_PRO_IRAMO SRAM_1_F Setting to 1 grants IBUS permission to fetch SRAM Block 1. (RAW)
PMS_PRO_IRAMO SRAM_1_R_ Setting to 1 grants IBUS permission to read SRAM Block 1. (R/W)
PMS_PRO_IRAMO SRAM_1_W Setting to 1 grants IBUS permission to write SRAM Block 1. (RAW)
PMS_PRO_IRAMO SRAM_2 F Setting to 1 grants IBUS permission to fetch SRAM Block 2. (RAW)
PMS_PRO_IRAMO SRAM_2 R Setting to 1 grants IBUS permission to read SRAM Block 2. (R/W)
PMS_PRO_IRAMO SRAM_2 W Settingto 1 grants IBUS permission to write SRAM Block 2. (R/W)
PMS_PRO_IRAMO SRAM_3_F Setting to 1 grants IBUS permission to fetch SRAM Block 3. (RAW)
PMS_PRO_IRAMO SRAM_3_R Setting to 1 grants IBUS permission to read SRAM Block 3. (R/W)

PMS_PRO_IRAMO_SRAM_3_W Setting to 1 grants IBUS permission to write SRAM Block 3. (RAN)

Submit Documentation Feedback

1 | 1 |Reset

ESP32-S2 TRM (Preliminary V0.4)
24. Permission Control

 

Register 24.17: PMS_PRO_IRAMO_2_REG (0x0018)

 

 

 

PMS_PRO_IRAMO_ SRAM_4 SPLTADDR Configure the split address of SRAM Block 4-21 for IBUS
access. (R/W)

PMS_PRO_IRAMO_SRAM_4 L F Setting to 1 grants IBUS permission to fetch SRAM Block 4-21
low address region. (R/W)

PMS_PRO_IRAMO_SRAM_4 L R Setting to 1 grants IBUS permission to read SRAM Block 4-21
low address region. (R/W)

PMS_PRO_IRAMO_SRAM_4 L W Setting to 1 grants IBUS permission to write SRAM Block 4-21
low address region. (R/W)

PMS_PRO_IRAMO_SRAM_4 _H_F Setting to 1 grants IBUS permission to fetch SRAM Block 4-21
high address region. (RAN)

PMS_PRO_IRAMO_SRAM_4 H_R Setting to 1 grants IBUS permission to read SRAM Block 4-21
high address region. (RAN)

PMS_PRO_IRAMO_ SRAM_4 H_W Setting to 1 grants IBUS permission to write SRAM Block 4-21
high address region. (RAN)

Espressif Systems 498 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

Register 24.18:

PMS_PRO_IRAMO_3_REG (0x001C)

 

v7] 6 [os]

 

 

[ol]
oO
oO
oO
oO
oO
oO
oO
oO

0 0 0 0

0 ofafaa

PMS_PRO_IRAMO_RTCFAST_SPLTADDR Configure the split address of RTC FAST for IBUS ac-

cess. (RAV)

PMS_PRO_IRAMO_RTCFAST_L_F Setting to 1 grants IBUS permission to fetch RTC FAST low ad-

dress region. (RAV)

PMS_PRO_IRAMO_RTCFAST_L_R_ Setting to 1 grants IBUS permission to read RTC FAST low ad-

dress region. (RAV)

PMS_PRO_IRAMO_RTCFAST_L_W Setting to 1 grants IBUS permission to write RTC FAST low ad-

dress region. (RAV)

PMS_PRO_IRAMO_RTCFAST_H_F Setting to 1 grants IBUS permission to fetch RTC FAST high

address region. (R/W)

PMS_PRO_IRAMO_RTCFAST_H_R Setting to 1 grants IBUS permission to read RTC FAST high

address region. (R/W)

PMS_PRO_IRAMO_RTCFAST_H_W Setting to 1 grants IBUS permission to write RTC FAST high

address region. (R/W)

Espressif Systems

499 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.19: PMS_PRO_DRAM0_1_REG (0x002C)

 

 

 

 

ge
x &
7 SS OA S Se S38 s 7 XMS Sg
Wi iV iY Ww Wit iM i
Sees é SEEEeeF
SX 4 SX 4 4 SX 4 SX 4 S&S 4 f 4
SES a S SES SKK
& € OEE’ ee SEEELEEERS
E LLL & RENE”
[a1 29] 26 | 27 | 26 | 25 [24 alefels[-[sfe[o feo]
foo oftfififi] 0 fifa [aft [s [i]t [st Jreset
PMS _PRO_DRAMO_SRAM_0R Setting to 1 grants DBUSO permission to read SRAM Block 0.
(RAV)
PMS _PRO_DRAMO_SRAM_0 W Setting to 1 grants DBUSO permission to write SRAM Block 0.
(RAV)
PMS_PRO_DRAMO_SRAM_1_R Setting to 1 grants DBUSO permission to read SRAM Block 1.
(RAV)
PMS _PRO_DRAMO_SRAM_1_W Setting to 1 grants DBUSO permission to write SRAM Block 1.
(RAV)
PMS _PRO_DRAMO_SRAM_2 R Setting to 1 grants DBUSO permission to read SRAM Block 2.
(RAV)
PMS _PRO_DRAMO_SRAM_2 W Setting to 1 grants DBUSO permission to write SRAM Block 2.
(RAV)
PMS _PRO_DRAMO_SRAM_3_R Setting to 1 grants DBUSO permission to read SRAM Block 3.
(RAV)
PMS _PRO_DRAMO_SRAM_3_W Setting to 1 grants DBUSO permission to write SRAM Block 3.
(RAV)
PMS_PRO_DRAMO_SRAM_4 SPLTADDR Configure the split address of SRAM Block 4-21 for
DBUS0O access. (R/WV)
PMS_PRO_DRAMO_SRAM_4_L_R Settingto1 grants DBUSO permission to read SRAM Block 4-21
low address region. (R/W)
PMS _PRO_DRAMO_SRAM_4 _L_W Setting to 1 grants DBUSO permission to write SRAM Block 4-
21 low address region. (RAN)
PMS_PRO_DRAMO_SRAM_4_H_R Setting to 1 grants DBUSO permission to read SRAM Block 4-21
high address region. (RAN)
PMS_PRO_DRAMO_SRAM_4_H_ W Setting to 1 grants DBUSO permission to write SRAM Block
4-21 high address region. (RAW)
Espressif Systems 500 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.20: PMS_PRO_DRAM0_2_REG (0x0030)

 

 

 

 

S$
)
we
SB SW S v
7 ZV
KPRILV ALY AF
SEES &
SEES oS
Sore =
SOF s
& THOS &
[a1 5] 4 [a3 | 2 | [0 o|
fo 0 9 0000000000 00 0 ofifrfifi] 0 |Reset
PMS_PRO_DRAMO_RTCFAST_SPLTADDR Configure the split address of RTC FAST for DBUSO
access. (R/W)
PMS _PRO_DRAMO_RTCFAST_L_R Setting to 1 grants DBUSO permission to read RTC FAST low
address region. (R/W)
PMS_PRO_DRAMO_RTCFAST_L_W Setting to 1 grants DBUSO permission to write RTC FAST low
address region. (R/W)
PMS _PRO_DRAMO_RTCFAST_H_R Setting to 1 grants DBUSO permission to read RTC FAST high
address region. (R/W)
PMS _PRO_DRAMO_RTCFAST_H_W Setting to 1 grants DBUSO permission to write RTC FAST high
address region. (R/W)
Espressif Systems 501 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.21: PMS_PRO_DPORT_1_REG (0x0040)

 

 

 

Q S$
we ©
& Sys ev e
f 7. f f 4 ge
Stor Ss Ss
Lx PEEO P&P &?
KIKI RAK x g
A» Sa SaSeS x aS
< SAE ESE g g
S SS s s
oF  oSo%oKS oS oS
eS & EES xs xs
g ? So .@ @ & &? S-
& Se aro’ * ~
[1 219 [sf els] e [a 1] o |
joo 0 0 000000 0 9 0 fi fafads] 0 [ 0 |Reset

 

PMS _PRO_DPORT_APB_PERIPHERAL FORBID Setting to 1 denies PeriBus1 bus’s access to
APB peripheral. (RAV)

PMS _PRO_DPORT_RTCSLOW_SPLTADDR Configure the split address of RTC FAST for PeriBus1
access. (R/W)

PMS _PRO_DPORT_RTCSLOW_L_R_ Setting to 1 grants PeriBus1 permission to read RTC FAST low
address region. (R/W)

PMS _PRO_DPORT_RTCSLOW_L_W Setting to 1 grants PeriBus1 permission to write RTC FAST
low address region. (R/W)

PMS _PRO_DPORT_RTCSLOW_H_R Setting to 1 grants PeriBus1 permission to read RTC FAST
high address region. (RAN)

PMS_PRO_DPORT_RTCSLOW_H_W Setting to 1 grants PeriBus1 permission to write RTC FAST
high address region. (RAN)

PMS_PRO_DPORT_RESERVE_FIFO_ VALID Configure whether to enable read protection for user-
configured FIFO address. (RAV)

Register 24.22: PMS_PRO_DPORT_2_REG (0x0044)

 

 

 

 

2
&
ew
S
&
gS
£7
ss
oF
S
sf s
& x
[1 [17 o|
jo 0 0 9 0 0 9 00000 0 Of 0x000 |Reset
PMS _PRO_DPORT_RESERVE_FIFO_0 Configure read-protection address 0. (RAM)
Espressif Systems 502 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.23: PMS_PRO_DPORT_3_REG (0x0048)

 

 

 

 

 

 

 

 

 

 

 

 

ee
ew
S
S
gS
A?
Ss
§
& 0%
s &?
Ce ~
[a1 te | o|
foo 09 000000000 0 0 0x000 |Reset
PMS _PRO_DPORT_RESERVE_FIFO_1 Configure read-protection address 1. (RAM)
Register 24.24: PMS_PRO_DPORT_4 REG (0x004C)
er
we
S
E
gS
&
oe
& e
& a
[1 [17 o|
jo 0 0 9 0 0 9 00000 0 Of 0x000 |Reset
PMS _PRO_DPORT_RESERVE_FIFO_2 Configure read-protection address 2. (RAW)
Register 24.25: PMS_PRO_DPORT_5 REG (0x0050)
?
&
ew
S
S
A?
ge
So
§
& er
& a
[a1 te | o|
foo 09 000000000 0 0 0x000 |Reset
PMS _PRO_DPORT_RESERVE_FIFO_3 Configure read-protection address 3. (RAW)
Espressif Systems 503 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.26:

PMS_PRO_AHB_1_REG (0x0060)

 

 

 

 

PMS _PRO_AHB_RTCSLOW_0 SPLTADDR Configure the split address of RTCSlow_0 for PeriBus2

access. (R/W)

PMS _PRO_AHB RTCSLOW_0_L F Setting to 1 grants PeriBus2 permission to fetch RTCSlow_0O

low address region. (R/W)

PMS _PRO_AHB RTCSLOW_0 LR Setting to 1 grants PeriBus2 permission to read RTCSlow_0O

low address region. (R/W)

PMS _PRO_AHB RTCSLOW_0_L_W Setting to 1 grants PeriBus2 permission to write RTCSlow_0O

low address region. (R/W)

PMS _PRO_AHB RTCSLOW_0_H_F Setting to 1 grants PeriBus2 permission to fetch RTCSlow_0O

high address region. (RAN)

PMS _PRO_AHB RTCSLOW_0_H_R Setting to 1 grants PeriBus2 permission to read RTCSlow_0O

high address region. (RAN)

PMS _PRO_AHB RTCSLOW_0_H_W Setting to 1 grants PeriBus2 permission to write RTCSlow_0O

high address region. (RAN)

Espressif Systems

504 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.27: PMS_PRO_AHB_2_REG (0x0064)

 

 

 

 

 

 

 

 

ge
YS <¢ se
f f f Lf < fo g
oer rr”
SONOS os
& EEE EE x
g if Cy 7 C7 Cy 7 C7 Cy 7 C7
& SPV M AS &
[a1 v7] 6 fas |v | 13 | 2 | Jo o|
fo 0 9 0 0 00000 00 0 0 ofifififrfi]i] 0 |Reset
PMS _PRO_AHB_ RTCSLOW_1_SPLTADDR Configure the split address of RTCSlow_1 for PeriBus2
access. (R/W)
PMS _PRO_AHB RTCSLOW_1_L F Setting to 1 grants PeriBus2 permission to fetch RTCSlow_1
low address region. (R/W)
PMS _PRO_AHB RTCSLOW_1_L_R Setting to 1 grants PeriBus2 permission to read RTCSlow_1
low address region. (R/W)
PMS _PRO_AHB RTCSLOW_1_L_W Setting to 1 grants PeriBus2 permission to write RTCSlow_1
low address region. (R/W)
PMS_PRO_AHB RTCSLOW_1_H_F Setting to 1 grants PeriBus2 permission to fetch RTCSlow_1
high address region. (RAN)
PMS _PRO_AHB RTCSLOW_1_H_R Setting to 1 grants PeriBus2 permission to read RTCSlow_1
high address region. (RAN)
PMS _PRO_AHB RTCSLOW_1_H_W Setting to 1 grants PeriBus2 permission to write RTCSlow_1
high address region. (RAN)
Register 24.28: PMS_PRO_TRACE_1_REG (0x0074)
o
SX
a
xe
& gor
Ss eo”
€ &
lf if
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
PMS_PRO_TRACE DISABLE Setting to 1 disables the trace memory function. (R/W)
Espressif Systems 505 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.29: PMS_PRO_CACHE_1_REG (0x007C)

 

 

 

A
&
ss
&
x7
eS
oe
& ee
s .
& ~
[1 16 [15 o|
[oo 0 900000000000 9 0 |Reset

 

PMS _PRO_CACHE CONNECT Configure which SRAM Block will be occupied by Icache or Dcache.
(RAV)

Espressif Systems 506 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

Register 24.30: PMS_DMA_APB_I_1_REG (0x0090)

 

 

 

x &
SU S Se 7 7 s SVS S 7
WY. SS a ON?
woe
SEK EF SF SESS SS SEF
& NNO” ow NNN”
E SEES er SEER”
[a1 29] 26 | 27 | 26 | 25 [24 alefels[-[sfe[o feo]
[0 0 | 0 fifa [aft [s [i]t [st Jreset

 

PMS_DMA_APB_| SRAM_0R Setting to 1 grants internal DMA permission to read SRAM Block 0.

(RAV)

PMS_DMA_APB_| SRAM_0 W Setting to 1 grants internal DMA permission to write SRAM Block
0. (RW)

PMS_DMA_APB_| SRAM_1_R Setting to 1 grants internal DMA permission to read SRAM Block 1.
(RAV)

PMS_DMA_APB_| SRAM_1_W Setting to 1 grants internal DMA permission to write SRAM Block
1. (RW)

PMS_ DMA _APB_| SRAM_2 RP Setting to 1 grants internal DMA permission to read SRAM Block 2.
(RAV)

PMS_DMA_APB_| SRAM_2 W Setting to 1 grants internal DMA permission to write SRAM Block
2. (RW)

PMS_ DMA _APB_| SRAM_3_ RP Setting to 1 grants internal DMA permission to read SRAM Block 3.
(RAV)

PMS_DMA_APB_| SRAM_3_W Setting to 1 grants internal DMA permission to write SRAM Block
3. (RW)

PMS_DMA_APB_| SRAM_4 SPLTADDR Configure the split address of SRAM Block 4-21 for inter-
nal DMA access. (R/W)

PMS_DMA_APB_| SRAM_4_L R Setting to 1 grants internal DMA permission to read SRAM Block
4-21 low address region. (R/W)

PMS_DMA_APB_| SRAM_4_L_W Setting to 1 grants internal DMA permission to write SRAM Block
4-21 low address region. (R/W)

PMS_DMA_APB_| SRAM_4_H_R Setting to 1 grants internal DMA permission to read SRAM Block
4-21 high address region. (RAW)

PMS_DMA_APB_| SRAM_4_H _W Setting to 1 grants internal DMA permission to write SRAM Block
4-21 high address region. (RAW)

Espressif Systems 507 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

 

 

 

Register 24.31: PMS_DMA_RX_I1_REG (0x00A0)
ge
SRWE a
we OY De” So S 7 NSS SoPo$
See Ss Se
goer ~ Sere ee ee”
OS sw WY Way gy ar Qh ha
S eroere” y SOO OOO OGY
EC SNS & SKM M MAAN SOS
[1 23| 2 | 2 | 26 | 2 [= el7felfs[«[s]e] fe]
[o 0 oli fafadt] 0 fifi fa ft [+ [1] st [4 Jreset

 

PMS_DMA_RX_I|_SRAM_0R Setting to 1 grants RX Copy DMA permission to read SRAM Block 0.

(RW)

PMS_DMA_RX_I|_SRAM_0 W Setting to 1 grants RX Copy DMA permission to write SRAM Block

0. (RW)

PMS_DMA_RX_I_SRAM_1_R Setting to 1 grants RX Copy DMA permission to read SRAM Block 1.

(RW)

PMS_DMA_RX_I_SRAM_1_W Setting to 1 grants RX Copy DMA permission to write SRAM Block

1. (RAW)

PMS _DMA_RX_I|_SRAM_2 R Setting to 1 grants RX Copy DMA permission to read SRAM Block 2.

(RW)

PMS_DMA_RX_I_SRAM_2 W Setting to 1 grants RX Copy DMA permission to write SRAM Block

2. (RW)

PMS_DMA_RX_I_SRAM_3 RP Setting to 1 grants RX Copy DMA permission to read SRAM Block 3.

(RW)

PMS_DMA_RX_I_SRAM_3 W Setting to 1 grants RX Copy DMA permission to write SRAM Block

3. (RW)

PMS_DMA_RX_I_SRAM_4 SPLTADDR Configure the split address of SRAM Block 4-21 for RX

Copy DMA access. (RAW)

PMS_DMA_RX_I_SRAM_4 LR Setting to 1 grants RX Copy DMA permission to read SRAM Block

4-21 low address region. (R/W)

PMS_DMA_RX_I_SRAM_4 L_W Setting to 1 grants RX Copy DMA permission to write SRAM Block

4-21 low address region. (R/W)

PMS_DMA_RX_I_SRAM_4 H_R Setting to 1 grants RX Copy DMA permission to read SRAM Block

4-21 high address region. (RAW)

PMS_DMA_RX_I_SRAM_4_H_W Setting to 1 grants RX Copy DMA permission to write SRAM Block

4 21 high address region. (R/W)

Espressif Systems

508 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.32: PMS_DMA_TX_I_1_REG (0x00B0)

 

 

 

SX
we
ws 4 7 Ss Se oad ra Sr For os
Se Ss SEELSS LS
PPD” a PPPHPHA PH”
S& KAO” 3 SHPO HOO”
EC SRK er SEEM

[1 29] 26 | 27 | 2 | 25 [2 al7fels[e[sfe[o]eo]
fo o oftfififr] 0 ee ee:

 

PMS_DMA_TX_I|_SRAM_0R Setting to 1 grants TX Copy DMA permission to read SRAM Block 0.
(RAV)

PMS_DMA_TX_I|_SRAM_0 W Setting to 1 grants TX Copy DMA permission to write SRAM Block 0.
(RAV)

PMS_DMA_TX_I|_SRAM_1_R Setting to 1 grants TX Copy DMA permission to read SRAM Block 1.
(RAV)

PMS_DMA_TX_I|_SRAM_1_W Setting to 1 grants TX Copy DMA permission to write SRAM Block 1.
(RAV)

PMS_DMA_TX_I_SRAM_2 R Setting to 1 grants TX Copy DMA permission to read SRAM Block 2.
(RAV)

PMS_DMA_TX_I_SRAM_2 W Setting to 1 grants TX Copy DMA permission to write SRAM Block 2.
(RAV)

PMS_DMA_TX_I_SRAM_3_R Setting to 1 grants TX Copy DMA permission to read SRAM Block 3.
(RAV)

PMS_DMA_TX_I_SRAM_3_W Setting to 1 grants TX Copy DMA permission to write SRAM Block 3.
(RAV)

PMS_DMA_TX_I_SRAM_4 SPLTADDR Configure the split address of SRAM Block 4-21 for TX Copy
DMA access. (R/WV)

PMS_DMA_TX_I_SRAM_4 L R Setting to 1 grants TX Copy DMA permission to read SRAM Block
4-21 low address region. (R/W)

PMS_DMA_TX_I_SRAM_4 L_W Setting to 1 grants TX Copy DMA permission to write SRAM Block
4-21 low address region. (R/W)

PMS_DMA_TX_I_SRAM_4 HR Setting to 1 grants TX Copy DMA permission to read SRAM Block
4-21 high address region. (RAW)

PMS_DMA_TX_I_SRAM_4 H W Settingto 1 grants TX Copy DMA permission to write SRAM Block
4-21 high address region. (RAW)

Espressif Systems 509 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

 

Register 24.33: PMS_APB_PERIPHERAL_1_REG (0x00D0)

 

[ [>|

jo 9000000000000 0000000 00090 00 0 0 0 0] 1 IReset

 

 

PMS_APB_ PERIPHERAL SPLIT BURST Setting to 1 splits the data phase of the last access and
the address phase of following access. (R/W)

Register 24.34: PMS_OCCUPY_1_REG (0x00D8)

 

 

 

 

PMS _ OCCUPY CACHE Configure whether SRAM Block 0-3 is used as cache memory. (R/W)

Register 24.35: PMS_OCCUPY_3_REG (0x00E0)

 

[1 [17 o|

 

 

jo 0 0 9 0 0 9 00000 0 Of 0 |Reset

 

PMS _ OCCUPY _PRO_TRACE Configure one out block of Block 4-21 is used as trace memory. (RAW)

Espressif Systems 510 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

Register 24.36: PMS_CACHE TAG_ACCESS_1_REG (0x00E8)

 

PMS_PRO_I_TAG_RD_ACS Setting to 1 permits read access to Icache tag memory. (RAW)
PMS_PRO_I_TAG _WR_ACS Setting to 1 permits write access to Icache tag memory. (RAV)
PMS _PRO_D TAG_RD_ACS Setting to 1 permits read access to Dcache tag memory. (R/W)

PMS_PRO_D_TAG_WR_ACS Setting to 1 permits write access to Dcache tag memory. (RAV)

Register 24.37: PMS_CACHE_MMU_ACCESS 1_REG (0x00FO0)

 

 

 

 

S
ee
We?
We’
& OO”
& ee
[z Lf]
joo 0 0 0000090000009 00900000909 00 0 0 0 0 0[71][1 IReset
PMS_PRO_MMU_RD_ACS Setting to 1 permits read access to MMU memory. (R/V)
PMS_PRO_MMU_WR_ACS Setting to 1 permits write access to MMU memory. (R/V)
Register 24.38: PMS_PRO_IRAMO_4 REG (0x0020)
oe
SEF
PPV”
ws 97 0”
Cee
e OOO
é Ee

 

 

 

PMS_PRO_IRAMO_ILG_CLR_ The clear signal for IBUS access interrupt. (RW)
PMS_PRO_IRAMO_ILG_EN The enable signal for IBUS access interrupt. (RAM)

PMS_PRO_IRAMO_ILG_INTR IBUS access interrupt signal. (RO)

Espressif Systems 514 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

Register 24.39: PMS_PRO_IRAMO_5_REG (0x0024)

 

 

 

gS
Ov
or
Ss
S a
&
EF a
[1 2221 o|
jo 0 0 0 9 0 0 0 0 Of 0 |Reset

 

PMS_PRO_IRAMO_ILG_ST Record the illegitimate information of IBUS. [21:2]: store the bits [21:2] of
IBUS address; [1]: 1 means data access, 0 means instruction access; [0]: 1 means write operation,

O means read operation. (RO)

Register 24.40: PMS_PRO_DRAM0_3_REG (0x0034)

<a
SSF
See
BF oe ov
oot oF
& CEE
f PRORe’
© We

 

31 3] 2 1 °

 

 

 

 

 

0 0 00 0 00 0 00 0 00 00 00 00 0 00 00 0 0 0 0 0] 0]0] O Reset

 

 

PMS_PRO_DRAMO_ILG_CLR The clear signal for DBUSO access interrupt. (RAV)
PMS_PRO_DRAMO_ILG_EN The enable signal for DBUSO access interrupt. (R/V)

PMS_PRO_DRAMO_ILG_INTR DBUSO access interrupt signal. (RO)

Register 24.41: PMS_PRO_DRAM0_4_REG (0x0038)

 

 

 

A
@
Ov
y
O7
ca
S go’
e
<
[1 2s | 25 o|
| 0 |Reset

 

PMS _PRO_DRAMO_ILG_ST Record the illegitimate information of DBUS. [25:6]: store the bits [21:2]
of DBUS address; [5]: 1 means atomic access, 0 means nonatomic access; [4]: 1 means write
operation, O means read operation; [8:0]: DBUSO bus byte enables. (RO)

Espressif Systems 512 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
24. Permission Control

Register 24.42: PMS_PRO_DPORT_6_REG (0x0054)

 

 

 

 

 

 

 

 

 

 

 

 

oe
LEE
Soro”
e OOO
é eh”
[1 3| 2 | 1 | 0 |
joo 0 0 0000000000090 0000090 00 0 0 0 ofo[o][o IReset
PMS _PRO_DPORT_ILG_CLR The clear signal for PeriBus1 access interrupt. (RAW)
PMS _PRO_DPORT_ILG_EN The enable signal for PeriBus1 access interrupt. (RW)
PMS_PRO_DPORT_ILG_INTR PeriBus1 access interrupt signal. (RO)
Register 24.43: PMS_PRO_DPORT_7_REG (0x0058)
$
e
ro
C7
< ¥
& x
[1 2s | 25 o|
[o 0 0 0 0 | 0 |Reset
PMS_PRO_DPORT_ILG_ST Record the illegitimate information of PeriBus1. [25:6]: store the bits
[21:2] of PeriBus1 address; [5]: 1 means atomic access, 0 means nonatomic access; [4]: if bits
[31:22] of PeriBus1 address are Oxfd, then the bit value is 1, otherwise it is 0; [3:0]: PeriBus 1 byte
enables. (RO)
Register 24.44: PMS_PRO_AHB 3 REG (0x0068)
SSF
& PLL
é RS
[a1 3| 2 | 1 | 0 |
jo9 0000000000000 00 0000090 090 00 0 0[0]0] 0 IReset
PMS_PRO_AHB_ILG_CLR The clear signal for PeriBus2 access interrupt. (R/V)
PMS_PRO_AHB_ILG_EN The enable signal for PeriBus2 access interrupt. (RAV)
PMS_PRO_AHB_ILG_INTR PeriBus2 access interrupt signal. (RO)
Espressif Systems 513 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

Register 24.45: PMS_PRO_AHB 4 REG (0x006C)
3
oy
ss
C57
&
[ 7]

| 0 | Reset

PMS_PRO_AHB_ILG_ST Record the illegitimate information of PeriBus2. [31:2]: store the bits [81:2]
of PeriBus2 address; [1]: 1 means data access, 0 means instruction access; [0]: 1 means write

operation, O means read operation. (RO)

Register 24.46: PMS_PRO_CACHE_2_ REG (0x0080)

 

 

 

 

 

 

 

 

yo
oe
YoY
KKK
wreR
& QOL’
é See
[1 3| 2 | 1 | 0 |
joo 0 0 0000000000090 0000090 00 0 0 0 ofo[o][o IReset
PMS_PRO_CACHE_ILG_CLR The clear signal for cache access interrupt. (R/V)
PMS_PRO_CACHE_ILG_EN The enable signal for cache access interrupt. (RAM)
PMS_PRO_CACHE_ILG_INTR Cache access interrupt signal. (RO)
Register 24.47: PMS_PRO_CACHE_3 REG (0x0084)
\
&
e
©
of
< ¥
& *
[a1 17] 6 o|
fo.0 9 000000000 00 0 0 |Reset
PMS_PRO_CACHE_ILG_ST_I Record the illegitimate information of cache to access memory. [16]:
access enable, active low; [15:4]: store the bits [11:0] of address; [3:0]: Icache bus byte enables,
active low. (RO)
Espressif Systems 514 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

Register 24.48: PMS_PRO_CACHE_4 REG (0x0088)

> &
£

vA

 

31 17 | 16

 

 

 

0 0 0 00 0 00 0 0 0 0 0 0 0 0 Reset

 

 

PMS _PRO_CACHE_ILG_ST_D Record the illegitimate information of Dcache to access memory.
[16]: access enable, active low; [15:4]: store the bits [11:0] of address; [8:0]: Dcache bus byte
enables, active low. (RO)

Register 24.49: PMS_DMA_APB_I_2_ REG (0x0094)

 

 

 

 

 

 

 

 

gy
ser
See
See
& & gy

[1 3| 2 | 1 | 0 |
joo 0 0 0000000000090 0000090 00 0 0 0 ofo[o][o IReset

PMS_DMA_APB_|_ILG_CLR_ The clear signal for internal DMA access interrupt. (RAV)

PMS_DMA_APB_I|_ILG_EN The enable signal for internal DMA access interrupt. (RW)

PMS_DMA_APB_|_ILG_INTR_ Internal DMA access interrupt signal. (RO)

Register 24.50: PMS_DMA_APB_|_ 3 REG (0x0098)
$
a
os
& x
& we
€ <

| 31 23 | 22 0 |
fo 0 0 0 0 0 0 0 Of 0 |Reset

PMS_DMA_APB_I|_ILG_ST Record the illegal information of Internal DMA. [22:6]: store the bits [18:2]

of address; [5]: if bits [81:19] of address are Ox7ff, then the bit value is 1, otherwise it is 0; [4]: 1
means write operation, 0 means read operation; [3:0]: Internal DMA bus byte enable; (RO)
Espressif Systems 515 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

Register 24.51: PMS_DMA_RX_|_2_ REG (0x00A4)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

YY ey
Saray”
> SQ”
& OE”
& Xe
31 3 2 1 0
0000000000000 00000 00 0 0 0 0 0 0 0 0 0f0]0] 0 IReset
PMS_DMA_RX_I_ILG_CLR The clear signal for RX Copy DMA access interrupt. (RAN)
PMS_DMA_RX_I_ILG_EN The enable signal for RX Copy DMA access interrupt. (R/V)
PMS_DMA_RX_I_ILG_INTR RX Copy DMA access interrupt signal. (RO)
Register 24.52: PMS_DMA_RX_|_3_ REG (0x00A8)
$
So
Ss ss
& ° oY
€ &
[a1 23 | 22 o|
fo 0 0 0 0 0 0 0 Of 0 |Reset
PMS_DMA_RX_I_ILG_ST Record the illegitimate information of RX Copy DMA. [22:6]: store the bits
[18:2] of address; [5]: if bits [81:19] of address are Ox7ff, then the bit value is 1, otherwise it is O; [4]:
1 means write operation, O means read operation; [3:0]: RX Copy DMA bus byte enables. (RO)
Register 24.53: PMS_DMA_TX_I_2 REG (0x00B4)
yo
s > oo
sey’
SOS
a See
& SNS
[a1 3| 2 | 1 | 0 |
jo9 0000000000000 00 0000090 090 00 0 0[0]0] 0 IReset
PMS _DMA_TX_I_ILG_CLR The clear signal for TX Copy DMA access interrupt. (RAV)
PMS_DMA_TX_I_ILG_EN The enable signal for TX Copy DMA access interrupt. (R/V)
PMS_DMA_TX_LILG_INTR TX Copy DMA access interrupt signal. (RO)
Espressif Systems 516 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

Register 24.54: PMS_DMA_TX_I_3_REG (0x00B8)

 

of
\y
Lo
S we
of Ss
& we
e <
31 23 | 22 o
0 00 0 0060 00 0 0 Reset

 

 

 

 

 

PMS_DMA_TX_LILG_ST Record the illegitimate information of TX Copy DMA. [22:6]: store the bits
[18:2] of address; [5]: if bits [81:19] of address are Ox7ff, then the bit value is 1, otherwise it is 0;
[4]: 1 means write operation, O means read operation; [3:0]: TX Copy DMA bus byte enables. (RO)

Register 24.55: PMS_APB_PERIPHERAL_INTR_REG (0x00F4)

 

 

 

 

 

 

 

LXV’
SXCO
SESE
KKK
oe
CLS
& PLE 7
& Oe”
€ g
[a1 3| 2 | 1 | 0 |
jo9 0000000000000 00 0000090 090 00 0 0[0]0] 0 IReset
PMS_APB_PERIBYTE ERROR_CLR The clear signal for APB peripheral interrupt. (RAM)
PMS_APB_PERI_BYTE ERROR_EN The enable signal for APB peripheral access interrupt. (RAW)
PMS_APB_PERI_BYTE ERROR_INTR APB peripheral access interrupt signal. (RO)
Register 24.56: PMS_APB_PERIPHERAL_STATUS_REG (0x00F8)
S$
e
ee
Ss
&
ey
g
LY’
oe
x
[1 o|
| 0 |Reset

 

PMS_APB_PERI_BYTE ERROR_ADDR Record the illegitimate address of APB peripheral. (RO)

Espressif Systems 517 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
24. Permission Control

 

Register 24.57: PMS_CPU_PERIPHERAL_INTR_REG (0x00FC)

 

 

 

Se oF
SELEY
SEE
Og
Ree’
SSE
° LES”
é SSE
[x Jet: ]e]
joo 0 0 0000000000090 0000090 00 0 0 0 ofo[o][o IReset

 

PMS _CPU_PERI_BYTE_ERROR_CLR The clear signal for CPU peripheral access interrupt. (R/W)
PMS_CPU_PERI_BYTE_ERROR_EN The enable signal for CPU peripheral access interrupt. (RW)

PMS_CPU_PERIBYTE_ERROR_INTR CPU peripheral access interrupt signal. (RO)

Register 24.58: PMS_CPU_PERIPHERAL_STATUS_REG (0x0100)

 

[ 7]

| 0 | Reset

 

 

PMS _CPU_PERI_BYTE_ERROR_ADDR Record the illegitimate address of CPU peripheral. (RO)

Register 24.59: PMS_DATE_REG (0x0FFC)

 

 

 

 

& X
& a
| 31 28 | 7 0 |
[o 0. 0 | 0x1905090 |Reset
PMS_DATE Version control register. (RAV)
Espressif Systems 518 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
25. Digital Signature

 

25. Digital Signature

25.1 Overview

Digital signatures provide a way to cryptographically authenticate a message using a private key, to be verified
using the corresponding public key. This can be used to validate a device’s identity to a server, or to authenticate
the integrity of a message has not been tampered with.

ESP32-S82 includes a digital signature (DS) peripheral which produces hardware accelerated RSA digital
signatures, without the RSA private key being accessible by software.

25.2 Features
* RSA Digital Signatures with key lengths up to 4096 bits

* Private key data is encrypted and only readable by DS peripheral

® SHA-256 digest is used to protect private key data against tampering by an attacker

25.3 Functional Description

25.3.1 Overview
The DS peripheral calculates the RSA encryption operation Z = XY mod M where Z is the signature, X is the
input message, Y and MM are the RSA private key parameters.

Private key parameters are stored in flash or another form of storage, in an encrypted form. They are encrypted
using a key which can only be read by the DS peripheral via the HMAC peripheral. The required inputs to
generate the key are stored in eFuse and can only be accessed by the HMAC peripheral. This means that only
the DS peripheral hardware can decrypt the private key, and the plaintext private key data is never accessed by
software.

The input message X is input directly to the DS peripheral by software, each time a signature is needed. After
the operation, the signature Z is read back by software.

25.3.2 Private Key Operands

Private key operands Y (private key exponent) and M (key modulus) are generated by the user. They will have a
particular RSA key length (up to 4096 bits). A corresponding public key is also generated and stored separately,
it can be used independently to verify DS signatures.

Two additional private key operands are needed —7 and M’. These two operands are derived from Y and M,
but they are calculated in advance by software.

Operands Y, M,7, and M’ are encrypted by the user along with an authentication digest and stored as a single
ciphertext C’. C is input to the DS peripheral in this encrypted format, then the hardware decrypts C and uses the
key data to generate the signature. Detailed description of the encryption process to prepare C is provided in
Section 25.3.4.

The DS peripheral needs to activate RSA to perform Z = XY mod M. For detailed information on the RSA
algorithm, please refer to Section 21.3.1 Large Number Modular Exponentiation in Chapter 21 RSA
Accelerator.

Espressif Systems 519 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
25. Digital Signature

 

25.3.3 Conventions
The following sections of this chapter will use the following symbols and functions:

° 15 A bit string that consists of s “1” bits.

® [z]5 A bit string of length s bits. If x is a number (x < 2°), it is represented in little endian byte order in
the bit string. « may be a variable value such as [Y]4096 or as a hexadecimal constant such as [OxOC]s. If
necessary, the value [2] is right-pacdded with Os to reach s bits in length. For example: [0x5], = 0101,
[Ox5]g = 00000101, [Ox5]i¢ = 0000010100000000, [Ox13]s = 00010011, [Ox13]ig = 0001001100000000.

® || A bit string concatenation operator for joining multiple bit strings into a longer bit string.

25.3.4 Software Storage of Private Key Data

To store a private key for use with the DS peripheral, users need to complete the following preparations:
* Generate the RSA private key (Y, M) and associated operands 7 and M’, as described in Section 25.3.2.

° Generate a 256-bit HMAC key (LH MAC_K EY 256) that is stored in eFuse. This HMAC key is read by the
HMAC peripheral to derive a key, as DS_K EY = HMAC-SHA256((H MAC_K EY Jose, 17°°). This key is
used to securely encrypt and decrypt the stored RSA private key data.

* Prepare encrypted private key parameters as ciphertext C, 1584 bytes in length.

Figure 25-1 below describes the preparations at the software level (the left part) and the DS peripheral operation
at the hardware level (the right part).

 

Software Level Hardware Level

   
   
 

   
   
 
 

 

 
 

 

  
 

1. [Prepare ¥, M, IKEYIng 29d Mg) | 12)
2) Calculate 7, M’ at)
3) 19

a o

 
  
 

     

5) Build [Pl sr
CBC encryption to get C

 

   

CBC decryption

   

 

 

x

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Figure 25-1. Preparations and DS Operation

Users need to follow the steps shown in the left part of Figure 25-1 to calculate C’.. Detailed instructions are as
follows:

e Step 1: Prepare Y and M whose lengths should meet the aforementioned requirements. Define [£]32 = x
(i.e., for RSA 4096, [L]32 == [Ox80]32). Prepare [DS_K EY ]25— and generate a random [JV ]j23 which

Espressif Systems 520 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
25. Digital Signature

should meet the requirements of the AES-CBC block encryption algorithm. For more information on AES,
please refer to Chapter 19 AES Accelerator.

Step 2: Calculate 7 and M’ based on M.

Step 3: Extend Y, M, and ¥F, in order to get [Y]ao96, [4]4096, and [F]4096, respectively. Since the largest
operand length for Y, M, and 7 is 4096 bits, this step is only required for lengths smaller than 4096 bits.

Step 4: Calculate MD authentication code using the SHA-256 algorithm:
[MD]256 = SHA256 ( [¥] 4096|| [7 ]4096|| [F]4096| |[44’] 321 |[]32I|[7V ]128)

Step 5: Build [P]12672 = ( [¥]aoge|| [4 ]4096! |[F]4096| |Z P2561] [A4’]321| [E]321|[B]ea), where [G]ea is a PKCS#7
padding value, i.e., a 64-bit string [Ox0O808080808080808])¢4 that is composed of eight bytes (value =
0x08). The purpose of [8]64 is to make the bit length of P a multiple of 128.

Step 6: Calculate C = [Ci 2672 = AES-CBC-ENC ([Plize72, [DS_K EY |as6, [IV ]128), where C is the
ciphertext that includes RSA operands Y, M, 7, M’, and L as well as the MD authentication code and
[Ble4. DS_K EY is derived from the HM AC_K EY stored in eFuse, as described above in Section 25.3.4.

25.3.5 DS Operation at the Hardware Level
The hardware operation is triggered each time a Digital Signature needs to be calculated. The inputs are the
pre-generated private key ciphertext C, a unique message X, and /V.

The DS operation at the hardware level is a reverse process of preparing C' described in Section 25.3.4. The
hardware operation can be divided into the following three stages.

1.

Decryption: Step 7 and 8

The decryption process is the reverse of Step 6. The DS peripheral will call AES accelerator to decrypt C in
CBC block mode and get the resulted plaintext. The decryption process can be represented by P =
AES-CBC-DEC (C, DS_KEY, IV), where IV (i.e., [[V]128) is defined by users. [DS_K EY ]a56 is provided
by HMAC module, derived from HM AC_K EY stored in eFuse. [D.S_K EY ]256 is not readable by
software.

With P, the DS peripheral can work out [Y]4096, [M]ao96, [F]4096, [M!’]32, [L]32, MD authentication code,
and the padding value [3]¢4. This process is the reverse of Step 5.

2. Check: Step 9 and 10
The DS peripheral will perform two check operations: MD check and padding check. Padding check is not
shown in Figure 25-1, as it happens at the same time with MD check.
¢ MD check: The DS peripheral calls SHA-256 to get the hash value [CALC_M D]256. This step is the
reverse of Step 4. Then, [CALC_M D]os6 is compared against [MM D]osg. Only when the two match,
MD check passes.
e Padding check: The DS peripheral checks if [3]é4 complies with the aforementioned PKCS#7 format.
Only when [8]g4 complies with the format, padding check passes.
lf MD check passes, the DS peripheral will perform subsequent operations, otherwise, it will not. If padding
check fails, an error bit is set in the query register, but it does not affect the subsequent operations.
3. Calculation: Step 11 and 12
Espressif Systems 521 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
25. Digital Signature

 

The DS peripheral treats X, Y, M, and? as big numbers. With M’, all operands to perform XY mod M
are in place. The operand length is defined by L. The DS peripheral will get the signed result 7 by calling
RSA to perform Z = X¥ mod M.

25.3.6 DS Operation at the Software Level
The following software steps should be followed each time a Digital Signature needs to be calculated. The inputs

are the pre-generated private key ciphertext C, a unique message X, and /V. These software steps trigger the

hardware steps described in Section 25.3.5.

1.

2.

9.

Activate the DS peripheral: Write 1 to DS_SET_START_REG.
Check if DS_K EY is ready: Poll DS_QUERY_BUSY_REG until it reads 0.

lf DS_QUERY_BUSY_REG does not read 0 after approximately 1 ms, it indicates a problem with HMAC
initialization. In such case, software can read register DS_QUERY_KEY_WRONG_REG to get more
information.

° If DS_ QUERY_KEY_WRONG_REG reads 0, it indicates that HMAC peripheral was not activated.

© If DS_QUERY_KEY_WRONG_REG reads any value from 1 to 15, it indicates that HMAC was
activated, but the DS peripheral did not successfully receive the DS_K EY value from the HMAC
peripheral. This may indicate that the HMAC operation was interrupted due to a software concurrency
problem.

. Configure register: Write IV block to register DS_IV_m_REG (m: 0-8). For more information on FV block,

please refer to Chapter 19 AES Accelerator.

. Write X to memory block DS_X_MEM: Write X; (i € [0,) 9 N) to memory block DS_X_MEM whose

capacity is 128 words. Each word can store one base-b digit. The memory block uses the little endian
format for storage, i.e., the least significant digit of the operand is in the lowest address. Words in
DS_X_MEM block after the configured length of X (N bits, as described in Section 25.3.2) are ignored.

. Write C to memory block DS_C_ MEM: Write C; (2 € [0, 396) 7 N) to memory block DS_C_MEM whose

capacity is 896 words. Each word can store one base-b digit.

. Start DS operation: Write 1 to register DS_SET_ME_REG.
. Wait for the operation to be completed: Poll register DS_QUERY_BUSY_REG until it reads 0.

. Query check result: Read register DS_QUERY_CHECK_REG and determine the subsequent operations

based on the return value.

® If the value is 0, it indicates that both padding check and MD check pass. Users can continue to get
the signed result Z.

® If the value is 1, it indicates that the padding check passes but MD check fails. The signed result Z is
invalid. The operation would resume directly from Step 10.

® If the value is 2, it indicates that the padding check fails but MD check passes. Users can continue to
get the signed result Z.

® If the value is 8, it indicates that both padding check and MD check fail. The signed result Z is invalid.
The operation would resume directly from Step 10.

Read the signed result: Read the signed result Z; (2 € {0, 1, 2...,}) from memory block DS_Z_ MEM. The
memory block stores Z in little-endian byte order.

Espressif Systems 522 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
25. Digital Signature

 

10. Exit the operation: Write 1 to DS_SET_FINISH_REG, then poll DS_QUERY_BUSY_REG until it reads 0.

After the operation, all the input/output registers and memory blocks are cleared.

25.4 Base Address

Users can access the DS peripheral with two base addresses, which can be seen in Table 180. For more
information about accessing peripherals from different buses please see Chapter 1 System and Memory.

Table 130: Base Address

 

 

 

Bus to Access Peripheral | Base Address
PeriBUS1 OxSF43D000
PeriBUS2 Ox6003D000

 

 

 

 

25.5 Memory Blocks

Both the starting address and ending address in the following table are relative to the DS peripheral base
addresses provided in Section 25.4.

 

 

 

 

Name Description Size (byte) | Starting Address | Ending Address | Access
DS_C_MEM Memory block C 1584 Ox0000 Ox062F WO
DS_X_MEM Memory block X 512 Ox0800 OxO9FF WO
DS_Z MEM Memory block Z 512 OxO0A00 OxOBFF RO

 

 

 

 

 

 

 

 

25.6 Register Summary
The addresses in the following table are relative to the DS peripheral base addresses provided in Section
25.4,

 

Name | Description Address | Access

 

Configuration Registers

 

 

 

 

DS_IV_0_REG IV block data Ox0630 WO
DS_IV_1_REG IV block data 0x0634 WO
DS_IV_2_REG IV block data Ox0638 WO
DS_IV_38_REG IV block data Ox063C WO

 

Status/Control Registers
DS_SET_START_REG
DS_SET_ME_REG
DS_SET_FINISH_REG

 

OxOE0O WO
OxOE04 WO
OxOE08 WO

Activates the DS peripheral

 

Starts DS operation

 

Ends DS operation

 

 

 

 

 

 

DS_QUERY_BUSY_REG Status of the DS OxOEOC RO
DS_QUERY_KEY_WRONG_REG Checks the reason why DS_K EY is not ready | OxOE10 RO
DS_QUERY_CHECK_REG Queries DS check result 0x0814 RO

 

Version Register
DS_DATE_REG

 

Version control egister 0x0820 W/R

 

 

 

Espressif Systems 523
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
25. Digital Signature

 

25.7 Registers

Register 25.1: DS_IV_m_REG (/n: 0-3) (0x0630+4*)

 

 

| 0x000000000 | Reset

 

DS_IV_m_REG (m: 0-3) IV block data. (WO)

Register 25.2: DS_SET_START_REG (0x0E00)

S
g® g
eC &’

[ Ts

 

 

joo 0000000900000 0000000 00 00 00 0 0 0 0] 0 Reset

 

DS_SET_START Write 1 to this register to activate the DS peripheral. (WO)

Register 25.3: DS_SET_ME_REG (0x0E04)

S
ay
&

[ [>|

jo0 0000000900000 0000000 00 090 090 0 0 0 0] 0 Reset

 

 

 

DS_SET_ME Write 1 to this register to start DS operation. (WO)

Register 25.4: DS_SET_FINISH_REG (Ox0E08)

S\
& on
é é

[ [>|

joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset

 

 

 

DS_SET_FINISH Write 1 to this register to end DS operation. (WO)

Espressif Systems 524 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
25. Digital Signature

 

Register 25.5: DS_QUERY_BUSY_REG (0x0E0C)

 

 

 

 

DS_QUERY_BUSY 1: The DS peripheral is busy; 0: The DS peripheral is idle. (RO)

Register 25.6: DS_QUERY_KEY_WRONG_REG (0x0E10)

 

 

 

 

 

©
Ss
SS
ee
sh 7
S S
s °
& one
[1 [s o|
joo 0 0000000000009 00900009000 00 9 x0 |Reset
DS_QUERY_KEY WRONG 1-15: HMAC was activated, but the DS peripheral did not successfully
receive the DS_K EY value from the HMAC peripheral. The biggest value is 15. 0: HMAC is not
activated. (RO)
Register 25.7: DS_QUERY_CHECK_REG (0x0E14)
Q
is
S SF
S9
eC 2° H"
[1 2 1 o

 

 

 

DS_PADDING_BAD_ 1: The padding check fails; 0: The padding check passes. (RO)

DS_MD_ERROR_ 1: The MD check fails; 0: The MD check passes. (RO)

Register 25.8: DS_DATE_REG (0x0E20)

 

 

& Ke
& Sv
© er
31 30] 29 o
0. 60 0x20190418 Reset

 

 

 

 

DS_DATE Version control register. (R/V)

Espressif Systems 525 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

26. HMAC Module

26.1 Overview

The Hash-based Message Authentication Code (HMAC) module computes Message Authentication Codes
(MACs) through Hash algorithms and keys as described in RFC 2104. The underlying hash algorithm is
SHA-256, and the 256-bit HMAC key is stored in an eFuse key block and can be configured as not readable by
software.

The HMAC module can be used in two modes - in "upstream” mode the HMAC message is supplied by the user
and the calculation result is read back by the user. In ”downstream” mode the HMAC module is used as a Key
Derivation Function (KDF) for other internal hardwares.

26.2 Main Features
® Standard HMAC-SHA-256 algorithm

* The hash result is only accessible by the configurable hardware peripheral (downstream mode)
* Supports identity verification challenge-response algorithms
* Supports Digital Signature peripheral (downstream mode)

* Supports re-enabling of Soft-Disabled JTAG (downstream mode)

26.3 Functional Description

26.3.1 Upstream Mode
In Upstream mode, the HMAC message is provided by the user and the result is read back by the user.

This allows the key stored in eFuse (can be configured as not readable by software) to become a shared secret
between the user and another party. Any challenge-response protocol that supports HMAC-SHA-256 can be
used in this way.

The generalized form of these protocols is as follows:

* Acalculates a unique nonce message M

* Asends MtoB

* B calculates HMAC (M, KEY) and sends to A

* A also calculates HMAC (M, KEY) internally

* A compares both results, If the same, then the identity of B is verified
To set up the key:

1. A 256-bit HMAC key is randomly generated and is programmed to an eFuse key block with corresponding
purpose eFuse set to EFUSE_KEY_PURPOSE_HMAC_UP. See Chapter 16 for details.

2. Configure the eFuse key block to be read protected, so software cannot read back the value. A copy of
this secret key should be kept by any other party that wants to authenticate this device.

To calculate an HMAC:

1. User initializes the HMAC module,and enter upstream mode.

Espressif Systems 526 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

2. User writes the correctly padded message to the peripheral, one block at a time.
3. User reads back the HMAC result from peripheral registers.

See Section 26.3.5 for detailed steps of this process.

26.3.2 Downstream JTAG Enable Mode

eFuse memory has two parameters to disable JTAG debugging: EFUSE_HARD_DIS_JTAG and
EFUSE_SOFT_DIS_JTAG. JTAG will be disabled permanently if the former is programmed to 1, and it will be
disabled temporarily if the latter is programmed to 1. See Chapter 16 for details.

The HMAC peripheral can be used to re-enable JIAG when EFUSE_SOFT_DIS_JTAG is programmed.
To set up the key:

1. A 256-bit HMAC key is randomly generated and is programmed to an eFuse key block with purpose set to
either EFUSE_KEY_PURPOSE_HMAC_DOWN_JTAG or EFUSE_KEY_PURPOSE_HMAC_DOWN_ALL. In
the latter case, the same key can be used for both DS and JTAG re-enable functions.

2. Configure the eFuse key block to be read protected, so software cannot read back the value. User stores
the randomly generated HMAC key in the process securely elsewhere.

3. Program the eFuse EFUSE_SOFT_DIS_JTAG to 1.
To re-enable JTAG:

1. User performs HMAC calculation on the 32-byte 0x00 locally using SHA-256 and the known random key,
and inputs this pre-calculated value into the registers
SYSTEM_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0 ~
SYSTEM_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_/7.

2. User enables the HMAC module, and enters downstream JTAG enable mode.

3. If the HMAC calculated result matches the value supplied in the registers
SYSTEM_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_0 ~
SYSTEM_CANCEL_EFUSE_DISABLE_JTAG_TEMPORARY_7, JTAG is re-enabled. Otherwise, JTAG
remains disabled.

4. JTAG remains the status in step 3 until the user writes 1 in register HMAC_SET_INVALIDATE_JTAG_REG,
or restarts the system.

See Section 26.3.5 for detailed steps of this process.

26.3.3 Downstream Digital Signature Mode
The Digital Signature (DS) module encrypts its parameters using AES-CBC. The HMAC module is used as a Key
Derivation Function (KDF) to derive the AES key used for this encryption.

To set up the key:

1. A 256-bit HMAC key is randomly generated and is programmed to an eFuse key block with purpose set to
either EFUSE_KEY_PURPOSE_HMAC_DOWN_DIGITAL_SIGNATURE or
EFUSE_KEY_PURPOSE_HMAC_DOWN_ALL. In the latter case, the same key can be used for both DS
and JTAG re-enable functions.

2. Configure the eFuse key block to be read protected, so software cannot read back the value. If necessary
a copy of the key can also be stored in a secure location.

Espressif Systems 527 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

Before using the DS module, software needs to enable the calculation task of HMAC module’s downstream DS
mode. The above calculation result will be used as the key when the DS mode performs the calculation task.
Consult the 25 chapter for details.

26.3.4 HMAC eFuse Configuration
The correct implementation of the HMAC module depends on whether the selected eFuse key block is
consistent with the configured HMAC function.

Configure HMAC Function

Currently, HMAC module supports three functions: JTAG re-enable in downstream mode, DS Key Derivation in
downstream mode, and HMAC calculation in upstream mode. Table 138 lists the configuration register value
corresponding to each function. The values corresponding to the function in use should be written into the
register HMAC_SET_PARA_ PURPOSE_REG (see Section 26.3.5).

Table 133: HMAC Function and Configuration Value

 

 

 

 

 

Functions Mode Type Value Description

JTAG Re-enable Downstream | 6 EFUSE_KEY_PURPOSE_HMAC_DOWN_JTAG

DS Key Derivation Downstream | 7 EFUSE_KEY_PURPOSE_HMAC_DOWN_DIGITAL_SIGNATURE
HMAC Calculation Upstream 8 EFUSE_KEY_PURPOSE_HMAC_UP

Both JTAG Re- | Downstream | 5 EFUSE_KEY_PURPOSE_HMAC_DOWN_ALL

enable and DS
KDF

 

 

 

 

 

 

Select eFuse Key Blocks

The eFuse controller provides six key blocks, KEYO ~ 5. To select a particular KEYn for HMAC module use at
runtime, user writes the number n into register HMVAC_SET_PARA_KEY_REG.

Note that the purpose of the key is also programmed into eFuse memory. Only when the configured HMAC
purpose matches the purpose defined in KEYn, will the HMAC module execute the configured
computation.

For more information see 16 chapter.

For example, suppose the user selects KEYS for the computation, and the value programmed in
KEY_PURPOSE_3 is 6 (EFUSE_KEY_PURPOSE_HMAC_DOWN_JTAG). Based on Table 133, KEYS is the key
used for JTAG restart. If the configured value of HMAC_SET_PARA_PURPOSE_REG is also 6, then the HMAC
peripheral will allow the JTAG start the computation of JTAG re-enable.

26.3.5 HMAC Process (Detailed)
The process to call HMAC in ESP32-S2 is as follows:

1. Enable HMAC module

(a) Enable the peripheral clock bits for HMAC and SHA peripherals, and clear the corresponding
peripheral reset bits.

(6) Write 1 into register HMAC_SET_START_REG.

2. Configure HMAC keys and key functions

Espressif Systems 528 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

(a) Write m representing key functions into register HMAC_SET_PARA_PURPOSE_REG. Correlation
between value m and key functions is shown in Table 55. Refer to Section 26.3.4.

(6) Select KEYn of eFuse memory as the key by writing n into register HMAC_SET_PARA_KEY_REG (n in
the range of 0 to 5). Refer to Section 26.3.4.

(c) Finish the configuration by writing 1 into register HMAC_SET_PARA_FINISH_REG.

(d) Read register HMAC_QUERY_ERROR_REG. Value of 1 means the selected key block does not
match the configured key purpose, and computation will not proceed. Value of O means the selected
key block matches the configured key purpose, and computation can proceed.

(e) Setting HMVAC_SET_PARA_ PURPOSE_REG to values other than 8 means HMAC module will operate
in downstream mode, proceed with Step 3. Setting value 8 means HMAC module will operate in
upstream mode, proceed with Step 4.

3. Downstream Mode

(a) Poll state register HMAC_QUERY_BUSY_REG. The register value of O means HMAC computation in
downstream mode is finished.

(b) In downstream mode, the result is used by JTAG module or DS module in the hardware. Users can
write 1 into register HVAC_SET_INVALIDATE_JTAG_REG to clean the result generated by JTAG key;
or can write 1 into register HMAC_SET_INVALIDATE_DS_REG to clean the result generated by digital
signature key.

(c) This is the end of the HMAC downstream operation.
4. Upstream Mode Transmit message block Block_n (n >= 1)
(a) Poll state register HMVAC_QUERY_BUSY_REG. Go to the next step when the value of the register is 0.

(6) Write 512-bit message block Block_n into register range HMAC_WDATA0~15_ REG. Then write 1 in
register HMAC_SET_MESSAGE_ONE_REG, and HMAC module will compute this message block.

(c) Poll state register HMVAC_QUERY_BUSY_REG. Go to the next step when the value of the register is 0.

(d) Subsequent message blocks are different, depending on whether the size of to-be-processed data is
a multiple of 512 bits.

® If the bit length of the message is a multiple of 512, there are three possible options:

i. If Block_n+1 exists, write 1 in register HMAC_SET_MESSAGE_ING_REG to make n = n+ 1,
then jump to step 4.(b).

i. If Block_n is the last block of the message, and user wishes to apply SHA padding through
hardware, write 1 in register HMAC_SET_MESSAGE_END_REG, then jump to step 6.

ili. If Block_n is the last block of the padded message, and the user has applied SHA padding in
software, write 1 in register HMVAC_SET_MESSAGE_PAD_REG, and jump to step 5.

® If the bit length of the message is not a multiple of 512, there are three possible options. Note that
in this case the user is required to apply SHA padding to the message, after which the padded
message length will be a multiple of 512 bits.

i. If Block_n is the only message block, n = 1, and Block_1 has included all padding bits, write
1 in register HMAC_ONE_BLOCK_REG, and then jump to step 6.

Espressif Systems 529 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

ii. If Block_n is the second last block of the padded message, write 1 in register
HMAC_SET_MESSAGE_PAD_REG, and jump to step 5.

iii, If Block_n is neither the last nor the second last message block, write 1 in register
HMAC_SET_MESSAGE_ING_REG and make n = n + 1, then jump to step 4.(b).

5. Apply SHA Padding to Message

(a) Users apply SHA padding to the final message block as described in Section 26.4.1, Write this block
in register HMAC_WDATA0~15_REG, then write 1 in register HMAC_SET_MESSAGE_ONE_REG.
HMAC module will compute the message block.

(6) Jump to step 6.

6. Read hash result in upstream mode
(a) Poll state register HMVAC_QUERY_BUSY_REG. Go to the next step when the value of the register is 0.
(6) Read hash result from register HMAC_RDATAO~7_REG.

(c) Write 1 in register HMAC_SET_RESULT_FINISH_REG to finish the computation.

 

Note:
The SHA accelerator can be called directly, or used internally by the DS module and the HMAC module. However, they
can not share the hardware resources simultaneously. Therefore, SHA module can not be called by CPU or DS module

 

 

when HMAC module is in use.

 

26.4 HMAC Algorithm Details

26.4.1. Padding Bits

HMAC module uses the SHA-256 hash algorithm. If the input message is not a multiple of 512 bits, the user
must apply SHA-256 padding algorithm in software. The SHA-256 padding algorithm is described here, and is
the same as “5.1 Padding the Message” of “FIPS PUB 180-4”.

As shown in Figure 26-1, suppose the length of the unpadded message is m bits. Padding steps are as
follows:

1. Append a single 1-bit “1” to the end of unpadded message;

2. Append k bits of value “O”, where k is the smallest non-negative number which satisfies
m+1+ k=448(mod512);

8. Append a 64-bit integer value as a binary block. The content of this block is the length of the the unpadded
message as a big-endian binary integer value m.

Bit sequence of data [2], 0,0,0...,0 |, Bit sequence of

 

 

 

 

 

 

 

 

 

 

 

 

Data length
XY 7 x J /
vO LJ Y~ YO
m bits 1 bit k bits 64 bits

m+1+k+64 = 512*n( n=1,2,3,...,2°5-1 )

 

 

 

Figure 26-1. HMAC SHA-256 Padding Diagram

Espressif Systems 530 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

In downstream mode, there is no need for users to input any message data or apply padding. In upstream
mode, if the total number of bits in the unpadded message is a multiple of 512, users can choose to configure
hardware to apply SHA padding. If the total number of bits in the unpadded message is not a multiple of 512,
SHA padding must be applied by the user. See Section 26.3.5 for the steps involved.

26.4.2 HMAC Algorithm Structure
The Structure of HMAC algorithm as implemented in the HMAC module is shown in Figure 26-2. This is the

standard HMAC algorithm as described in RFC 2104.

 

 

Key (K) Paddedkey(K,) | |  ipad — |

 

 

 

 

 

 

$1 Message

 

 

 

 

 

Vv
1024-bit |

 

 

 

 

 

SHA-256

Figure 26-2. HMAC Structure Schematic Diagram

 

 

 

In Figure 26-2,
1. ipad is 512-bit message block composed of sixty-four 0x36 byte.
2. opad is 512-bit message block composed of sixty-four Ox5c byte.

HMAC module appends 256-bit O sequence after the bit sequence of 256-bit key k, and gets 512-bit Ko.
Afterwards, HMAC module XORs Ko with ipad to get 512-bit S1. Then, HMAC module appends the input
message which is a multiple of 512 after 512-bit S1, and processes SHA-256 algorithm to get 256-bit H1.

HMAC module appends the 256-bit SHA-256 hash result to the 512-bit S2 value, which is calculated by XOR
between Ky and opad, this produces a 768-bit sequence. Then, HMAC module uses SHA padding algorithm
described in Section 26.4.1 to pad 768-bit sequence into 1024-bit sequence, and applies SHA-256 algorithm to
get the final hash result.

26.5 Base Address

Users can access HMAC module with base address, which can be seen in the following table.

Espressif Systems 531 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

Table 134: HMAC Base Address

 

 

 

 

Base Address Address Value
PeriBUS1 Ox3F43E000
PeriBUS2 Ox6003E000

 

 

 

26.6 Register Summary

The addresses in the following table are relative to the system registers base addresses provided in Section

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

26.5,
Name | Description Address | Access
Control/Status Registers
HMAC_SET_START_REG HMAC start control register 0x0040 | WO
HMAC_SET_PARA_FINISH_REG HMAC configuration completion register O0x004C | WO
HMAC_SET_MESSAGE_ONE_REG HMAC one message control register O0x0050 | WO
HMAC_SET_MESSAGE_ING_REG HMAC message continue register 0x0054 | WO
HMAC_SET_MESSAGE_END_REG HMAC message end register 0x0058 | WO
HMAC_SET_RESULT_FINISH_REG HMAC read result completion register Ox005C | WO
HMAC_SET_INVALIDATE_JTAG_REG Invalidate JTAG result register Ox0060 | WO
HMAC_SET_INVALIDATE_DS_REG Invalidate cigital signature result register O0x0064 | WO
HMAC_QUERY_ERROR_REG The matching result between key and purpose | Ox0068 | RO

user configured

HMAC_QUERY_BUSY_REG The busy state of HMAC module Ox006C | RO
configuration Registers
HMAC_SET_PARA_PURPOSE_REG HMAC parameter configuration register 0x0044 | WO
HMAC_SET_PARA_KEY_REG HMAC key configuration register 0x0048 | WO
HMAC Message Block
HMAC_WR_MESSAGE_O_REG Message register 0 Ox0080 | WO
HMAC_WR_MESSAGE_1_REG Message register 1 0x0084 | WO
HMAC_WR_MESSAGE_2_REG Message register 2 0x0088 | WO
HMAC_WR_MESSAGE_3_REG Message register 3 Ox008C | WO
HMAC_WR_MESSAGE_4_REG Message register 4 Ox0090 | WO
HMAC_WR_MESSAGE_5_ REG Message register 5 0x0094 | WO
HMAC_WR_MESSAGE_6_REG Message register 6 0x0098 | WO
HMAC_WR_MESSAGE_7_REG Message register 7 Ox009C | WO
HMAC_WR_MESSAGE_8 REG Message register 8 OxO0AO | WO
HMAC_WR_MESSAGE_9 REG Message register 9 Ox00A4 | WO
HMAC_WR_MESSAGE_10_REG Message register 10 OxO0A8 | WO
HMAC_WR_MESSAGE_11_REG Message register 11 OxO0AC | WO
HMAC_WR_MESSAGE_12_REG Message register 12 OxOOBO | WO
HMAC_WR_MESSAGE_13_REG Message register 13 Ox00B4 | WO
HMAC_WR_MESSAGE_14_REG Message register 14 Ox00B8 | WO
HMAC_WR_MESSAGE_15_REG Message register 15 OxOOBC | WO
HMAC Upstream Result
HMAC_RD_RESULT_0_REG Hash result register 0 | oxooco | RO

 

 

Espressif Systems

582

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
26. HMAC Module

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
HMAC_RD_RESULT_1_REG Hash result register 1 Ox00C4 | RO
HMAC_RD_RESULT_2_ REG Hash result register 2 Ox00C8 | RO
HMAC_RD_RESULT_3_REG Hash result register 3 Ox00CC | RO
HMAC_RD_RESULT_4 REG Hash result register 4 OxO00DO | RO
HMAC_RD_RESULT_5 REG Hash result register 5 Ox00D4 | RO
HMAC_RD_RESULT_6_REG Hash result register 6 Ox00D8 | RO
HMAC_RD_RESULT_7_REG Hash result register 7 OxO0DC | RO
Control/Status registers

HMAC_SET_MESSAGE_PAD_REG Software padding register OxOOFO | WO
HMAC_ONE_BLOCK_REG One block message register OxO0F4 | WO
Version Register

HMAC_DATE_REG Version control register OxOOF8 | RAV

 

 

 

26.7 Registers

Register 26.1: HMAC_SET_START_REG (0x0040)

 

 

 

 

 

 

 

 

A
A
oS
& Sf
& ww
lf if
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
HMAC_SET_START Set this bit to enable HMAC. (WO)
Register 26.2: HMAC_SET_PARA_FINISH_REG (0x004C)
SS
e
& Sf
EF ww
lf if
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
HMAC _SET_PARA_END Set this bit to finish HMAC configuration. (WO)
Espressif Systems 533 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
26. HMAC Module

 

Register 26.3: HMAC_SET_MESSAGE_ONE_REG (0x0050)

 

E

 

joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset

 

HMAC SET _TEXT_ONE Call SHA to calculate one message block. (WO)

Register 26.4: HMAC_SET_MESSAGE_ING_REG (0x0054)

S
&
s

O
Se

 

E

 

jo0 0000090090000 09 09009 009 00 09 00 0 0 0 0] 0 Reset

 

HMAC _SET_TEXT_ING Set this bit to show there are still some message blocks to be processed.

(WO)

Register 26.5: HMAC_SET_MESSAGE_END_REG (0x0058)

S
&
s

O
Se

 

E

 

joo 0000000900000 0000000 00 00 00 0 0 0 0] 0 Reset

 

HMAC _SET_TEXT_END Set this bit to start hardware padding. (WO)

Espressif Systems

534 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
26. HMAC Module

 

Register 26.6: HMAC_SET_RESULT_FINISH_REG (0x005C)

 

 

 

 

 

 

 

 

©
aS
So
$
& Sf
ee
& »
[a1 1 0 |
joo 0000000900000 0000000 00 00 00 0 0 0 0] 0 Reset
HMAC SET RESULT_END Set this bit to end upstream and clear the calculation result. (WO)
Register 26.7: HMAC_SET_INVALIDATE_JTAG_REG (0x0060)
@
¥
x
e
=
& &
& ww
[1 1 0 |
joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset
HMAC_SET_INVALIDATE_JTAG Set this bit to clear calculation results in JTAG re-enable function
under downstream mode. (WO)
Register 26.8: HMAC_SET_INVALIDATE_DS_REG (0x0064)
&
x
x
S
wey
s
S &
cs OF
& ww

 

 

 

 

HMAC_SET_INVALIDATE_DS Set this bit to clear calculation results in DS function under down-
stream mode. (WO)

Espressif Systems 535 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

Register 26.9: HMAC_QUERY_ERROR_REG (0x0068)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

RS
&
Oo
ee
NS)
oe oF
&
[1 ‘]o |
joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset
HMAC _QUREY_CHECK HMAC error status. 0: HMAC key and purpose match. 1: error. (RO)
Register 26.10: HMAC_QUERY_BUSY_REG (0x006C)
a
AZ
©
& oo
ES we
31 1 oO
°o000000000000000000000808~ 000 0 0 0 0 010 |Reset
HMAC_BUSY_STATE The state of HMAC. 1’b0: idle. 1761: busy. (RO)
Register 26.11: HMAC_SET_PARA_PURPOSE_REG (0x0044)
&
x’
&
es
& <<
&
[1 [s o|
joo 0 0000000000009 00900009000 00 9 0 |Reset
HMAC_PURPOSE_SET Set HMAC purpose. (WO)
Register 26.12: HMAC_SET_PARA_KEY_REG (0x0048)
&
S er
& oe"
& Ss
[1 3[2 o|
joo 0 0 0000000000090 0000009 00 0 0 0 of 0 Reset
HMAC_KEY_SET Select HMAC key. (WO)
Espressif Systems 536 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
26. HMAC Module

 

Register 26.13: HMAC_WR_MESSAGE_»_REG (7: 0-15) (0x0080+4*/)

 

 

| 0 | Reset

 

HMAC _WDATA_» Store the nth 32-bit of message. (WO)

Register 26.14: HMAC_RD_RESULT_n_REG (: 0-7) (0x00C0+4*7)

 

 

| 0 | Reset

 

HMAC_RDATA_» Read the nth 32-bit of hash result. (RO)

Register 26.15: HMAC_SET_MESSAGE_PAD_REG (0x00F0)

 

 

 

 

‘ ©
& Se
&
[1 if o |
jo0 0000090090000 09 09009 009 00 09 00 0 0 0 0] 0 Reset
HMAC _SET_TEXT_PAD Set this bit to let software do padding job. (WO)
Register 26.16: HMAC_ONE_BLOCK_REG (0x00F4)
x
LY
xX’
9
& &
x
&

 

[ [>|

joo 0000000000000 000000 000090 00 0 0 0 0] 0 Reset

 

 

HMAC SET ONE BLOCK Set this bit to show no padding is required. (WO)

Espressif Systems 537 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
26. HMAC Module

 

Register 26.17: HMAC_DATE_REG (0x00F8)

 

 

 

 

x
& So
& ~~
| 31 30 | 29 0 |
[0 o 0x20190402 |Reset
HMAC DATE Store HMAC version information. (RAV)
Espressif Systems 538 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

27. ULP Coprocessor

27.1 Overview

The ULP coprocessor is an ultra-low-power processor that remains powered on when the chip is in Deep-sleep
(see Chapter 28 Low-power Management). Hence, users can store in RTC memory a program for the ULP
coprocessor to access peripheral devices, internal sensors and RTC registers during Deep-sleep.

In power-sensitive scenarios, the main CPU goes to sleep mode to lower power consumption. Meanwhile, the
coprocessor is woken up by ULP timer, and then monitors the external environment or interacts with the external
circuit by controlling peripheral devices such as RTCIO, RTC I?C, SAR ADC, or temperature sensor (TSENS). The
coprocessor wakes the main CPU up once a wakeup condition is reached.

 

 

 

 

 

ESP32-S2
Enable by ULP or Main CPU
Enable with) a= ULP Wakeup Wakeup Main
RTC GPIO Timer | ULP ~ CPU

 

 

 

 

 

 

 

L TSENS

 

 

 

 

 

 

 

Iz) |g
ol o/=
OS) alo
2] 9/8
4

-_

iY

Monitor / Control

Figure 27-1. ULP Coprocessor Overview

ESP32-S2 has two ULP coprocessors, with one based on RISC-V instruction set architecture (ULP-RISC-V) and
the other on finite state machine (ULP-FSM). Users can choose between the two coprocessors depending on
their needs.

27.2 Features

* Access up to 8 KB of SRAM RTC slow memory for instructions and data
* Clocked with 8 MHz RTC_FAST_CLK

® Support working in normal mode and in monitor mode

e Wake up the CPU or send an interrupt to the CPU

* Access peripherals, internal sensors and RTC registers

ULP-FSM and ULP-RISC-V can not be used simultaneously. Users can only choose one of them as the ULP
coprocessor of ESP32-S2. The differences between the two coprocessors are shown in the table below.

Espressif Systems 539 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

 

 

 

 

Coprocessors
Feature
ULP-FSM ULP-RISC-V
Memory (RTC Slow Memory) 8 KB
Work Clock Frequency 8 MHz
Wakeup Source ULP Timer

 

Assist the main CPU to complete some tasks
after the system is woken up.

Normal Mode
Work Mode

 

. Control sensors to do tasks such as monitoring
Monitor Mode

 

environment, when the system is in sleep.
ADCO/ADC 1
DACO/DAC1

Control Low-Power Peripherals RTC PC

RTC GPIO
Touch Sensor

 

 

 

 

 

 

Temperature Sensor
Architecture Programmable FSM RISC-V
Development Special instruction set | Standard C compiler

 

 

 

 

 

 

 

Table 136: Comparison of the Two Coprocessors

ULP coprocessor can access the modules in RTC domain via RTC registers. In many cases the ULP
coprocessor can be a good supplement to, or replacement of, the main CPU, especially for power-sensitive
applications. Figure 27-2 shows the overall layout of ESP382-S2 coprocessor.

Espressif Systems 540 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

 

APB BUS

 

 

 

ridge

 

fo

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

RTC CNTL REG
RTC Memory RTC IO REG
Arbiter
12C CTRL SARADC REG
RTC l2C REG

 

 

 

 

 

 

 

 

 

 

TSENS CTRL

 

 

ULP-FSM_ |_,J aux [e+] ULP-RISC-V

 

 

 

 

 

 

 

 

SAR CTRL

 

 

 

 

 

 

 

 

ULP Timer

 

 

 

 

 

ESP32-S2 RTC

 

Figure 27-2. ULP Coprocessor Diagram

27.3 Programming Workflow

The ULP-RISC-V is intended for programming using C language. The program in C is then compiled to
RV32IMC standard instruction code. The ULP-FSM is using custom instructions normally not supported by
high-level programming language. Users develop their programs using ULP-FSM instructions (see Section
27.5.2).

27.4 ULP Coprocessor Workflow
ULP coprocessor is designed to operate independently of the CPU, while the CPU is either in sleep or
running.

In a typical power-saving scenario, the chip goes to Deep-sleep mode to lower power consumption. Before
setting the chip to sleep mode, users should complete the following operations.

1. Flash the program to be executed by ULP coprocessor into RTC slow memory.

2. Select the working ULP coprocessor by configuring the register RTC_CNTL_COCPU_SEL.
* 0: select ULP-RISC-V
* 1: select ULP-FSM

3. Set sleep cycles for the timer by configuring RTC_CNTL_ULP_CP_TIMER_1_REG.

Espressif Systems 541 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

     
    

User

 

Instruction
Code

Instruction Set
C Language ==» (RV32IMC) =» ULP-RISC-V

 

User Instruction

Code

 

 

Instruction Set — »
ULP-FSM
(ULP-FSM)

 

Figure 27-3. Programing Workflow

4. Enable the timer by software or by RTC GPIO;
* By software: set the register RTC_CNTL_ULP_CP_SLP_TIMER_EN.
* By RTC GPIO: set the register RTC_CNTL_ULP_CP_GPIO_WAKEUP_ENA.
5. Set the system into sleep mode.
When the system is in Deep-sleep mode:

1. The timer periodically sets the low-power controller (see Chapter 28 Low-power Management) to Monitor
mode and then wakes up the coprocessor.

2. Coprocessor executes some necessary operations, such as monitoring external environment via
low-power sensors.

3. After the operations are finished, the system goes back to Deep-sleep mode.
4. ULP coprocessor goes back to halt mode and waits for next wakeup.

In monitor mode, ULP coprocessor is woken up and goes to halt as shown in Figure 27-4.

 

 

 

 

 

 

 

Enable (tt 4}
Disable
. eye )
Timer
sn @) |e s
Run
ULP Har HALT ; Run | HALT Run HALT “I HALT 5 Rn
time

 

 

 

 

 

 

 

 

 

Figure 27-4. Sample of a ULP Operation Sequence

1. Enable the timer and the timer starts counting.

Espressif Systems 542 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

2. The timer expires and wakes up the ULP coprocessor. ULP coprocessor starts running and executes the
program flashed in RTC slow memory.

3. ULP coprocessor goes to halt and the timer starts counting again.
* Put ULP-RISC-V into HALT: set the register RTC_CNTL_COCPU_DONE,
e Put ULP-FSM into HALT: execute HALT instruction.

4. Disable the timer by ULP program or by software. The system exits from monitor mode.
* Disabled by software: clear the register RTC_CNTL_ULP_CP_SLP_TIMER_EN.

* Disabled by RTC GPIO: clear the register RTC_CNTL_ULP_CP_GPIO_WAKEUP_ENA, and set the
register RTC_CNTL_ULP_CP_GPIO_WAKEUP_CLR.

Note:

® If the timer is enabled by software (RTC GPIO), it should be disabled by software (RTC GPIQ).

* Before setting ULP-RISC-V to HALT, users should configure the register RTC_CNTL_COCPU_DONE first,
therefore, it is recommended to end the flashed program with the following pattern:

— Set the register RTC_CNTL_COCPU_DONE to end the operation of ULP-RISC-V and put it into halt;
— Set the register RTC_CNTL_COCPU_SHUT_RESET_EN to reset ULP-RISC-V.
Enough time is reserved for the ULP-RISC-V to complete the operations above before it goes to halt.

The relationship between the signals and registers is shown in Figure 27-5.

Espressif Systems 543 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Soc — Main CPU a
PQ
a —
D EF
E 2
Wakeup E 3
Soc E i
ULP
WAKE ULP Timer
Enable
REG_WR > RTC_CNTL_ULP_CP_SLP_TIMER_EN
> Set Period
RTC_CNTL_ULP_CP_TIMER_SLP_CYCLE
HALT -——————————__| Start
Run Timer Expired
PT c= RTC_CNTL_ULP_CP_PC_INIT]

 

Figure 27-5. Control of ULP Program Execution

27.5 ULP-FSM

27.5.1 Features
ULP-FSM is a programmable finite state machine that can work while the main CPU is in Deep-sleep. ULP-FSM

supports instructions for complex logic and arithmetic operations, and also provides dedicated instructions for
RTC controllers or peripherals. ULP-FSM can access up to 8 KB of SRAM RTC slow memory (accessible by the
CPU) for instructions and data. Hence, such memory is usually used to store instructions and share data
between the ULP coprocessor and the CPU. ULP-FSM can be stopped by running HALT instruction.

ULP-FSM has the following features.

* Provide four 16-bit general-purpose registers (RO, R1, R2, and R3) for manipulating data and accessing

memory.

* Provide one 8-bit stage count register (Stage_cnt) which can be manipulated by ALU and used in JUMP

instructions.

* Support built-in instructions specially for direct control of low-power peripherals, such as SAR ADC and

temperature sensor.

27.5.2 Instruction Set
ULP-FSM supports the following instructions.

* ALU: perform arithmetic and logic operations
e LD, ST, REG_RD and REG_WR: load and store data
e JUMP: jump to a certain address

© WAIT/HALT: manage program execution

Espressif Systems 544 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

e¢ WAKE: wake up CPU or communicate with the CPU

* TSENS and ADC: take measurements
The format of ULP-FSM instructions is shown in Figure 27-6.
&

sO
Se eS

 

 

 

Figure 27-6. ULP-FSM Instruction Format

An instruction, which has one OpCode, can perform various operations, depending on the setting of Operands
bits. A good example is the ALU instruction, which is able to perform 10 arithmetic and logic operations; or the
JUMP instruction, which may be conditional or unconditional, absolute or relative.

Each instruction has a fixed width of 32 bits. A series of instructions can make a program be executed by the
coprocessor. The execution flow inside the program uses 32-bit addressing. The program is stored ina
dedicated region called Slow Memory, which is visible to the main CPU as one that has an address range of
Ox5000_0000 to Ox5000_1FFF (8 KB).

27.5.2.1. ALU - Perform Arithmetic and Logic Operations

ALU (Arithmetic and Logic Unit) performs arithmetic and logic operations on values stored in ULP coprocessor
registers, and on immediate values stored in the instruction itself. The following operations are supported.

* Arithmetic: ADD and SUB

* Logic: AND and OR

* Bit shifting: LSH and RSH

* Moving data to register: MOVE

* PC register operations - STAGE_RST, STAGE_INC, and STAGE_DEC

The ALU instruction, which has one OpCode (7), can perform various arithmetic and logic operations, depending
on the setting of the instruction bits [27:21].

Operations Among Registers
>
’ S So >

¥ e& e&

 

 

 

Figure 27-7. Instruction Type — ALU for Operations Among Registers

When bits [27:26] of the instruction in Figure 27-7 are set to 0, ALU performs operations on the data stored in
ULP-FSM registers R[O-3]. The types of operations depend on the setting of the instruction bits ALU_sel [24:21]
presented in Table 137.

Espressif Systems 545 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Operand Description - see Figure 27-7

Rast Register R[0-3], destination
Rsrct Register R[O-3], source
Rsrc2 Register R[O-3], source

ALU_sel — ALU Operation

 

ALU_sel Instruction Operation Description
0 ADD Rast = Rsrc? + Rsrc2 Add to register
1 SUB Rast = Rsrc? - Rsrc2 Subtract from register
2 AND Rdst = Rsrc? & Rsrc2 Logical AND of two operands
3 OR Rdst = Rsrc7 | Rsrc2 Logical OR of two operands
4 MOVE Rast = Rsrc? Move to register
5 LSH Rost = Rsrc1 << Rsrc2 Logical shift left
6 RSH Rost = Rsrcl >> Rsrc2 Logical shift right

Table 137: ALU Operations Among Registers

Note:
* ADD or SUB operations can be used to set or clear the overflow flag in ALU.
* All ALU operations can be used to set or clear the zero flag in ALU.

Operations with Immediate Value

>
sf
2 €

31 28]27 26] 25 | 24 21} 20 | 19 413 241 °

 

 

 

 

 

 

 

 

 

 

 

 

Figure 27-8. Instruction Type — ALU for Operations with Immediate Value

When bits [27:26] of the instruction in Figure 27-8 are set to 1, ALU performs operations using register R[O-3] and
the immediate value stored in instruction bits [19:4]. The types of operations depend on the setting of the
instruction bits ALU_sel[24:21] presented in Table 138.

Operand Description - see Figure 27-8

Rast Register R[0-3], destination
Rsrct Register R[O-3], source
Imm 16-bit signed immediate value

ALU_sel — ALU Operation

Espressif Systems 546 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

 

ALU_sel Instruction Operation Description
0 ADD Rdst =Rsrcit +imm Add to register
1 SUB Rast = Rsrc7 - Imm Subtract from register
2 AND Rast = Rsrc? & lmm Logical AND of two operands
3 OR Rast = Resrc? | imm Logical OR of two operands
4 MOVE Rast =imm Move to register
5 LSH Rdst = Resrct << imm Logical shift left
6 RSH Rdst = Rsrct >> Imm _— Logical shift right

Table 138: ALU Operations with Immediate Value

Note:
* ADD or SUB operations can be used to set or clear the overflow flag in ALU.
* All ALU operations can be used to set or clear the zero flag in ALU.

Operations with Stage Count Register

&
yy’
r

 

[1 as [27 2s] a5 [24 a | 20 wu [3 o|

[7 Jet | | | |

Figure 27-9. Instruction Type — ALU for Operations with Stage Count Register

 

 

ALU is also able to increment or decrement by a given value, or reset the 8-bit register Stage_cnt. To do so, bits
[27:26] of instruction in Figure 27-9 should be set to 2. The type of operation depends on the setting of the
instruction bits ALU_sel[24:21] presented in Table 27-9. The Stage_cnt is a separate register and is not a part of
the instruction in Figure 27-9.

Operand Description - see Figure 27-9

Imm 8-bit signed immediate value

ALU _sel ALU Operation

Stage_cnt Stage count register, a 8-bit separate register used to store variables, such as loop index

 

ALU sel Instruction Operation Description
0 STAGE_INC — Stage_cnt = Stage_cnt+imm__ |ncrement stage count register
1 STAGE_DEC  Siage_cnt = Stage_cnt-imm Decrement stage count register
2 STAGE_RST — Stage_cnt = 0 Reset stage count register

Table 139: ALU Operations with Stage Count Register

Note: This instruction is mainly used with JUMPS instruction based on the stage count register to form a stage
count for-loop. For the usage, please refer to the following pseudocode:

Espressif Systems 547 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

STAGE_RST // Clear stage count register
STAGE_INC // stage count register ++
ff // loop body, containing n instructions

JUMPS (step =n, cond = 0, threshold =m) _// If the value of stage count register is less than m, then jump to
STAGE_INC, otherwise jump out of the loop. By such way, a cumulative for-loop with threshold m is implemented.

27.5.2.2 ST -Store Data in Memory

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Ss & Oo s\
wy o> & RG
SS? & SS ES
31 28] 27 26 25 | 24 21] 20 10 9 8 7 6 5 4/3 21 0
6
Figure 27-10. Instruction Type - ST
Operand Description - see Figure 27-10
Rast Register R[0-3], address of the destination, expressed in 32-bit words
Rsrc Register R[0-3], 16-bit value to store
label Data label, 2-bit user defined unsigned value
upper 0: write the low half-word; 1: write the high half-word
wr_way 0: write the full-word; 1: with the label; 3: without the label
offset 11-bit signed value, expressed in 32-bit words
wr_auto Enable automatic storage mode
offset_set Offset enable bit.
0: Do not configure the offset for automatic storage mode.
1: Configure the offset for automatic storage mode.
manul_en Enable manual storage mode
Automatic Storage Mode
x
[1 2a 27 [2 a|2 1o[» o|
a | | |
Figure 27-11. Instruction Type - Offset in Automatic Storage Mode (ST-OFFSET)
Operand Description - see Figure 27-11
offset Initial address offset, 11-bit signed value, expressed in 32-bit words
eS
£ SC SE ES

 

 

 

Figure 27-12. Instruction Type - Data Storage in Automatic Storage Mode (ST-AUTO-DATA)

Espressif Systems 548 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Operand Description - See Figure 27-12

Rast Register R[O-3], address of the destination, expressed in 32-bit words
Rsrc Register R[O-3], 16-bit value to store
label Data label, 2-bit user defined unsigned value

wr_way 0: write the fullword; 1: with the label; 3: without the label
Description
This mode is used to access continuous addresses. Before using this mode for the first time, please configure
the initial address using ST-OFFSET instruction. Executing the instruction ST-AUTO-DATA will store the 16-bit

data in Asrc into the memory address Adst + Offset, see Table 140. Write_cnt here indicates the times of the
instruction ST-AUTO-DATA executed.

 

wr_way write cnt Store Data Operation

0 * Mem [Rast + Offset]{31:0} ={PC[10:0], 5’bO, Rsrc[15:0]} Write full-word, including
the pointer and the data

1 odd Mem [Rast + Offset]{15:0} = {Label[1:0],Rscr[13:0]} Store the data with label
in the low half-word

1 even Mem [Rast + Offset]{31:16} = {Label[1:0],Rscr[13:0]} Store the data with label
in the high half-word

3 odd Mem [Rast + Offset]{15:0} = Rscr[15:0}} Store the data without label
in the low half-word

3 even Mem [Rast + Offset]{31:16} = Rscr[1 5:0] Store the data without label

in the high half-word

Table 140: Data Storage Type - Automatic Storage Mode

Note:

¢ When full-word is written, the offset will be automatically incremented by 1 after each ST-AUTO-DATA
execution.

* When half-word is written (low half-word first), the offset will be automatically incremented by 1 after twice
ST-AUTO-DATA execution.

® This instruction can only access 32-bit memory words.

® The ’Mem’ written is the RTC_SLOW_MEM memory. Address 0, as seen by the ULP coprocessor,
corresponds to address Ox50000000, as seen by the main CPU.

Manual Storage Mode

 

 

 

 

eS
< ww s os & S
[a1 2s] 27 as | aa a1 | 20 w]e fe i]s [s [3 afi o|
[Los | 4 | | }{ {] | | |
Figure 27-13. Instruction Type - Data Storage in Manual Storage Mode
Espressif Systems 549 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

Operand
Radst
Resrc
label
uoper
wr_way
offset

Description

Description - See Figure 27-13

Register R[O-3], address of the destination, expressed in 32-bit words
Register R[O-3], 16-bit value to store

Data label, 2-bit user defined unsigned value

0: Write the low half-word; 1: write the high half-word

0: Write the full-word; 1: with the label; 3: without the label

11-bit signed value, expressed in 32-bit words

Manual storage mode is mainly used for storing data into discontinuous addresses. Each instruction needs a

storage acdress and offset. The detailed storage methods are shown in Table 141.

 

wr_way upper Data Operation

0 * Mem [Rast + Offset]{31:0} ={(PC[10:0], 5’bO, Rsrc[15:0]} Write full-word, including
the pointer and the data

1 0 Mem [Rast + Offset]{15:0} = {Label[1:0],Rscr[13:0}} Store the data with label
in the low half-word

1 1 Mem [Rast + Offset]{31:16} = {Labell[1:0],Rscr[13:0]} Store the data with label
in the high half-word

3 0 Mem [Rdst + Offset]{15:0} = Rsrc[15:0] Store the data without label
in the low half-word

3 1 Mem [Rast + Offset]{31:16} = Rsrc[15:0] Store the data without label

in the high half-word

Table 141: Data Storage - Manual Storage Mode

27.5.2.3 LD -Load Data from Memory

&
ss es
& & &

 

[a1 2s| a7 [26 a1 | 20 ro [3 afi o|

 

 

Operand
Radst
Resrc
Offset
rd_upper

Description

Figure 27-14. Instruction Type - LD

Description - see Figure 27-14

Register R[0-3], destination

Register R[O-3], address of destination memory, expressed in 32-bit words
11-bit signed value, expressed in 32-bit words

Choose which half-word to read:

O - read the high half-word

1 - read the low half-word

This instruction loads the low or high 16-bit half-word, depending on rd_upper, from memory with address Asrc +

offset into the destination register Rast:

Rdst[15:0] = Mem[Rsrc + Offset]

Espressif Systems 550 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

Note:
® This instruction can only access 32-bit memory words.

* The “Mem” loaded is the RTC_SLOW_MEM memory. Address 0, as seen by the ULP coprocessor,
corresponds to address Ox50000000, as seen by the main CPU.

27.5.2.4 JUMP - Jump to an Absolute Address

 

 

 

 

 

 

 

 

 

 

 

 

&
Sd & &
31 28 | 27 26] 25 | 24 22) 21 | 20 13] 12 21 0
8 1
Figure 27-15. Instruction Type- JUMP
Operand Description - see Figure 27-15
Rast Register R[O-3], containing address to jump to (expressed in 32-bit words)

immAcdr 11-bit address, expressed in 32-bit words
Sel Select the address to jump to:
0 - jump to the address stored in immAdar
1 - jump to the address stored in Rast
Type Jump type:
0 - make an unconditional jump
1 - jump only if the last ALU operation has set zero flag
2 - jump only if the last ALU operation has set overflow flag

Note:

All jump addresses are expressed in 32-bit words.

Description
The instruction executes a jump to a specified address. The jump can be either unconditional or based on the
ALU flag.

27.5.2.5 JUMPR - Jump to a Relative Offset (Conditional upon RO)

 

 

 

 

S
& s ac
[1 2a 27 2s [25 [17 16 [15 o|
[ « |e | || |
Figure 27-16. Instruction Type - JUMPR
Espressif Systems 551 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

Operand Description - see Figure 27-16
Threshold Threshold value for condition (see Cond below) to jump
Cond Condition to jump:
0 - jump if RO < Threshold
1 - jump if RO > Threshold
2 - jump if RO = Threshold
Step Relative shift from current position, expressed in 32-bit words:
if Step[7] = 0, then PC = PC + Step[6:0]
if Step[7] = 1, then PC = PC - Step[6:0]

Note:
All jump addresses are expressed in 32-bit words.

Description
The instruction executes a jump to a relative address, if the above-mentioned condition is true. The condition is
the result of comparing the RO register value and the Threshold value.

27.5.2.6 JUMPS - Jump to a Relative Address (Conditional upon Stage Count Regis-
ter)

& RS eC

 

 

 

Figure 27-17. Instruction Type - JUMPS

Operand Description - see Figure 27-17
Threshold Threshold value for condition (see Cond below) to jump
Cond Condition to jump:
1X - jump if Stage_cnt <= Threshold
00 - jump if Stage_cnt < Threshold
01 - jump if Stage_cnt >= Threshold
Step Relative shift from current position, expressed in 32-bit words:
if Step[7] = 0, then PC = PC + Step[6:0]
if Step[7] = 1, then PC = PC - Step[6:0]

Note:
* For more information about the stage count register, please refer to Section 27.5.2.1.

* All jump addresses are expresses in 32-bit words.

Description
The instruction executes a jump to a relative address if the above-mentioned condition is true. The condition itself
is the result of comparing the value of Stage_cnt (stage count register) and the Threshold value.

Espressif Systems 552 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

27.5.2. HALT - End the Program

 

31 28 | 27 °

 

 

 

 

 

Figure 27-18. Instruction Type- HALT

Description
The instruction ends the operation of the ULP-FSM and puts it into power-down mode.

Note:
After executing this instruction, the ULP coprocessor wakeup timer gets started.

27.5.2.8 WAKE - Wake up the Chip

 

[1 2a 27 2s [25 1] o |

[ 2 Je] [re

 

 

 

Figure 27-19. Instruction Type - WAKE

Description
This instruction sends an interrupt from the ULP-FSM to the RTC controller.

® If the chip is in Deep-sleep mode, and the ULP wakeup timer is enabled, the above-mentioned interrupt will
wake up the chip.

® If the chip is not in Deep-sleep mode, and the ULP interrupt bit (RTC_CNTL_ULP_CP_INT_ENA) is set in
register RTC_CNTL_INT_ENA REG, an RTC interrupt will be triggered.

27.5.2.9 WAIT - Wait fora Number of Cycles

oO

 

 

 

 

oe
[a1 2s] 27 16 [is o|
L + | | |
Figure 27-20. Instruction Type - WAIT

Operand Description - see Figure 27-20

Cycles The number of cycles to wait

Description
The instruction will delay the ULP-FSM for a given number of cycles.
Espressif Systems 553 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

27.5.2.10 TSENS - Take Measurement with Temperature Sensor

 

[1 2a 27 16 [15 afi o|

[i | | | |

Figure 27-21. Instruction Type - TSENS

 

 

Operand Description - see Figure 27-21
Rast Destination Register R[O-3], results will be stored in this register.
Wait_Delay Number of cycles used to perform the measurement.

Description

Increasing the measurement cycles Wait_Delay helps improve the accuracy and optimize the result. The
instruction performs measurement via temperature sensor and stores the result into a general purpose
register.

27.5.2.11 ADC - Take Measurement with ADC

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

SF
S s &
[a1 2s | 27 [os [s afi o|
Ls | | | [|
Figure 27-22. Instruction Type - ADC
Operand Description - see Figure 27-22
Rast Destination Register R[O-3], results will be stored in this register.
Sar_Mux Enable SAR ADC pad [Sar_Mux - 1], see Table 142.
Sel Select ADC. 0: select SAR ADC1; 1: select SAR ADC2, see Table 142.
Table 142: Input Signals Measured Using the ADC Instruction
Pad / Signal / GPIO Sar_Mux | ADC Selection Se/
GPIO1 1
GPIO2 2
GPIO3 3
GPIO4 4
GPIO5 5
Se/ = 0, select SAR ADC1
GPIO6 6
GPIO7 7
GPIO8 8
GPIO9 9
GPIO10 10
GPIO11 1
Se/ = 1, select SAR ADC2
GPIO12
Espressif Systems 554 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

 

Pad / Signal / GPIO Sar_Mux | ADC Selection Se/

 

GPIO13
GPIO14
XTAL_32k_P
XTAL_32k_N
DAC_1
DAC_2
GPIO19
GPIO20

 

 

 

 

Sel = 1, select SAR ADC2

 

 

oloalw|oa]a} a] oo]!

 

 

 

 

4
oO

 

 

27.5.2.12 REG_RD - Read from Peripheral Register

 

[1 2a 27 23] 2 [17 1o[»

 

[ 2 | | | |

Figure 27-23. Instruction Type - REG_RD

Operand Description - see Figure 27-23

Adar Peripheral register address, in 32-bit words
Low Register start bit number
High Register end bit number

Description

The instruction reads up to 16 bits from a peripheral register into a general-purpose register:

RO = REG|Addr][High:Low]

In case of more than 16 bits being requested, i.e. High - Low + 1 > 16, then the instruction will return

[Low+15:Low].

Note:

® This instruction can access registers in RTC_CNTL, RTC_lO, SENS, and RTC_I2C peripherals. Address of
the register, as seen from the ULP coprocessor, can be calculated from the address of the same register on

PeriBUS1 (addr_peribus1)}, as follows:
addr_ulp = (addr_peribus1 - DR-REG_RTCCNTL_BASE) / 4

© The adar_ulp is expressed in 32-bit words (not in bytes), and value O maps onto the

DR_REG_RTCCNTL_BASE (as seen from the main CPU). Thus, 10 bits of address cover a 4096-byte
range of peripheral register space, including regions DR_REG_RTCCNTL_BASE, DR_REG_RTCIO_BASE,

DR_REG_SENS_BASE, and DR_LREG_RTC_I2C_BASE.

Espressif Systems 555 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

27.5.2.13 REG_WR - Write to Peripheral Register

oS o>
& s Se &

 

[a1 2s] 27 23 | 22 te | ro] o|

| | | | |

Figure 27-24. Instruction Type - REG_WR

 

 

Operand Description - see Figure 27-24

Adar Register address, expressed in 32-bit words
Data Value to write, 8 bits
Low Register start bit number
High Register end bit number
Description

This instruction writes up to 8 bits from an immediate data value into a peripheral register.

REG|Addr][High:Low] = Data

lf more than 8 bits are requested, i.e. High - Low + 1 > 8, then the instruction will pad with zeros the bits above
the eighth bit.

Note:

See notes regarding addr_uip in Section 27.5.2.12.

27.6 ULP-RISC-V

27.6.1 Features
* Support RVG2IMC instruction set

® Thirty-two 32-bit general-purpose registers
* 32-bit multiplier and divider

® Support for interrupts

27.6.2 Multiplier and Divider
ULP-RISC-V has an independent multiplication and division unit. The efficiency of multiplication and division
instructions is shown in the following table.

Espressif Systems 556 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Table 143: Instruction Efficiency

 

 

 

 

 

 

 

 

 

 

 

 

 

Operation | Instruction Execution Cycle | Instruction Description
MUL 34 Multiply two 32-bit integers and return the lower 32-bit of the result
Multiply MULH 66 Multiply two 82-bit signed integers and return the higher 32-bit of
the result
MULHU 66 Multiply two 32-bit unsigned integers and return the higher 32-bit
of the result
MULHSU 66 Multiply a 32-bit signed integer with a unsigned integer and return
the higher 32-bit of the result
DIV 34 Divide a 32-bit integer by a 32-bit integer and return the quotient
Divide DIU 34 Divide a 32-bit unsigned integer by a 32-bit unsigned integer and
return the quotient
REM 34 Divide a 32-bit signed integer by a 32-bit signed integer and return
the remainder
REMU 34 Divide a 32-bit unsigned integer by a 32-bit unsigned integer and

return the remainder

 

27.6.3 ULP-RISC-V Interrupts
The interrupts from some sensors, software, and RTC |2C can be routed to ULP-RISC-V. To enable the interrupts,

please set the register SENS_SAR_COCPU_INT_ENA REG, see Table 144.

Enable bit

Interrupt

Description

 

0

OoOnN Oak ONY =

Note:

TOUCH_DONE_INT
TOUCH_INACTIVE_INT
TOUCH_ACTIVE_INT
SARADC1_DONE_INT
SARADC2_DONE_INT
TSENS_DONE_INT
RISCV_START_INT

SW_INT
SWD_INT

Triggered when the touch sensor completes the scan of a channel
Triggered when the touch pad is released

Triggered when the touch pad is touched

Triggered when SAR ADC1 completes the conversion one time
Triggered when SAR ADC2 completes the conversion one time
Triggered when the temperature sensor completes the dump of its data
Triggered when ULP-RISC-V powers on and starts working

Triggered by software
Triggered by timeout of Super Watchdog (SWD)

Table 144: ULP-RISC-V Interrupt List

Besides the above-mentioned interrupts, ULP-RISC-V can also handle the interrupt from RTC_IO by simply

configuring RTC_lO as input mode. Users can configure RTCIO_GPIO_PINn_INT_TYPE to select the
interrupt trigger modes, but only level trigger modes are available. For more details about RTC_lO
configuration, see Chapter |O MUX and GPIO Matrix.

RTCIO_RTC_GPIO_STATUS_REG.

Espressif Systems

The interrupt from RTC_IO can be cleared by releasing RTC_IO and its source can be read from the register

The SW_INT interrupt is generated by configuring the register RTC_CNTL_COCPU_SW_INT_TRIGGER,.

For the information about RTC l?C interrupts, please refer to Section 27.7.4.

557 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 
27. ULP Coprocessor

 

27.7 RTC I2C Controller

ULP coprocessor can use RTC l?C controller to read from or write to the external I?C slave devices.

27.7.1. Connecting RTC I2C Signals
SDA and SCL signals can be mapped onto two out of the four GPIO pins, which are identified in Table 24 in

Chapter 5 /(O MUX and GPIO Matrix, using the register RTCIO_SAR_I2C_lO_REG.

27.7.2. Configuring RTC I?C

Before the ULP coprocessor can use the |?C instruction, certain parameters of the RTC IC need to be
configured. Configuration is performed by writing certain timing parameters into the RTC |?C registers. This can
be done by the program running on the main CPU, or by the ULP coprocessor itself.

1. Set the low and high SCL half-periods by configuring RTC_I2C_SCL_LOW_PERIOD_REG and
RTC_l2C_SCL_HIGH_PERIOD_REG in RTC_FAST_CLK cycles (e.g. RTC_I2C_SCL_LOW_PERIOD_REG
= 40, RTC_l2C_SCL_HIGH_PERIOD_REG = 40 for 100 kHz frequency).

2. Set the number of cycles between the SDA switch and the falling edge of SCL by using
RTC_l2C_SDA_DUTY_REG in RTC_FAST_CLK (e.g. RTC_I2C_SDA_DUTY_REG = 16).

3. Set the waiting time after the START condition by using RTC_l2C_SCL_START_PERIOD_REG (e.g.
RTC_l2C_SCL_START_PERIOD = 80).

4. Set the waiting time before the END condition by using RTC_I2C_SCL_STOP_PERIOD_REG (e.g.
RTC_l2C_SCL_STOP_PERIOD = 44).

5. Set the transaction timeout by using RTC_I2C_TIME_OUT_REG (e.g. RTC_I2C_TIME_OUT_REG = 200).

6. Configure the RTC [2C controller into master mode by setting the RTC_I2C_MS_MODE bit in
RTC_l2C_CTRL_REG.

7. Write the address(es) of external slave(s) to SENS_I2C_SLAVE_ADDR)? (7: 0-7). Up to eight slave
addresses can be pre-programmed this way. One of these addresses can then be selected for each
transaction as part of the RTC [2C instruction.

Once RTC |?C is configured, the main CPU or the ULP coprocessor can communicate with the external |2C
devices.

27.7.3 Using RTC I2C
27.7.3.1 Instruction Format

The format of RTC I2C instruction is consistent with that of l2?CO/l?C1, see Section 17.3.2.2 CMD_Controller in
Chapter 17 /°C Controller. The only difference is that RTC l?C provides fixed instructions for different operations,
as follows:

* Command 0 ~ Command 1: specially for l2C write operation
* Command 2 ~ Command 6: specially for I2C read operation

Note: All slave addresses are expressed in 7 bits.

27.7.3.2 12C_RD - l?C Read Workflow

Preparation for RTC I2C read:

Espressif Systems 558 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

* Configure the instruction list of RTC l2C (see Section CMD_Controller in Chapter 17 &C Conirofer, including
instruction order, instruction code, read data number (byte_num), and other information.

* Configure the slave register address by setting the register SENS_SAR_l2C_CTRL[18:11].

Start RTC 2C transmission by setting the registers SENS_SAR_l2C_START_FORCE and
SENS_SAR_|2C_START.

® When an RTC_l2C_RX_DATA_INT interrupt is received, transfer the read data stored in RTC_l2C_RDATA to
SRAM RTC slow memory, or use the data directly.

The 12C_RD instruction performs the following operations (see Figure 27-25):
1. Master generates a START condition.

2. Master sends slave address, with r/w bit set to O (“write”). Slave address is obtained from
SENS _I2C_SLAVE_ADDR».

3. Slave generates ACK.

4. Master sends slave register address.

5. Slave generates ACK.

6. Master generates a repeated START (RSTART) condition.
7. Master sends slave address, with r/w bit set to 1 (“read”).
8. Slave sends one byte of data.

9. Master checks whether the number of transmitted bytes reaches the number set by the current instruction
(byte_num). If yes, master jumps out of the read instruction and sends an NACK signal. Otherwise master
repeats Step 8 and waits for the slave to send the next byte.

10. Master generates a STOP condition and stops reading.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

q 2 3 4 5 6 7 8 9 10
Master Slave Address W Reg Address E Slave Address R 2) 8
Slave é & Data(n)
Figure 27-25. l2?C Read Operation
Note:

The RTC |?C peripheral samples the SDA signals on the falling edge of SCL. If the slave changes SDA in less than
0.38 microsecond, the master may receive incorrect data.

27.7.3.3 |12C_WR - |?C Write Workflow

Preparation for RTC 2C write:

® Configure RTC [2C instruction list, including instruction order, instruction code, and the data to be written in
byte (byte_num). See the configuration of I2CO/l2C1 in Section CMD_Controller in Chapter 17 /°C Controller.

* Configure the slave register address by setting the register SENS_SAR_|2C_CTRL[18:11], and the data to
be transmitted in SENS_SAR_I2C_CTRL[26:19].

® Set the registers SENS_SAR_l2C_START_FORCE and SENS_SAR_|2C_START to start the transmission.

Espressif Systems 559 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

e Update the next data to be transmitted in the register SENS_SAR_l2C_CTRL[26:19], each time when an

RTC_l2C_TX_DATA_INT interrupt is received.

The 12C_WR instruction performs the following operations, see Figure 27-26.

1.
2.

10.

Master generates a START condition.

Master sends slave address, with r/w bit set to 0 (“write”). Slave address is obtained from
SENS _I2C_SLAVE_ADDR».

. Slave generates ACK.

. Master sends slave register address.

. Slave generates ACK.

. Master generates a repeated START condition (RSTART).
. Master sends slave address, with r/w bit set to O (“write”).
. Master sends one byte of data.

. Slave generates ACK. Master checks whether the number of transmitted bytes reaches the number set by

the current instruction (byte_num). If yes, master jumps out of the write instruction and starts the next
instruction. Otherwise the master repeats step 8 and sends the next byte.

Master generates a STOP condition and stops the transmission.
2 3 4 5

Slave Address W Reg Address

Slave é é

7 8 9
Slave Address W Data(n)

4

STOP, OQ

 

START]
RSTRT| OD

Master

 

 

 

ACK

 

 

 

 

 

 

 

 

 

 

Figure 27-26. l?C Write Operation

27.7.3.4 Detecting Error Conditions

Applications can query specific bits in the RTC_l2C_INT_ST_REG register to check if the transaction is
successful. To enable checking for specific communication events, their corresponding bits should be set in
register RTC_l2C_INT_ENA REG. Note that the bit map is shifted by 1. If a specific communication event is
detected and its corresponding bit in register RTC_l2C_INT_ST_REG is set, the event can then be cleared using
register RTC_l2C_INT_CLR_REG.

27.7.4 RTC I2C Interrupts

RTC_l2C_SLAVE_TRAN_COMP_INT: Triggered when the slave finishes the transaction.
RTC_l2C_ARBITRATION_LOST_INT: Triggered when the master loses control of the bus.
RTC_l2C_MASTER_TRAN_COMP_INT: Triggered when the master completes the transaction.
RTC_l2C_TRANS_COMPLETE_INT: Triggered when a STOP signal is detected.
RTC_l2C_TIME_OUT_INT: Triggered by time out event.

RTC_l2C_ACK_ERF_INT: Triggered by ACK error.

RTC_l2C_RX_DATA_ INT: Triggered when data is received.

Espressif Systems 560 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

* RTC_I2C_TX_DATA_INT: Triggered when data is transmitted.

° RTC_I2C_DETECT_START_INT: Triggered when a START signal is detected.

27.8 Base Address
27.8.1 ULP Coprocessor Base Address

Users can access ULP coprocessors with the following base addresses as shown in Table 145.

Table 145: ULP Coprocessor Base Address

 

 

 

 

 

Module Bus to Access Peripheral | Base Address
PeriBUS1 OxSF408000
ULP (ALWAYS_ON) -
PeriBUS2 Ox60008000
PeriBUS1 OxSF408800
ULP (RTC_PERI) ;
PeriBUS2 Ox60008800

 

 

 

 

 

Wherein:

e ULP (ALWAYS_ON) represents the registers, which will not be reset due to the power down of RTC_PERI
domain. See Chapter Low Power Management.

e ULP (RTC_PER)) represents the registers in RTC_PERI domain, which will be reset due to the power down
of RTC_PERI domain. See Chapter Low Power Management.

27.8.2 RTC I?C Base Address
Users can access the RTC I?C registers in RTC_PERI domain, including RTC_PERI registers and ?C registers,
with the following base addresses as shown in Table 146.

Table 146: RTC l2C Base Address

 

 

 

 

 

Module Bus to Access Peripheral | Base Address
PeriBUS1 OxSF408800
RTC [2C (RTC_PERI) -
PeriBUS2 O0x60008800
PeriBUS1 OxSF408C00
RTC [2C (l2C) -
PeriBUS2 Ox60008C00

 

 

 

 

 

27.9 Register Summary
The address in the following part represents the address offset (relative address) with respect to the base address,
not the absolute address. For detailed information about the base address, please refer to Section 27.8.

27.9.1 ULP (ALWAYS_ON) Register Summary

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description Address | Access

ULP Timer Registers

RTC_CNTL_ULP_CP_TIMER_REG Configure the timer OxOOF8 | varies

RTC_CNTL_ULP_CP_TIMER_1_REG Configure sleep cycle of the timer 0x0130 | RAV

ULP-FSM Register

RTC_CNTL_ULP_CP_CTRL_REG ULP-FSM configuration register | OxOOFC | RAW
Espressif Systems 561 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name | Description | Address | ACCess
ULP-RISC-V Register
RTC_CNTL_COCPU_CTRL_REG | ULP-RISC-V configuration register | ox0100 | varies
27.9.2 ULP (RTC_PERI) Register Summary
Name | Description Address | Access
ULP-RISC-V Registers
SENS_ SAR_COCPU_INT_RAW_REG Interrupt raw bit of ULP-RISC-V 0x0128 | RO
SENS_SAR_COCPU_INT_ENA REG Interrupt enable bit of ULP-RISC-V O0x012C | RAV
SENS_SAR_COCPU_INT_ST_REG Interrupt status bit of ULP-RISC-V 0x0130 | RO
SENS_SAR_COCPU_INT_CLR_REG Interrupt clear bit of ULP-RISC-V 0x0134 | WO
27.9.3 RTC l2C (RTC_PERI) Register Summary
Name | Description | Address | ACCess
RTC l2C Controller Register
SENS_SAR_I2C_CTRL_REG | Configure RTC [2C transmission | O0x0058 | RAW
RTC l?C Slave Address Registers
SENS_SAR_SLAVE_ADDR1_REG Configure slave addresses 0-1 of RTC I?C 0x0040 | RAV
SENS_SAR_SLAVE_ADDR2_REG Configure slave addresses 2-3 of RTC I?C 0x0044 | RAV
SENS_SAR_SLAVE_ADDR3_REG Configure slave addresses 4-5 of RTC I?C 0x0048 | RAV
SENS_SAR_SLAVE_ADDR4_REG Configure slave addresses 6-7 of RTC I2?C Ox004C | RAV
27.9.4 RTC I2C (l2C) Register Summary
Name | Description Address | Access
RTC l2C Signal Setting Registers
RTC_l2C_SCL_LOW_REG Configure the low level width of SCL Ox0000 | RAV
RTC_l2C_SCL_HIGH_REG Configure the high level width of SCL 0x0014 | RAV
RTC_lI2C_SDA_DUTY_REG Configure the SDA hold time after a negative | Ox0018 | RAV
SCL edge
RTC_l2C_SCL_START_PERIOD_REG Configure the delay between the SDA and SCL | 0x001C | RAV
negative edge for a start condition
RTC_l2C_SCL_STOP_PERIOD_REG Configure the delay between SDA and SCL pos- | 0x0020 | RAV
itive edge for a stop condition
RTC l?C Control Registers
RTC_l2C_CTRL_REG Transmission setting O0x0004 | RAV
RTC_l2C_STATUS REG RTC 2C status 0x0008 | RO
RTC_l2C_TO_REG Configure RTC [2C timeout Ox000C | RAV
RTC_l2C_SLAVE_ADDR_REG Configure slave address O0x0010 | RAV
RTC [2C Interrupt Registers
RTC_l2C_INT_CLR_REG Clear RTC |2C interrupt 0x0024 | WO
RTC_l2C_INT_RAW_REG RTC 2C raw interrupt 0x0028 | RO
RTC_l2C_INT_ST_REG RTC IC interrupt status O0x002C | RO

 

 

 

 

 

Espressif Systems

562 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback

 

 

 

 
27. ULP Coprocessor

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
RTC_l2C_INT_ENA_REG Enable RTC [2C interrupt Ox0030 | RAV
RTC l2?C Status Register

RTC_l2C_DATA_REG RTC l?C read data Ox00384 | varies
RTC l2?C Command Registers

RTC_l2C_CMDO_REG RTC I? Command 0 Ox00388 | varies
RTC_l2C_CMD1_REG RTC I? Command 1 OxO0038C_ | varies
RTC_l2C_CMD2_REG RTC I? Command 2 0x0040 ‘| varies
RTC_l2C_CMD3_REG RTC I? Command 3 0x0044 | varies
RTC_l2C_CMD4_REG RTC I? Command 4 Ox0048 (| varies
RTC_I2C_CMD5_REG RTC I? Command 5 Ox004C_ | varies
RTC_l2C_CMD6_REG RTC I? Command 6 Ox0050_ ‘| varies
RTC_l2C_CMD7_REG RTC I? Command 7 O0x0054 =| varies
RTC_l2C_CMD8_REG RTC I? Command 8 Ox0058 ‘| varies
RTC_l2C_CMD9_REG RTC I? Command 9 Ox005C_ | varies
RTC_l2C_CMD10_REG RTC I? Command 10 Ox0060_ ‘| varies
RTC_l2C_CMD11_REG RTC I? Command 11 Ox0064 | varies
RTC_l2C_CMD12_REG RTC I? Command 12 Ox0068 | varies
RTC_l2C_CMD13_REG RTC I? Command 13 OxO006C_ | varies
RTC_l2C_CMD14_REG RTC I? Command 14 Ox0070 | varies
RTC_l2C_CMD15_REG RTC I? Command 15 Ox0074 | varies
Version register

RTC_l2C_DATE_REG Version control register OxOOFC | RAV

 

27.10 Registers

The address in the following part represents the address offset (relative address) with respect to the base address,

not the absolute address. For detailed information about the base address, please refer to Section 27.8.

Espressif Systems

563

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
27. ULP Coprocessor

 

27.10.1 ULP (ALWAYS_ON) Registers

Register 27.1: RTC_CNTL_ULP_CP_TIMER_REG (Ox00F8)

 

 

 

ser
ELE
SES ee’
B°BI8? w
SER <a
OKXOKO’ Q@ O7

S&E é é

[ a1 | 2 | 2 [2 | 10 o|
[ofofofo o 0000000000000 090 Of 0 |Reset

 

RTC_CNTL_ULP_CP_PC_INIT ULP coprocessor PC initial address. (R/W)

RTC_CNTL_ULP_CP_GPIO_WAKEUP_ENA Enable the option of ULP coprocessor woken up by
RTC GPIO. (RV)

RTC_CNTL_ULP_CP_GPIO_WAKEUP_CLR Disable the option of ULP coprocessor woken up by
RTC GPIO. (WO)

RTC_CNTL_ULP_CP_SLP_TIMER_EN ULP coprocessor timer enable bit. 0: Disable hardware
timer; 1: Enable hardware timer. (RAV)

Register 27.2: RTC_CNTL_ULP_CP_TIMER_1_REG (0x0130)

 

 

 

y
ao
of’
Sv
SNS
&%
Ss
V7
s &
O7 G
&é Ce
[a1 al o|
| 200 [o 0 000 0 0 O|Reset

 

RTC_CNTL_ULP_CP_TIMER_SLP_CYCLE Set sleep cycles for ULP coprocessor timer. (R/W)

Espressif Systems 564 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

Register 27.3: RTC_CNTL_ULP_CP_CTRL_REG (0x00FC)

[a | 2 | 2 | [= o|

fofo[ofofo 0 9 0 0 9 0 09 0 9 000000009 0009 00 0 0 0 0 OlReset

RTC_CNTL_ULP_CP_CLK_FO ULP-FSM clock force on. (R/W)
RTC_CNTL_ULP_CP_RESET ULP-FSM clock software reset. (RAW)
RTC_CNTL_ULP_CP_FORCE_START_TOP Write 1 to start ULP-FSM by software. (RAW)

RTC_CNTL_ULP_CP_START_TOP Write 1 to start ULP-FSM. (R/W)

Espressif Systems 565 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

Register 27.4: RTC_CNTL_COCPU_CTRL_REG (0x0100)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

S
>
S S A) S }”
KS Y
& & ES Oo ° & &
SEX 6S y a wa ©
XS ey LY » » » oe s on
LOPL’ ey or ey ey oe
SF FF FO Oo Oo Oo Oo Oo
SES EE S SF SF SF oS
& SEK of xX YX
& EEE & SS & SS &
31 27 | 26 25 24 23 22 | 21 14] 13 | 12 716 1 0
0 0 0 0 ofololo]ifo 40 0 16 8 0 |Reset
RTC_CNTL_COCPU_CLK_FO ULP-RISC-V clock force on. (RAN)
RTC_CNTL_COCPU_START_2 RESET _DIS Time from ULP-RISC-V startup to pull down reset.
(RAV)
RTC_CNTL_COCPU_START_2 INTR_EN Time from ULP-RISC-V startup to send out
RISCV_START_INT interrupt. (R/WW)
RTC_CNTL_COCPU_SHUT Shut down ULP-RISC-V. (RWW)
RTC_CNTL_COCPU_SHUT_2 CLK_DIS Time from shut down ULP-RISC-V to disable clock. (RAV)
RTC_CNTL_COCPU_SHUT_RESET_EN This bit is used to reset ULP-RISC-V. (RW)
RTC_CNTL_COCPU_SEL 0: select ULP-RISC-V, 1: select ULP-FSM. (R/W)
RTC_CNTL_COCPU_DONE_FORCE 0: select ULP-FSM DONE signal; 1: select ULP-RISC-V
DONE signal. (RAV)
RTC_CNTL_COCPU_DONE DONE signal. Write 1 to this bit, ULP-RISC-V will go to HALT and the
timer starts counting. (RAN)
RTC_CNTL_COCPU_SW_INT_TRIGGER Trigger ULP-RISC-V register interrupt. (WO)
Espressif Systems 566 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

27.10.2 ULP (RTC_PERI) Registers

Register 27.5: SENS_ SAR_COCPU_INT_RAW_REG (0x01 28)

 

[a

Tede}e>]«fe]e] fe]

 

[0 00000000000000000 0000 ofofofofolo]o][o]o] 4 IRreset

 

SENS_COCPU_TOUCH_DONE_INT_RAW TOUCH _DONE INT interrupt raw bit. (RO)

SENS_COCPU_TOUCH_INACTIVE_INT_RAW TOUCH_INACTIVE_INT interrupt raw bit. (RO)

SENS_COCPU_TOUCH_ACTIVE_INT_RAW TOUCH _ACTIVE_INT interrupt raw bit. (RO)

SENS_COCPU_SARADC1_INT_RAW SARADC1_DONE_INT interrupt raw bit. (RO)

SENS_COCPU_SARADC2_INT_RAW SARADC2_ DONE _INT interrupt raw bit. (RO)

SENS_COCPU_TSENS_INT_RAW TSENS_DONE_INT interrupt raw bit. (RO)

SENS_COCPU_START_INT_RAW RISCV_START_INT interrupt raw bit. (RO)

SENS_COCPU_SW_INT_RAW SW_INT interrupt raw bit. (RO)

SENS_COCPU_SWD_INT_RAW SWD_INT interrupt raw bit. (RO)

Espressif Systems

567

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
27. ULP Coprocessor

 

Register 27.6: SENS_SAR_COCPU_INT_ENA_REG (0x01 2C)

&
oe
ret ROSS
Se QO SOAS
SOS SOS
WA NS Ss YG ¥ wed
OSES?
SSF SSF SF RO’
SOO OL OLD oS

 

 

 

 

SENS_COCPU_TOUCH_DONE_INT_ENA TOUCH_DONE_INT interrupt enable bit. (R/W)

SENS_COCPU_TOUCH_INACTIVE_INT_ENA TOUCH_INACTIVE_INT interrupt enable bit. (RAV)

SENS_COCPU_TOUCH_ACTIVE_INT_ENA TOUCH _ACTIVE_INT interrupt enable bit. (RAV)

SENS_COCPU_SARADC1_INT_ENA SARADC1_DONE _INT interrupt enable bit. (R/WV)

SENS_COCPU_SARADC2_INT_ENA SARADC2_DONE INT interrupt enable bit. (R/WV)

SENS_COCPU_TSENS_INT_ENA TSENS_DONE INT interrupt enable bit. (R/W)

SENS_COCPU_START_INT_ENA RISCV_START_INT interrupt enable bit. (R/W)

SENS_COCPU_SW_INT_ENA_ SW_INT interrupt enable bit. (R/WV)

SENS_COCPU_SWD_INT_ENA SWD_INT interrupt enable bit. (R/W)

Espressif Systems

568

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
27. ULP Coprocessor

 

Register 27.7: SENS_SAR_COCPU_INT_ST_REG (0x01 30)

 

 

 

 

 

 

 

 

 

 

 

 

 

0 0 0000 0 00 00 00 00 0 0 0 0 0 0 0 0)/0)/0]/0]}0]/0/0]0]0] 0 JReset

 

SENS _COCPU_TOUCH_DONE_INT_ST TOUCH _DONE INT interrupt status bit. (RO)
SENS _COCPU_TOUCH_INACTIVE_INT_ST TOUCH_INACTIVE_INT interrupt status bit. (RO)
SENS _COCPU_TOUCH_ACTIVE_INT_ST TOUCH ACTIVE _INT interrupt status bit. (RO)
SENS _COCPU_SARADC1_INT_ST SARADC1_DONE_INT interrupt status bit. (RO)

SENS _COCPU_SARADC2_INT_ST SARADC2_DONE_INT interrupt status bit. (RO)

SENS _COCPU_TSENS_INT_ST TSENS DONE _INT interrupt status bit. (RO)

SENS _COCPU_START_INT_ST RISCV_START_INT interrupt status bit. (RO)

SENS COCPU_SW_INT_ST SW_INT interrupt status bit. (RO)

SENS_COCPU_SWD_INT_ST SWD_INT interrupt status bit. (RO)

Espressif Systems 569 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.8: SENS_SAR_COCPU_INT_CLR_REG (0x0134)

 

 

 

 

 

 

 

 

 

 

 

 

 

Reset

 

SENS _COCPU_TOUCH_DONE_INT_CLR TOUCH _DONE_INT interrupt clear bit. (WO)

SENS _COCPU_TOUCH_INACTIVE_INT_CLR TOUCH_INACTIVE_INT interrupt clear bit. (WO)
SENS _COCPU_TOUCH_ACTIVE_INT_CLR TOUCH _ACTIVE_INT interrupt clear bit. (WO)
SENS _COCPU_SARADC1_INT_CLR SARADC1_DONE INT interrupt clear bit. (WO)

SENS _COCPU_SARADC2_ INT_CLR SARADC2_DONE _INT interrupt clear bit. (WO)

SENS _COCPU_TSENS_INT_CLR TSENS_DONE INT interrupt clear bit. (WO)

SENS _COCPU_START_INT_CLR RISCV_START_INT interrupt clear bit. (WO)

SENS COCPU_SW_INT_CLR SVW_INT interrupt clear bit. (WO)

SENS_COCPU_SWD_INT_CLR SWD_INT interrupt clear bit. (WO)

27.10.38 RTC l?C (RTC_PERI) Registers

Register 27.9: SENS_SAR_I2C_CTRL_REG (0x0058)

 

 

 

xy
O
Ss
LAK
KE wv
foe x
VY Y
S So Lf
s se s
§ Oo’ 5s”
& LS 8
[1 so] 29 | 28 | a7 o|
[o | 0 | 0 | 0

| Reset

 

SENS_SAR_I2C_CTRL RTC I?C control data; active only wnen SENS_SAR_|I2C_START_FORCE =

1. (RAW)

SENS_SAR_I2C_START Start RTC ?C; active only wnen SENS_SAR_I2C_START_FORCE = 1. (R/W)

SENS_SAR_I2C_START_FORCE 0: RTC ?C started by FSM; 1: RTC [?C started by software. (R/W)

570
Submit Documentation Feedback

Espressif Systems

ESP32-S2 TRM (Preliminary V0.4)
27. ULP Coprocessor

Register 27.10: SENS_SAR_SLAVE_ADDR1_REG (0x0040)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

© \
x SX
‘. ss
“ey &’
vr ss
Ss Ov Ov
sf oe oS
& oo SY
[a1 afar ni] 10 o|
jo 0 9 0 9 000 0 9] Oxo | Oxo |Reset
SENS I2C_ SLAVE _ADDR1 RTC I2C slave address 1. (RAW)
SENS I2C_ SLAVE ADDRO RTC I°C slave address 0. (RW)
Register 27.11: SENS SAR SLAVE ADDR2_REG (0x0044)
v 0)
x x
‘. ss
xe &
s a
& ee ee
& S S
31 22) 21 11] 10 0
0000000 0 0 0 oxo oxo Reset
SENS I2C_ SLAVE _ADDR3 RTC I°C slave address 3. (RW)
SENS I2C_ SLAVE ADDR2 RTC I°C slave address 2. (RW)
Register 27.12: SENS SAR SLAVE ADDR3_REG (0x0048)
& Ke)
SX x
‘. ss
xe &
of ca
& Y ¥
& S S
31 22) 21 11] 10 0
0000000 0 0 0 oxo oxo Reset
SENS I2C_ SLAVE _ADDR5 RIC I°C slave address 5. (RAW)
SENS I2C_ SLAVE ADDR4 RTC I°C slave address 4. (R/V)
Espressif Systems 571 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.13: SENS_SAR_SLAVE_ADDR4_REG (0x004C)

 

 

 

 

 

 

 

© A
SX SX
8 s
xe &
wy Ss
Sd C7 C7
ss oe oe
& & LY
[a1 afar ni] 10 o|
jo 0 9 0 9 000 0 9] Ox0 | xO |Reset
SENS _12C SLAVE_ADDR7 RTC I2C slave address 7. (RAV)
SENS _12C SLAVE_ADDR6 RTC IC slave address 6. (RAV)
27.10.4 RTC I2C (I2C) Registers
Register 27.14: RTC_l2C_SCL_LOW_REG (0x0000)
&
QO’
“Xe
aw’
wy
O
S
5 > &’
& &
| 31 20 | 1g o |
joo 0 0 000000 0 9 ox100 |Reset

 

RTC _I12C_ SCL_LOW_PERIOD_REG This register is used to configure how many clock cycles SCL
remains low. (R/W)

Register 27.15: RTC_l2C_SCL_HIGH_REG (0x0014)

 

 

 

&
f
e&
x
f
we
NY
S fF
& v
J oO
F x
x <
[a1 20 | 19 o|
fo 0 0 9 000000 0 Of ox100 |Reset

 

RTC _12C_ SCL_HIGH_ PERIOD REG This register is used to configure how many cycles SCL re-
mains high. (RAV)

Espressif Systems 572 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.16: RTC_l2C_SDA_DUTY_REG (0x0018)

 

 

 

o
Ss
ss
7
oS
S
se ee’
& &
[1 20] 19 o|
fo 0 9 9 009 000 0 9 Ox010 |Reset

 

RTC_I12C_SDA_DUTY_NUM The number of clock cycles between the SDA switch and the falling
edge of SCL. (RW)

Register 27.17: RTC_l2C_SCL_START_PERIOD_REG (0x001C)

 

 

&
&
&
Se
S oS
of v
& «07
2)
« &
31 20] 19 oO
0 0 0 0 00 0 0 0 0 0 0 8 Reset

 

 

 

 

RTC _I12C_ SCL_START_PERIOD Number of clock cycles to wait after generating a start condition.

 

 

(RAV)
Register 27.18: RTC_I2C_SCL_STOP_PERIOD_REG (0x0020)
Q
&
g
iS
WP
O
& oF
of v
& «Oo?
€ <
31 20) 19 0
000000 00 0 0 0 0 8 Reset

 

 

 

 

RTC _I12C_ SCL_STOP_PERIOD Number of clock cycles to wait before generating a stop condition.
(RAV)

Espressif Systems 573 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.19:

RTC_l2C_CTRL_REG (0x0004)

 

S ‘
KY A SS
& EES See
Le QS Se O oO
b> MLS? SES
& 5 See ES
3 J

CEE € ECE EEE
| st | 2 | 29 | 2 6] 5 «[o[e[s[o]

 

 

[= |
[o]o]ofo 000000000000000000000 ofo][ofo]o][o]o JRreset

 

RTC _I12C_ SDA _FORCE_OUT SDA output mode. 0: open drain; 1: push pull. (RAY)

RTC _l2C_ SCL_FORCE_OUT SCL output mode. 0: open drain; 1: push pull. (RAY)

RTC_I2C_MS MODE Set this bit to configure RTC l?C as a master. (RAV)

RTC_l2C_TRANS_START Set this bit to 1, RTC [?C starts sending cata. (R/W)

RTC _12C_TX_LSB FIRST This bit is used to control the sending mode. 0: send data from the most

significant bit; 1: send data from the least significant bit. (RAV)

RTC _I12C_RX_LSB FIRST This bit is used to control the storage mode for received data. 0: receive
data from the most significant bit; 1: receive data from the least significant bit. (RAV)

RTC_Il2C_CTRL_CLK_GATE_EN RIC I2C controller clock gate. (RAM)

RTC_I2C_ RESET RIC [2C software reset. (R/V)

Espressif Systems

574

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
27. ULP Coprocessor

 

Register 27.20: RTC_l2C_STATUS_REG (0x0008)

of v
& 7 (O%0%4%0%4%040%07
€ & SEES

31 Bl7 6} 5 ]4]3}]2]i]o

 

 

000000000 000060060060 00 0 0 06 0 0 6 of 0 Jololo}olo] o IReset

 

 

 

 

 

 

 

 

 

RTC_12C_ACK_REC The received ACK value. 0: ACK; 1: NACK. (RO)

RTC _I2C_ SLAVE RW 0: master writes to slave; 1: master reads from slave. (RO)

RTC _I12C_ ARB LOST When the RTC [°C loses control of SCL line, the register changes to 1. (RO)
RTC _Il2C BUS BUSY 0: RTC 2C bus is in idle state; 1: RTC |?C bus is busy transferring data. (RO)

RTC _I2C_ SLAVE ADDRESSED When the address sent by the master matches the address of the
slave, then this bit will be set. (RO)

RTC _I12C_BYTE_TRANS This field changes to 1 when one byte is transferred. (RO)

RTC_I2C_OP_CNT Indicate which operation is working. (RO)

Register 27.21: RTC_l2C_TO_REG (0x000C)

 

 

 

&
$7
we
S ge”
ss >
eo «O
& <
[a1 20 | 19 o|
[0 000000000 0 o| 0x10000 |Reset

 

RTC_l2C_TIME_OUT_REG Timeout threshold. (R/W)

Register 27.22: RTC_l2C_SLAVE_ADDR_REG (0x0010)

 

 

0j/O0 0 0 00 0 00 00 0 00 00 00 0 00 00 00 0 0 0 0 0 0 OfReset

 

 

 

 

RTC_I2C_ADDR_10BIT_EN This field is used to enable the slave 10-bit addressing mode. (R/W)

Espressif Systems 575 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.23: RTC_l2C_INT_CLR_REG (0x0024)

 

 

 

 

S
Se XS
S$ OSES
6& Sk 5S $7
SS SF FMA Hey
LEO ORIOL S
Se oe & QSKS OOP
7 294° O oo? x ve
ESS SSPE E
LE TLE KES
& ELEEEELLL’
é E&EEELEEE
[1 Tel-fels]l2]2[: [2]
[o 000000000000 00000 0000 ofofofofofolfo]o]o]o JReset

RTC_I2C_SLAVE_TRAN_COMP_INT_CLR RTC_l2C_SLAVE_TRAN_COMP_INT interrupt clear bit.

(WO)
RTC_I2C_ARBITRATION_LOST_INT_CLR RTC_l2C_ARBITRATION_LOST_INT interrupt clear bit.

(WO)
RTC_I2C_MASTER_TRAN_COMP_INT_CLR RTC_l2C_MASTER_TRAN_COMP_INT interrupt

clear bit. (WO)
RTC_I2C_TRANS_COMPLETE_INT_CLR RTC_I2C_TRANS_COMPLETE_INT interrupt clear bit.

(WO)
RTC_I2C_TIME_OUT_INT_CLR RTC_l2C_TIME_OUT_INT interrupt clear bit. (WO)
RTC_I2C_ACK_ERR_INT_CLR RTC_l2C_ACK_ERF_INT interrupt clear bit. (WO)
RTC_I2C_RX_DATA_INT_CLR RTC_l2C_RX_DATA_INT interrupt clear bit. (WO)
RTC_I2C_TX_DATA_INT_CLR RTC_l2C_TX_DATA_INT interrupt clear bit. (WO)
RTC_I2C_DETECT_START_INT_CLR RTC_l2C_DETECT_START_INT interrupt clear bit. (WO)

Espressif Systems 576 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.24: RTC_l2C_INT_RAW_REG (0x0028)

£94040 4O4O4O4O

PEELS

Z,

OO

<

 

| 8

SEL EL EEE
1

7)6]5 4/3 ]2

 

 

o| 0

 

ofo}ol]o}lo}]olo] o Reset

 

 

 

 

 

 

 

 

 

 

RTC_l2C_SLAVE_TRAN_COMP_INT_RAW RTC_|2C SLAVE_TRAN_COMP_INT interrupt raw bit.

(RO)

RTC_I2C_ARBITRATION_LOST_INT_RAW RTC_|2C_ ARBITRATION _LOST_INT interrupt raw bit.

(RO)

RTC_I2C_MASTER_TRAN_COMP_INT_RAW RTC_|l2C_MASTER_TRAN_COMP_INT interrupt raw

bit. (RO)

RTC_I2C_TRANS_COMPLETE_INT.RAW RTC_I2C_ TRANS COMPLETE_INT interrupt raw bit.

(RO)

RTC_l2C_TIME_OUT_INT_RAW RTC_[2C_TIME_OUT_INT interrupt raw bit. (RO)

RTC_l2C_ACK_ERR_INT_RAW RTC_I2C_ACK_ ERR _INT interrupt raw bit. (RO)

RTC_l2C_RX_DATA_INT_RAW RTC_|l2C_RX_DATA INT interrupt raw bit. (RO)

RTC_l2C_TX_DATA_INT_RAW RTC_|I2C_TX_DATA_INT interrupt raw bit. (RO)

RTC_l2C_DETECT_START_INT_RAW RTC_|2C_DETECT_START_INT interrupt raw bit. (RO)

Espressif Systems

s/f

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
27. ULP Coprocessor

 

Register 27.25: RTC_l2C_INT_ST_REG (0x002C)

Da
KA K&7S
on
KZA
<P SSNS?
Sin Bb LEES
ve SELES S

a
& OXKOKOKOKOKOKOKOZ KO
€ SESE SEE

[1 lelrfels[ele]e]i fo]

[o °000000000000000000000 ofofofofolofol[o]o]o IRreset

 

 

 

RTC_I2C_SLAVE_TRAN_COMP_INT_ST RTC_l2C_SLAVE_TRAN_COMP_INT interrupt status bit.
(RO)

RTC_I2C_ARBITRATION_LOST_INT_ST RTC_l2C_ARBITRATION_LOST_INT interrupt status bit.
(RO)

RTC_I2C_MASTER_TRAN_COMP_INT_ST RTC_12C_MASTER_TRAN_COMP_INT interrupt status
bit. (RO)

RTC_I2¢_TRANS_COMPLETE_INT_ST RTC_I2C_TRANS_COMPLETE_INT interrupt status bit.
(RO)

RTC_l2C_TIME_OUT_INT_ST RTC_l2C_TIME_OUT_INT interrupt status bit. (RO)
RTC_l2C_ACK_ERR_INT_ST RTC_l2C_ACK_ERRF_INT interrupt status bit. (RO)
RTC_l2C_RX_DATA_INT_ST RTC_l2C_RX_DATA INT interrupt status bit. (RO)
RTC_l2C_TX_DATA_INT_ST RTC_l2C_TX_DATA _INT interrupt status bit. (RO)

RTC_l2C_DETECT_START_INT_ST RTC_I2C_DETECT_START_INT interrupt status bit. (RO)

Espressif Systems 578 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

Register 27.26: RTC_l2C_INT_ENA_REG (0x0030)

RTC_l2C_SLAVE_TRAN_COMP_INT_ENA RTC_|2C_SLAVE_TRAN_COMP_INT interrupt enable

bit. (RAW)
RTC_I2C_ARBITRATION_LOST_INT_ENA RTC_I2C_ARBITRATION_LOST_INT interrupt enable bit.
(RW)
RTC_I2C_MASTER_TRAN_COMP_INT_ENA RTC_12C_MASTER_TRAN_COMP_INT interrupt en-
able bit. (R/W)

RTC_I2C_TRANS_COMPLETE_INT_ENA RTC_|l2C_TRANS COMPLETE_INT interrupt enable bit.
(RW)

RTC_l2C_TIME_OUT_INT_ENA RTC_|2C_TIME_OUT_INT interrupt enable bit. (R/W)

RTC_l2C_ACK_ERR_INT_ENA RTC _|2C_ACK_ERR_INT interrupt enable bit. (RAM)

RTC_l2C_RX_DATA_INT_ENA RTC_I2C_RX_DATA INT interrupt enable bit. (R/W)

RTC_l2C_TX_DATA_INT_ENA RTC_|2C_TX_DATA_INT interrupt enable bit. (RAW)

RTC_l2C_DETECT_START_INT_ENA RTC_l2C_DETECT_START_INT interrupt enable bit. (RAV)

Register 27.27: RTC_l2C_DATA_REG (0x0034)

 

 

 

 

X
¥ oo e
“ A
Ss Ss x
7 S C7 O7
of sf oF oF
€ & € €
| 31 | 30 6 | 15 8 | 7 0 |
| 0 [o 0000000000000 o| Ox0 | Ox0 |Reset
RTC_I2C_RDATA Data received. (RO)
RTC _I2C_ SLAVE _TX_DATA The data sent by slave. (RW)
RTC_I2C_ DONE RTC PC transmission is done. (RO)
Espressif Systems 579 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.28: RTC_l2C_CMD0O_REG (0x0038)

 

 

 

¥Y
eS
oe &
we &
> s
? 5 or
of s e oe
&€ & €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000 00000 o| 0x903 |Reset

 

RTC_I2C_ COMMANDO Content of command 0. For more information, please refer to the register
12C_COMDO_REG in Chapter I2C Controller. (RAV)

RTC_I2C_ COMMANDO DONE When command 0 is done, this bit changes to 1. (RO)

Register 27.29: RTC_I2C_CMD1_REG (0x003C)

 

 

 

&
Ss
3 3
S S
& ws
Oo O
Oo S Oo
of ° s e of °
€ & &€
| 31 | 30 14 | 13 ° |
| 0 | 0000000000000 000 0 | 0x1901 |Reset

 

RTC_I2C_ COMMAND1 Content of command 1. For more information, please refer to the register
12C_COMD1_REG in Chapter I2C Controller. (RAV)

RTC_I2C_ COMMAND1_ DONE When command 1 is done, this bit changes to 1. (RO)

Register 27.30: RTC_l2C_CMD2_REG (0x0040)

 

 

 

ow
Q
eV oo
“ “
ww wr
3s NS
Qo Oo
oF S oF
ov & ow
f & f
&€ € €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000000 00 o| 0x902 |Reset

 

RTC_I2C_ COMMAND2 Content of command 2. For more information, please refer to the register
12C_COMD2_REG in Chapter I2C Controller. (RAV)

RTC_I2C_ COMMAND2 DONE When command 2 is done, this bit changes to 1. (RO)

Espressif Systems 580 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.31: RTC_l2C_CMD3_REG (0x0044)

 

 

 

¥Y
eS
oe &
we &
> s
? 5 or
of gf oe
&€ & €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000 00000 o| Ox101 |Reset

 

RTC_I2C_ COMMAND3 Content of command 3. For more information, please refer to the register
12C_COMDS3_REG in Chapter I2C Controller. (RAV)

RTC_I2C_ COMMAND3_ DONE When command 3 is done, this bit changes to 1. (RO)

Register 27.32: RTC_l2C_CMD4_REG (0x0048)

 

 

 

&
x
oO &
= =
& ws
© O
Oo S Oo
of ° s e of “
& & €
| 31 | 30 4 | 13 ° |
[ofo 0 0 09 0 9 9 009 00090 0 0 9] 0x901 |Reset

 

RTC _I2C_ COMMAND4 Content of command 4. For more information, please refer to the register
12C_COMD4_REG in Chapter I2C Controller. (RAV)

RTC_I2C_COMMAND4 DONE When command 4 is done, this bit changes to 1. (RO)

Register 27.33: RTC_I2C_CMD5_REG (0x004C)

 

 

 

¥Y
eS
{7 Kay
= ©
ww wr
3s NS
Qo Oo
oe S oF
ov & ow
7 &§ 4
&€ € €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000000 00 o| Ox1701 |Reset

 

RTC_I2C_ COMMANDS Content of command 5. For more information, please refer to the register
12C_COMD5_REG in Chapter I2C Controller. (RAV)

RTC_I2C_COMMAND5 DONE When command 5 is done, this bit changes to 1. (RO)

Espressif Systems 581 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.34: RTC_l2C_CMD6_REG (0x0050)

 

 

 

¥Y
eS
O7 ©
g g
we &
> s
? 5 or
of s e oe
&€ & €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000 00000 o| Ox1 901 |Reset

 

RTC_I2C_ COMMAND6 Content of command 6. For more information, please refer to the register
12C_COMD6_REG in Chapter I2C Controller. (RAV)

RTC_I2C_ COMMAND6 DONE When command 6 is done, this bit changes to 1. (RO)

Register 27.35: RTC_l2C_CMD7_REG (0x0054)

 

 

 

<
3” $
= =
& ws
© O
Oo S Oo
of ° s e of “

& € é
| 31 | 30 4 | 13 ° |
[ofo 0 0 09 0 9 9 009 00090 0 0 9] 0x04 |Reset

 

RTC_I2C_ COMMAND? Content of command 7. For more information, please refer to the register
|2C_COMD7_REG in Chapter I2C Controller. (RAV)

RTC_I2C_COMMAND7_DONE When command 7 is done, this bit changes to 1. (RO)

Register 27.36: RTC_l2C_CMD8_REG (0x0058)

 

 

 

¥Y
eS
Q &
= ©
ww wr
3s NS
Qo Oo
oF S oF
ov & ow
f & f
&€ € €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000000 00 o| 0x1901 |Reset

 

RTC_I2C_ COMMAND8 Content of command 8. For more information, please refer to the register
12C_COMD8_REG in Chapter I2C Controller. (RAV)

RTC_I2C_COMMAND8 DONE When command 8 is done, this bit changes to 1. (RO)

Espressif Systems 582 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.37: RTC_l2C_CMD9_REG (0x005C)

 

 

 

¥Y
s
we S&
we &
> s
? 5 or
of s e oe
&€ & €
| 31 | 30 14 | 13 ° |
| 0 | 00000000000 00000 o| 0x903 |Reset

 

RTC_I2C_ COMMAND9 Content of command 9. For more information, please refer to the register
12C_COMD9_REG in Chapter I2C Controller. (RAV)

RTC_I2C_ COMMAND9 DONE When command 9 is done, this bit changes to 1. (RO)

Register 27.38: RTC_I2C_CMD10_REG (0x0060)

 

 

¥
es
O74 9
& =
eS ~
& &
.
a ra of “
7 of 4

&é & €

31 30 14] 13 oO
010 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Ox101 Reset

 

 

 

 

 

RTC_I2C_ COMMAND10 Content of command 10. For more information, please refer to the register
12C_COMD10_REG in Chapter l?C Controller. (RAV)

RTC_I2C_ COMMAND10_ DONE When command 10 is done, this bit changes to 1. (RO)

Register 27.39: RTC_I2C_CMD11_REG (0x0064)

 

 

 

&
Ss
od ~.
OQ OQ
« «
ww wr
S Ss
Oo N Oo
a ra of “
f FS f
& € &€
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000000 00 o| 0x901 |Reset

 

RTC_I2C_ COMMAND11 Content of command 11. For more information, please refer to the register
12C_COMD11_REG in Chapter l?C Controller. (RAV)

RTC_I2C_ COMMAND11_DONE When command 11 is done, this bit changes to 1. (RO)

Espressif Systems 583 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.40: RTC_l2C_CMD12_REG (0x0068)

 

 

 

&
s
XW xv
QO QO
“ “
ws wr
3s NS
Qo Oo
oF S oF
ov & ow
7 &§ 4
&€ € €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000000 00 o| Ox1701 |Reset

 

RTC _I2C_ COMMAND12 Content of command 12. For more information, please refer to the register
12C_COMD12_REG in Chapter l?C Controller. (RAV)

RTC_I2C_ COMMAND12_DONE When command 12 is done, this bit changes to 1. (RO)

Register 27.41: RTC_l2C_CMD13_REG (0x006C)

 

 

&
es
ora %
& ©
RS SS
O O
9 S ?
oe s oF
f S f
&é & €
31 30 14] 13 oO
010 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0x1901 Reset

 

 

 

 

 

RTC_I2C_ COMMAND13 Content of command 13. For more information, please refer to the register
12C_COMD13_REG in Chapter l2?C Controller. (RAV)

RTC_I2C_ COMMAND13 DONE When command 18 is done, this bit changes to 1. (RO)

Register 27.42: RTC_I2C_CMD14_REG (0x0070)

 

 

 

 

&
ss
oY s
S Ss
o . o
oa os of
é € €
| 31 | 30 14 | 13 0 |
| a fo 000000000000 000 | x00 |Reset
RTC_I2C_ COMMAND14 Content of command 14. For more information, please refer to the register
12C_COMD14_REG in Chapter I?C Controller. (RAV)
RTC_I2C_ COMMAND14 DONE When command 14 is done, this bit changes to 1. (RO)
Espressif Systems 584 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
27. ULP Coprocessor

 

Register 27.43: RTC_I2C_CMD15_ REG (0x0074)

 

 

 

&
eS
7 ©
S So
“ “
ws wr
3s NS
Qo Oo
oF S oF
ov & ow
7 &§ 4
&€ € €
| 31 | 30 14 | 13 ° |
| 0 [o 0000000000000 00 o| x00 |Reset

 

RTC_I2C_ COMMAND15 Content of command 15. For more information, please refer to the register
12C_COMD15_REG in Chapter l?C Controller. (RAV)

RTC_I2C_ COMMAND15 DONE When command 15 is done, this bit changes to 1. (RO)

Register 27.44: RTC_l2C_DATE_REG (0x00FC)

 

 

 

| Reset

 

S\ &
ra f”
& &
| 31 28 | 7 0 |
foo 9 of 0x1905310
RTC_I2C_ DATE Version control register (RAW)
Espressif Systems 585 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

28. Low-power Management

28.1 Introduction
ESP32-S2 has an advanced Power Management Unit (PMU), which can flexibly power up different power

domains of the chip, to achieve the best balance among chip performance, power consumption, and wakeup
latency. To simplify power management for typical scenarios, ESP82-S2 has predefined five power modes, which
are preset configurations that power up different combinations of power domains. On top of that, the chip also
allows the users to independently power up any particular power domain to meet more complex requirements.
ESP32-S2 has integrated two Ultra-Low-Power co-processors (ULP co-processors), which allow the chip to
work when most of the power domains are powered clown, thus achieving extremely low-power

consumption.

28.2 Features

ESP32-S2’s low-power management supports the following features:
e ULP co-processors supported in all power modes
° Five predefined power modes to simplify power management for typical scenarios
* Up to 16 KB of retention memory
* 8x 32-bit retention registers
* RTC Boot supported for reduced wakeup latency

In this chapter, we first introduce the working process of ESP382-S2’s low-power management, then introduce
the predefined power modes of the chip, and at last, introduce the RTC boot of the chip.

28.3 Functional Description
ESP32-S2’s low-power management involves the following components:

* Power management unit: controls the power supply to Analog, RTC and Digital power domains.

* Power isolation unit: isolates different power domains, so any powered down power domain does not
affect the powered up ones.

* Low-power clocks: provide clocks to power domains working in low-power modes.
° Timers:
— RTC timer: logs the status of the RTC main state machine in dedicated registers.

— ULP timer: wakes up the ULP co-processors at a predefined time. For details, please refer to Chapter
27 ULP Coprocessor.

— Touch sensor timer: wakes up the touch sensor at a predefined time.

* 8 x 32-bit “always-on” retention registers: These registers are always powered up and can be used for
storing data that cannot be lost.

® 22 x “always-on” pins: These pins are always powered up and can be used as wakeup sources when the
chip is working in the low-power modes (for details, please refer to Section 28.4.4), or can be used as
regular GPIQOs (for details, please refer to Chapter 5 /O MUX and GPIO Matrix).

Espressif Systems 586 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

* RTC slow memory: supports 8 KB SRAM, which can be used as retention memory or to store ULP

directives and data.
* RTC fast memory: supports 8 KB SRAM, which can be used as retention memory.
* Regulators: regulate the power supply to different power domains.

The schematic diagram of ESP32-S2’s low-power management is shown in Figure 28-1.

VDD3P3_RTC_IO VDD3P3_CPU VDDA1 VDDA2 VDD_RTC

ESP32-S2 a | tf

 

 

 

 

 

Low Power Digital System Flash

Voltage — Voltage Voltage
Regulator Regulator Regulator

Analog
fi | VDD_SPI

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

XPD_RTC_REG
XPD_DIG_REG ® CPU
XPD_SDIO_REG
ROM
xpd_dg_wrap
xpd_wifi
xpd_rte
xpd_ric_mem } Internal SRAMx.
xpd_fast_te_mem |
Peripherals
Digital Core
Slow
Memory
& MAC BB
Fast
Memory
P M a
ower hte W-Fi Circuits
RTC Digital

 

 

 

 

 

 

 

 

 

Figure 28-1. Low-power Management Schematics

28.3.1 Power Management Unit
ESP32-S2’s power management unit controls the power supply to different power domains. The main
components of the power management unit include:

* RTC main state machine: generates power gating, clock gating, and reset signals.

* Power controllers: power up and power down different power domains, according to the power gating

signals from the main state machine.

® Sleep / wakeup controllers: send sleep or wakeup requests to the RTC main state machine.

* Clock controller: selects and powers up / down clock sources.

Espressif Systems 587 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

In ESP32-S2’s power management unit, the sleep / wakeup controllers send sleep or wakeup requests to the
RTC main state machine, which then generates power gating, clock gating, and reset signals. Then, the power
controller and clock controller power up and power down different power domains and clock sources, according
to the signals generated by the RTC main state machine, so that the chip enters or exits the low-power modes.
The main workflow is shown in Figure 28-2.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Zz &
iw 2 Digital Power Controller
g 9
oD a
% o Wi-Fi Digital Core
Power Controller | Power Controller
RTC Memory ROM / RAM
Power Controller | Power Controller
Sleep Clock Analog RTC Peripheral Protection
Controller Controller Power Controller Power Controller Timer
4 A
alo clo clo clo w|® clo
g18 als als ala @|S ‘als
als e|S Els E|8 318 Ela
RTC Main State Machine
A 4 A
3
8
a He 5 S| o
a ots a ge
4 eB 4 as
| ° |
Oo
s
ULP trig ULP- Touch trig | Touch £
Timer coprocessor Timer Controller =
2
oO
Q)
| 2
QD a
x x
o o
= |
Wakeup Controller
Z|
- Boa Q oa ora
gc 8 ga 3 ae <3 PES
gD SD > coo
. nix Ox Ox x t¢x
RTC Main c a” sg og g $353
Timer 2 Ee =

 

 

 

Figure 28-2. Power Management Unit Workflow

 

Note:
For more detailed description about power domains, please refer to 28.4.2.

 

 

 

Espressif Systems 588 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

28.3.2 Low-Power Clocks

In general, ESP82-S2 powers down its 40 MHz crystal oscillator and PLL to reduce power consumption when
working in low-power modes. During this time, the chip’s low-power clocks remain on to provice clocks to
different power domains, such as the power management unit, RTC peripherals, RTC fast memory, RTC slow
memory, and Wi-Fi digital circuits in the digital domain.

 

fast_clk_sel *
ULP-coprocessor

 

 

 

XTAL_CLK

 

div 4 Sensor controllers

rtc_fast_clk

 

 

 

 

RTC8M_CLK RTC slow memory

 

div n

 

 

 

 

 

 

 

RTC registers

 

 

 

* fast_clk_sel + RTC_CNTL_REG_FAST_CLK_SEL

Figure 28-3. Low-Power Clocks for RTC Power Domains

slow_clk_sel*

 

 

 

 

RTC_CLK
+l) RTC timers
XTAL32K_CLK rtc_slow_clk [’
8M_D256_CLK Li
2 PMU

 

 

 

 

* slow_clk_sel > RTC_CNTL_REG_ANA_CLK_RTC_SEL

Figure 28-4. Low-Power Clocks for RTC Power Domains

sel_xtal_32k

CK_XTAL_32K a
——C lock Gating

sel_8m
CK8M_OUT* a
———*C lock Gating"

 

 

 

 

 

 

 

clk32k_mux
sel_ric_slow div n low_power_clk Wi-Fi

slow_clk_rtc “

sel_xtal
CK_40M_DIG Z

 

 

 

 

 

 

 

 

* Default Selection

sel_xtal_32k —- SYSTEM_REG_LPCLK_SEL_XTAL32K
sel_8m — SYSTEM_REG_LPCLK_RTC_SLOW
sel_rtc_slow > SYSTEM_REG_LPCLK_SEL_8M
sel_xtal — SYSTEM_REG_LPCLK_SEL_XTAL

Figure 28-5. Low-Power Clocks for RTC Fast Memory and Slow Memory

Espressif Systems 589 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Table 151: Low-Power Clocks

 

 

 

 

Clock Type Clock Source Selection Option Power Domain
RTC8M_CLK divided by n ! RTC peripherals
RTC fast clock RTC_CNTL_REG_FAST_CLK_RTC_SEL} RTC fast memory

XTAL_CLK divided by 4

 

RTC slow memory

 

 

 

 

 

 

 

XTAL32K_CLK

RTC slow clock RTC8M_D256_CLK RTC_CNTL_REG_ANA_ CLK_RTC_SEL | Power management unit
RTC_CLK 2
XTAL32K_CLK SYSTEM_LPCLK_SEL_XTAL32K

Low-Power clocks | RTC8M_CLK SYSTEM_LPCLK_SEL_8M Digital system (Wi-Fi)
RTC_CLK SYSTEM_LPCLK_RTC_SLOW in low-power modes
XTAL_CLK SYSTEM_LPCLK_SEL_XTAL

 

 

 

 

 

 

 

Note:
1. The default RTC fast clock source.

2. The default RTC slow clock source.

 

 

 

For more detailed description about clocks, please refer to 2 Reset and Clock,

28.3.3 Timers

ESP32-S2’s low-power management uses 83 timers:
* RTC timer
© ULP timer
* Touch sensor timer

This section only introduces the RTC timer. For detailed description of ULP timer and touch sensor timer, please
refer to Chapters 27 ULP Coprocessor.

The readable 48-bit RTC timer is a real-time counter (using RTC slow clock) that can be configured to log the
time when one of the following events happens. For details, see Table 152.

Table 152: The Triggering Conditions for the RTC Timer

 

Enabling Options Descriptions

 

1. RTC main state machine powers down; 2. 40 MHz crystal
RTC_CNTL_REG_TIMER_XTL_OFF
powers up.

 

CPU enters or exits the stall state. This is to ensure the
SYS_TIMER is continuous in time.
RTC_CNTL_REG_TIMER_SYS_RST Resetting digital system completes.

Register RTC_CNTL_RTC_TIME_UPDATE is configured by
CPU (i.e. users).

RTC_CNTL_REG_TIMER_SYS_STALL

 

 

RTC_CNTL_REG_TIME_UPDATE

 

 

 

 

The RTC timer updates two groups of registers upon any new trigger. The first group logs the information of the
current trigger, and the other logs the previous trigger. Detailed information about these two register groups is

Espressif Systems 590 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

shown below:
e Register group 0: logs the status of RTC timer at the current trigger.
-— RTC_CNTL_TIME_HIGHO_REG
-— RTC_CNTL_TIME_LOWO0_REG
* Register group 1: logs the status of RTC timer at the previous trigger.
- RTC_CNTL_TIME_HIGH1_REG
- RTC_CNTL_TIME LOW1_REG

On anew trigger, information on previous trigger is moved from register group 0 to register group 1 (and the
original trigger logged in register group 1 is overrode), and this new trigger is logged in register group O.
Therefore, only the last two triggers can be logged at any time.

lt should be noted that any reset / sleep other than power-up reset will not stop or reset the RTC timer.

Also, the RTC timer can be used as a wakeup source. For details, see Section 28.4.4.

28.3.4 Regulators
ESP32-S2 has three regulators to regulate the power supply to different power domains:

* Digital system voltage regulator for digital power domains;
* Low-power voltage regulator for RTC power domains;

* Flash voltage regulator for the rest of power domains.

 

Note:
For more detailed description about power domains, please refer to Section 28.4.2.

 

 

 

28.3.4.1 Digital System Voltage Regulator

ESP32-S2’s built-in digital system voltage regulator converts the external power supply (typically 3.3 V) to 1.1 V
for digital power domains. This regulator has an adjustable output. For the architecture of the ESP82-S2 digital
system voltage regulator, see Figure 28-6.

Espressif Systems 591 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

 

VDD3P3_CPU
VDD3P3_RTC_IO

   
  

11V (0.85V - 1.2)

Digital System

Figure 28-6. Digital System Regulator

ESP32-S2

 

 

1. When XPD_DIG_REG == 1, the regulator outputs a 1.1 V voltage and the power domains in digital system
are able to run; when XPD_DIG_REG == 0, both the regulator and the power domains in digital system
stop running.

2. DIG_REG_DBIAS[2:0] tunes the supply voltage of the digital system:

VDD_DIG = 0.90 + DBIAS x 0.05V

8. The current to power domains in digital system comes from pin VDD3P3_CPU and pin VDD3P3_RTC_IO.

28.3.4.2 Low-power Voltage Regulator

ESP32-S2’s built-in low-power voltage regulator converts the external power supply (typically 3.3 V) to 1.1 V for
RTC power domains. This regulator has an adjustable output to achieve lower power consumption and can
output even lower voltage in Deep-sleep mode and Hibernation mode. For the architecture of the ESP382-S2
low-power voltage regulator, see Figure 28-1.

 

VDD3P3_RTC_IO

dbiag[2:0]

“24

VREF

1.1V

RTC
ESP32-S2

 

 

Figure 28-7. Low-power voltage regulator

Espressif Systems 592 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

1. When the pin CHIP_PU is at a high level, the low-power voltage regulator cannot be turned off, but only
switching between normal-work mode and Deep-sleep mode.

2. RTC_DBIAS[2:0] can be used to tune the output voltage:
VDD_RTC = 0.90 + DBIAS x 0.05V

3. The current to the RTC power domains comes from pin VDDSP3_RTC_IO.

28.3.4.3 Flash Voltage Regulator

ESP32-S2’s built-in flash voltage regulator can supply a voltage of 3.3 V or 1.8 V to other components outside of
digital system and RTC, such as flash. For the architecture of the ESP32-S2 flash voltage regulator, see Figure
28-8.

 

VDD3P3_RTC_IO
drefh, drefm, drefl

VREF

 

 

 

 

 

VDD_SPI
Regulator

Output

 

1. SD gs
vv

ESP32-S2

 

 

 

Figure 28-8. Flash voltage regulator

1. When XPD_SDIO_VREG == 1, the regulator outputs a voltage of 3.3 V or 1.8 V; when XPD_SDIO_VREG
== 0, the output is high-impedance. In this case, the voltage is provided by the external power supply.

2. When SDIO_TIEH == 1, the regulator shorts pin VDD_SDIO to pin VDDSP3_RTC, and outputs a voltage of
3.3 V, which is the voltage of pin VDD3P3_RTC. When SDIO_TIEH == 0, the regulator outputs the
reference voltage VREF, which is typically 1.8 V.

3. DREFH_SDIO, DREFM_SDIO and DREFL_SDIO could be used to fine tune the reference voltage VREF, but
are not recommended because this fine tuning may jeopardize the stability of the inner loop.

4. When the regulator output is 3.3 V or 1.8 V, the output current comes from the pin VDD3P3_RTC_IlO.
The flash voltage regulator can be configured via RTC registers or eFuse controller registers.
* The configuration of XPD_SDIO_VREG:

- When the chip is in active mode, RTC_CNTL_SDIO_FORCE == 0 and VDD_SPI_FORCE(EFUSE) ==
1, the XPD_SDIO_VREG voltage is defined by XPD_VDD_SPI_REG(EFUSE);

— When the chip is in sleep modes and RTC_CNTL_SDIO_REG_PD_EN == 1, XPD_SDIO_VREG is 0;

Espressif Systems 593 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

-— When RTC_CNTL_SDIO_FORCE == 1, XPD_SDIO_VREG is defined by RTC_CNTL_XPD_SDIO_REG.
° The configuration of SDIO_TIEH:

- When RTC_CNTL_SDIO_FORCE == 0 and VDD_SPI_FORCE(EFUSE) == 1, SDIO_TIEH =
VDD_SDIO_TIEH(EFUSE)

- Otherwise, SDIO_TIEH = RTC_CNTL_SDIO_TIEH.

28.3.4.4 Brownout Detector

The brownout detector checks the voltage of pins VDDSP3_RTC_lO, VDD3P3_CPU, VDDA1, and VDDA2. If the
voltage of these pins drops rapidly and becomes too low, the detector would trigger a signal to shut down some
power-consuming blocks (such as LNA, PA, etc.) to allow extra time for the digital system to save and transfer
important data.

The brownout detector has ultra-low power consumption and remains enabled whenever the chip is powered up.
For the architecture of the ESP32-S2 brownout detector, see Figure 28-9.

 

 
  
 
 
   

ESP32-S2
thres[2:0]

VREF

VDD3P3_RTC_IO
VDD3P3_CPU
VDDA1

VDDA2

Brownout
detected

 

 

 

Figure 28-9. Brown-out detector

1. RTC_CNTL_RTC_BROWN_OUT_DET indicates the output level of brown-out detector. This register is low
level by default, and outputs high level when the voltage of the detected pin drops below the predefined
threshold;

2. |2C register ULP_CAL_REG5[2:0] configures the trigger threshold of the brown-out detector;

Table 153: Brown-out Detector Configuration

 

ULP_CAL_REGS§[2:0] | VDD (Unit: V)
2.67
3.30
3.19
2.98
2.84
2.67
2.56
2.44

 

 

 

 

 

 

 

 

NN] O}ao}&}]a]rm]-] of!

 

 

 

 

Espressif Systems 594 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

38. RTC_CNTL_REG_BROWN_OUT_RST_SEL configures the reset type.
* 0: resets the chip

* 1: resets the system

 

Note:
For more information regarding chip reset and system reset, please refer to 2 Reset and Clock.

 

 

 

28.4 Power Modes Management

28.4.1 Power Domain
ESP32-S2 has 10 power domains in three power domain categories:

¢ RIC

— Power management unit

RTC peripherals

RTC slow memory

— RTC fast memory
* Digital

— Digital core

— Wi-Fi digital circuits
* Analog

-— 8 MHZ crystals

40 MHz crystals
- PLL

FF circuits

28.4.2 RTC States
ESP32-S2 has three main RTC states: Active, Monitor, and Sleep. The transition process among these states
can be seen in Figure 28-10,

Espressif Systems 595 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

 

 

ULP done or touch done

 

ULP timer or touch timer

 

 

Figure 28-10. RTC States

Under different RTC states, different power domains are powered up or down by default, but can also be

force-powered-up (FPU) or force-powered-down (FPD) individually based on actual requirements. For details,

please refer to Table 154.

Table 154: RTC Statues Transition

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Power Domain RTC States Not
otes
Category Sub-category Active | Monitor | Sleep
Power Management Unit ON ON ON I
RIC RTC Peripherals ON ON OFF 2
RTC Slow Memory ON OFF OFF 3
RTC Fast Memory ON OFF OFF 4
, Digital Core ON OFF OFF 5
Digital oe, ,
Wi-Fi Digital Circuits ON OFF OFF 6
8 MHz Crystals ON ON OFF -
40 MHz Crystals ON OFF OFF -
Analog
PLL ON OFF OFF -
RF Circuits - - - -

 

 

 

 

 

 

Note:

 

sensor, SAR ADC controller).

force-power-on.

by CPU via IRAMO / DRAMO, and should be forced-power-up.

Espressif Systems

596

. ESP32-S2’s power management unit is specially designed to be “always-on”, which means it is always on when
the chip is powered up. Therefore, users cannot FPU or FPD the power management unit.

. The RTC peripherals include 27 ULP Coprocessor and on-chip sensor (i.e. temperature sensor controller, touch

. RTC slow memory supports 8 KB SRAM, which can be used to reserve memory or to store ULP instructions and
/ or data. This memory can be accessed by CPU via PeriBUS2 (starting address is Ox50000000), and should be

. RTC fast memory supports 8 KB SRAM, which can be used to reserve memory. This memory can be accessed

. When the digital core of the digital system is powered down, all components in the digital system are turned off.

Submit Documentation Feedback

 

ESP32-S2 TRM (Preliminary V0.4)
28. Low-power Management

 

It’s worth noting that, ESP32-S2’s ROM and SRAM are no longer controlled as independent power domains, thus
cannot be force-powered-up or force-powered-down when the digital core is powered down.

6. Power domain Wi-Fi digital circuits includes Wi-Fi MAC and BB (Base Band).

 

28.4.3 Pre-defined Power Modes
As mentioned earlier, ESP32-S2 has five power modes, which are predefined configurations that power up
different combinations of power domains. For details, please refer to Table 155.

Table 155: Predefined Power Modes

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Power Power Domain

Modes PMU | RTC | RTC | RTC | Digital | Wi-Fi | 8MHz | 40 PLL RF
Pe- Slow Fast Core Digital | Crys- | MHz Cir-
ripher- | Mem- | Mem- Cir- tals Crys- cuits
als ory ory cuits tals

Active ON ON ON ON ON ON ON ON ON ON

Modem-sleep ON ON ON ON ON ON * ON ON ON OFF

Light-sleep ON ON ON ON ON ON * OFF OFF OFF OFF

Deep-sleep ON ON ON ON OFF OFF OFF OFF OFF OFF

Hibernation ON OFF OFF OFF OFF OFF OFF OFF OFF OFF

Note:

* Configurable

 

 

 

By default, ESP32-S2 first enters the Active mode after system resets, then enters different low-power modes
(including Modem-sleep, Light-sleep, Deep-sleep, and Hibernation) to save power after the CPU stalls for a
specific time (For example, when CPU is waiting to be wakened up by an external event). From modes Active to
Hibernation, the performance? and power consumption? decreases and wakeup latency increases. Also, the
supported wakeup sources for different power modes are different®. Users can choose a power mode based on
their requirements of performance, power consumption, wakeup latency, and available wakeup sources.

 

Note:

1. For details, please refer to Table 155.

2. For details on power consumption, please refer to the Current Consumption Characteristics in ESP32-S2 Datasheet.

 

 

3. For details on the supported wakeup sources, please refer to Section 28.4.4.

 

28.4.4 Wakeup Source
The ESP82-S2 supports various wakeup sources, which could wake up the CPU in different sleep modes. The
wakeup source is determined by RTC_CNTL_REG_RTC_WAKEUP_ENA as shown in Table 156.

Espressif Systems 597 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Table 156: Wakeup Source

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

oOo N OO &

oO

 

. Awakeup is triggered when any touch event is detected by the touch sensor.

10. A wakeup is triggered when the USB host sends USB into the RESUMING state.

WAKEUP_ENA Wakeup Source Light-sleep | Deep-sleep | Hibernation | Notes*
Ox1 EXTO Y Y - 1
Ox2 EXT1 Y Y Y 2
Ox4 GPIO Y Y - 3
Ox8 RTC timer Y Y Y -
0x20 Wi-Fi Y - - 4
0x40 UARTO Y - - 5
Ox80 UART1 Y - - 5
0x100 TOUCH Y Y - 6
Ox800 ULP-FSM Y Y - 7
0x1000 XTAL_82K Y Y Y 8
0x2000 ULP-RISCV Trap Y Y - 9
Ox8000 USB Y - - 10
Note:

1. EXTO can only wake up the chip from Light-sleep / Deep-sleep modes. If RTC_CNTL_REG_EXT_WAKEUPO_LV is
1, it’s triggered when the pin level is high. Otherwise, it’s triggered when the pin level is low. Users can configure
RTCIO_EXT_WAKEUPO_SEL to select an RTC pin as a wakeup source.

2. EXT1 is especially designed to wake up the chip from any sleep modes, and can be triggered by a combination of
pins. Users should define the combination of wakeup sources by configuring RTC_CNTL_REG_EXT_WAKEUP1
_SEL[17:0] according to the bitmap of selected wakeup source. When RTC_CNTL_REG_EXT_WAKEUP1_LV ==
1, the chip is waken up if any pin in the combination is high level. When RTC_CNTL_REG_EXT_WAKEUP1_LV ==
0, the chip is only waken up if all pins in the combination is low level.

3. In Deep-sleep mode, only the RTC GPIOs (not regular GPIOs) can work as a wakeup source.

. To wake up the chip with a Wi-Fi source, the chip switches between the Active, Modem-sleep, and Light-sleep
modes. The CPU and RF modules are woken up at predetermined intervals to keep Wi-Fi connections active.

. Awakeup is triggered when the number of RX pulses received exceeds the setting in the threshold register.

. Awakeup is triggered when RTC_CNTL_RTC_SW_CPU_INT is configured by the ULP co-processor.

. When the 82 kHz crystal is working as RTC slow clock, a wakeup is triggered upon any detection of any crystal
stops by the 32 kHz watchdog timer.

. Awakeup is triggered when the ULP co-processor starts capturing exceptions (e.g., stack overflow).

 

 

28.5 RTC Boot

The wakeup time for Deep-sleep and Hibernation modes are much longer, compared to the Light-sleep and

Modem-sleep, because the ROMs and RAMs are both powered down in this case, and the CPU needs more

time for ROM unpacking and data-copying from the flash (SPI booting). However, it’s worth noting that both RTC

fast memory and RTC slow memory remain powered up in the Deep-sleep mode. Therefore, users can store

Espressif Systems

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
28. Low-power Management

 

codes (so called “deep sleep wake stub” of up to 8 KB) either in RTC fast memory or RTC slow memory to avoid

the above-mentioned ROM unpacking and SPI booting, thus speeding up the wakeup process.

Method one: Using RTC slow memory

1.
2.

3.

Set RTC_CNTL_PROCPU_STAT_VECTOR_SEL to 0.
Send the chip into sleep.

After the CPU is powered up, the reset vector starts resetting from Ox50000000 instead of Ox40000400,
which does not involve any ROM unpacking and SPI booting. The codes stored in RTC slow memory
starts running immediately after the CPU reset. However, note that the content in the RTC slow memory
should be initialized before sending the chip into sleep.

Method two: Using RTC fast memory

1.

a & WwW

Set RTC_CNTL_PROCPU_STAT_VECTOR_SEL to 1.

. Calculate CRC for the RTC fast memory, and save the result in RTC_CNTL_STORE6_REG[81:0].
. Set RTC_CNTL_STORE?7_REG[S81:0] to the entry address of RTC fast memory.
. Send the chip into sleep.

. ROM unpacking and some of the initialization starts after the CPU is powered up. After that, calculate the

CRC for the RTC fast memory again. If the result matches with register RTC_CNTL_STORE6_REG[S1:0],
the CPU jumps to the entry acdress.

The boot flow is shown in Figure 28-11.

Espressif Systems 599 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Running in ROM
reset_vector@ reset_vector@
0x40000400 0x50000000
Initialization
Cal CRC in Run code in
fast RTC mem RTC mem
4k Running in RTC memory
Yes CRG tight No
Jump to entry
point in SPI Boot
RTC fast mem
Running in RTC fast mem:
Run code in
CPU RAM
Running in CPU RAM

 

 

 

Figure 28-11. ESP32-S2 Boot Flow

When working under low-power modes, ESP32-S2’s 40 MHz crystal oscillator and PLL are usually powered
down to reduce power consumption. However, the low-power clock remains on so the chip can operate properly
under low-power modes.

28.6 Base Address

Users can access the low-power management module of ESP32-S2 with two base addresses, which can be
seen in Table 157. For more information about accessing peripherals from different buses please see Chapter 1
System and Memory.

Table 157: Low-power Management Base Address

 

 

 

Bus to Access Peripheral Base Address
PeriBUS1 Ox3f408000
PeriBUS2 Ox60008000

 

 

 

 

28.7 Register Summary
The addresses in the following table are relative to the Low Power Management base addresses provided in
Section 28.6,

Espressif Systems 600 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access
RTC Option Registers
RTC_CNTL_OPTIONSO_REG Sets the power options of crystal and PLL | OxO0000 | varies
clocks, and initiates reset by software
RTC_CNTL_OPTION1_REG RTC option register 0x0128 | RAV
RTC Timer Registers
RTC_CNTL_SLP_TIMERO_REG RTC timer threshold register 0 Ox0004 | RAV
RTC_CNTL_SLP_TIMER1_REG RTC timer threshold register 1 Ox0008 | varies
RTC_CNTL_TIME_UPDATE_REG RTC timer update control register Ox000C_ | varies
RTC_CNTL_TIME_LOWO0_REG Stores the lower 32 bits of RTC timer 0 0x0010 | RO
RTC_CNTL_TIME_HIGHO_REG Stores the higher 16 bits of RTC timer O 0x0014 | RO
RTC_CNTL_STATEO_REG Configures the sleep / reject / wakeup state 0x0018 | varies
RTC_CNTL_TIMER1_REG Configures CPU stall options Ox001C | RAV
RTC_CNTL_TIMER2_REG Configures RTC slow clock and touch con- | 0x0020 | RAV
troller
RTC_CNTL_TIMER5_REG Configures the minimal sleep cycles Ox002C | RAV
RTC_CNTL_TIME_LOW1_REG Stores the lower 32 bits of RTC timer 1 OxO0E8 | RO
RTC_CNTL_TIME_HIGH1_REG Stores the higher 16 bits of RTC timer 1 OxOOEC | RO
Internal Power Control Register
RTC_CNTL_ANA_CONF_REG Configures the power options for I2C and | 0x0084 | RAV
PLLA
RTC_CNTL_REG_REG Low-power voltage and digital voltage regula- | Ox0084 | RAV
tors configuration register
RTC_CNTL_PWC_REG RTC power configuration register O0x0088 | RAV
RTC_CNTL_DIG_PWC_REG Digital system power configuraiton register Ox008C | RAV
RTC_CNTL_DIG_ISO_REG Digital system isolation configuration register | OxO090 | varies
RTC_CNTL_LOW_POWER_ST_REG RTC main state machine state register Ox00CC | RO
Reset Control Register
RTC_CNTL_RESET_STATE_REG Indicates the CPU reset source 0x0038 | varies
Sleep and Wake-up Control Register
RTC_CNTL_WAKEUP_STATE_REG Wakeup bitmap enabling register Ox003C_ | RAV
RTC_CNTL_EXT_WAKEUP_CONF_REG GPIO wakeup configuration register Ox0064 | RAV
RTC_CNTL_SLP_REJECT_CONF_REG Configures sleep / reject options Ox0068 | RAV
RTC_CNTL_EXT_WAKEUP1_REG EXT1 wakeup configuration register OxO0DC | varies
RTC_CNTL_EXT_WAKEUP1_STATUS_REG]| EXT1 wakeup source register OxOOEO | RO
RTC_CNTL_SLP_REJECT_CAUSE_REG Stores the reject-to-sleep cause 0x0124 | RO
RTC_CNTL_SLP_WAKEUP_CAUSE_REG_ | Stores the sleep-to-wakeup cause 0x012C | RO
Interrupt Registers
RTC_CNTL_INT_ENA_RTC_REG RTC interrupt enabling register 0x0040 | RAV
RTC_CNTL_INT_RAW_RTC_REG RTC interrupt raw register 0x0044 | RO
RTC_CNTL_INT_ST_RTC_REG RTC interrupt state register 0x0048 | RO
RTC_CNTL_INT_CLR_RTC_REG RTC interrupt clear register Ox004C | WO
Reservation Registers
RTC_CNTL_STOREO_REG Reservation register 0 | oxooso | RWW

 

Espressif Systems

601

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
28. Low-power Management

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Name Description Address | Access

RTC_CNTL_STORE1_REG Reservation register 1 0x0054 | RAV

RTC_CNTL_STORE2_REG Reservation register 2 Ox0058 | RAV

RTC_CNTL_STORE3_REG Reservation register 3 Ox005C_ | RAV

RTC_CNTL_STORE4_REG Reservation register 4 OxOOBC | RAV

RTC_CNTL_STORES_REG Reservation register 5 Ox00CO | RAV

RTC_CNTL_STORE6_REG Reservation register 6 Ox00C4 | RAV

RTC_CNTL_STORE7_REG Reservation register 7 Ox00C8 | RAV

Clock Control Registers

RTC_CNTL_EXT_XTL_CONF_REG 82 kHz crystal oscillator configuration register | OxOO60 | varies

RTC_CNTL_CLK_CONF_REG RTC clock configuration register 0x0074 | RAV

RTC_CNTL_SLOW_CLK_CONF_REG RTC slow clock configuration register 0x0078 | RAV

RTC_CNTL_XTALS82K_CLK_FACTOR_REG | Configures the divider for the backup clock of | OxOOFO | RAV
82 kHz crystal oscillator

RTC_CNTL_XTAL82K_CONF_REG 82 kHz crystal oscillator configuration register | OxOOF4 | RAV

RTC Watchdog Control Register

RTC_CNTL_WDTCONFIGO_REG RTC watchdog configuration register 0x0094 | RAV

RTC_CNTL_WDTCONFIG1_REG Configures the hold time of RTC watchdog at | Ox0098 | RAV
level 1

RTC_CNTL_WDTCONFIG2_REG Configures the hold time of RTC watchdog at | OxO09C | RAV
level 2

RTC_CNTL_WDTCONFIG3_REG Configures the hold time of RTC watchdog at | OxOOAO | RAV
level 3

RTC_CNTL_WDTCONFIG4_REG Configures the hold time of RTC watchdog at | OxOOA4 | RAV
level 4

RTC_CNTL_WDTFEED_REG RTC watchdog SW feed configuration register | OxOOA8 | WO

RTC_CNTL_WDTWPROTECT_REG RTC watchdog write protection configuration | OxOOAC | RAV
register

RTC_CNTL_SWD_CONF_REG Super watchdog configuration register Ox00BO | varies

RTC_CNTL_SWD_WPROTECT_REG Super watchdog write protection configura- | OxOOB4 | RAV
tion register

Other Registers

RTC_CNTL_SW_CPU_STALL_REG CPU stall configuration register Ox00B8 | RAV

RTC_CNTL_PAD_HOLD_REG Configures the hold options for RTC GPIOs Ox00D4 | RAV

RTC_CNTL_DIG_PAD_HOLD_REG Configures the hold options for digital GPIOs | OxOOD8 | RAV

RTC_CNTL_BROWN_OUT_REG Brownout configuration register OxO0E4 | varies

 

28.8 Registers

The addresses in this section are relative to the Low Power Management base addresses provided in Section

28.6.

Espressif Systems

602

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)

 
28. Low-power Management

Register 28.1: RTC_CNTL_OPTIONSO_REG (0x0000)

S
Boro DOLD OVO DILDOS

S\ S\ S\

NOS & SOOO SESSA EO SF

oe
O%0%07 O%Z0O KOZ %0%~0%O 404 O7 & Oo
CEE € CLE EEE EEE E FE

31 | 30 | 29 | 28 14] 13 | 12] 11]; 10] 9} s |] 7]o6]5 413 241 °

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

olololo 0 6 6 6 00 00 00 0 0 0 ofifolofolo}o}o}lofolo] o fo olReset

 

RTC_CNTL_REG_SW_STALL_PROCPU_CO When RTC_CNTL_REG_SW_STALL_ PROCPU_C1 is
configured to 0x21, setting this bit to Ox2 stalls the CPU by SW.

RTC_CNTL_SW_PROCPU_RST _ Set this bit to reset the CPU by SW. (WO)
RTC_CNTL_REG_BB_I2C_FORCE_PD Set this bit to FPD BB_l2C. (RW)
RTC_CNTL_REG_BB_I2C_FORCE_PU Set this bit to FPU BB_l2C. (RW)
RTC_CNTL_REG_BBPLL_I2C_FORCE_PD Set this bit to FPD BB_PLL _I2C. (RAN)
RTC_CNTL_REG_BBPLL_I2C_FORCE_PU Set this bit to FPU BB_PLL _l2C. (RAN)
RTC_CNTL_REG_BBPLL_FORCE_PD Set this bit to FPD BB_PLL. (R/W)
RTC_CNTL_REG_BBPLL_FORCE_PU Set this bit to FRU BB_PLL. (R/W)
RTC_CNTL_REG_XTL_FORCE_PD Set this bit to FPD the crystal oscillator. (R/W)
RTC_CNTL_REG_XTL_FORCE_PU Set this bit to FPU the crystal oscillator. (R/W)

RTC_CNTL_REG_DG_WRAP_FORCE RST Set this bit to force reset the digital system in deep-
sleep. (RW)

RTC_CNTL_REG_DG_WRAP_FORCE_NORST Set this bit to disable force reset to digital system in
deep-sleep. (RW)

RTC_CNTL_SW_SYS RST Set this bit to reset the system via SW. (WO)

Espressif Systems 603 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.2: RTC_CNTL_OPTION1_REG (0x0128)

 

[ Te]

joo 0 000000900000 009 0090 000 00 0 0 0 0 0 00 Reset

 

 

RTC_CNTL_REG_FORCE_ DOWNLOAD BOOT ‘Set this bit to force the chip to boot from the down-
load mode. (RAV)

Register 28.3: RTC_CNTL_SLP_TIMERO_REG (0x0004)

 

E |

| 0x000000 | Reset

 

 

RTC_CNTL_REG_SLP_VAL_LO Sets the lower 32 bits of the trigger threshold for the RTC timer.

 

 

 

(RAW)
Register 28.4: RTC_CNTL_SLP_TIMER1_REG (0x0008)
S
ae
Re
Se »
S w
“o
as a
S
& “f “f
& &€ &€
[1 7] 16 [is o|
[fo 0 0 9 0 0 9 0 0 0 0 0 0 0 ofa] 0x00 |Reset

 

RTC_CNTL_REG_SLP_VAL_HI Sets the higher 16 bits of the trigger threshold for the RTC timer.
(RAV)

RTC_CNTL_RTC_MAIN_TIMER_ALARM_EN Sets this bit to enable the timer alarm. (WO)

Espressif Systems 604 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.5: RTC_CNTL_TIME_UPDATE_REG (0x000C)

Ke
x sy V7 IO

S
Y SRS
Or O4O407
So KEE
SELES S
7 Q@ LOZ
EEEE €

[ a1 | 20 | 2» | 2 | 2 [2 o|

o
€

 

 

 

fofofofof[ofo 0 0 9 0 9600000000090 009 09 0 0 09 0 0 0 OfReset

 

RTC_CNTL_REG_TIMER_SYS STALL Selects the triggering condition for the RTC timer. (RAV)
RTC_CNTL_REG_TIMER_XTL_OFF Selects the triggering condition for the RTC timer. (RAM)
RTC_CNTL_REG_TIMER_SYS_RST Selects the triggering condition for the RTC timer. (RAM)

RTC_CNTL_RTC_TIME UPDATE Selects the triggering condition for the RTC timer. (WO)

 

Note:
For details, please refer to Table 152.

 

 

 

Register 28.6: RTC_CNTL_TIME_LOW0_REG (0x0010)

 

 

 

WS
oY
ve
wey
Sy
ws
oe
V7
ss
O7
€
| al 0 |
| 0x000000 | Reset

 

RTC_CNTL_RTC_TIMER_VALUEO_LOW Stores the lower 32 bits of RTC timer 0. (RO)

Espressif Systems 605 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.7: RTC_CNTL_TIME_HIGHO_REG (0x0014)

 

 

 

 

eS
Oo”
S)
wey
Qy
we
wor
S x
e &
| 31 16 | 15 o |
[oo 0 900000000000 9 0x00 |Reset
RTC_CNTL_RTC_TIMER_VALUEO_HIGH Stores the higher 16 bits of RTC timer 0. (RO)
Register 28.8: RTC_CNTL_STATEO_REG (0x0018)
aa
x
sf
» gs
$ g SF os
SES eee
& 8’ 3’ Oe
SX SS e on
LE E & ak

 

[a | 2 | 2 | [=

 

fofofofofo 0 0 09 0 9 0 09 6 9 0 09 9 00900 00 09 00 0 0 Of0] 9 IReset

 

RTC_CNTL_RTC_SW_CPU_INT Sends a SW RTC interrupt to CPU. (WO)

RTC_CNTL_REG_RTC_SLP_REJECT_CAUSE_CLR Clears the RTC reject-to-sleep cause. (WO)

RTC_CNTL_SLP_WAKEUP Sleep wakeup bit. (R/W)

RTC_CNTL_SLP_REJECT Sleep reject bit. (R/W)

RTC_CNTL_REG_SLEEP_EN Sends the chip to sleep. (RW)

Espressif Systems

606

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
28. Low-power Management

Register 28.9: RTC_CNTL_TIMER1_REG (0x001C)

 

 

 

 

 

 

 

 

S$
Yr =
S$ y’ wz
s s S SS &
S we’ & er er
Oo sd e CO
ey ey ey’ ey’ ey
oF oF oF oF gt
€ € € € €
[1 x |2s [13 aE 1] o |
| 40 | 80 Ox10 | 1 [ 7 |Reset
RTC_CNTL_REG_CPU_STALL_EN Enables the CPU stalling. (RAM)
RTC_CNTL_REG_CPU_STALL WAIT Sets the CPU stall waiting cycles (using the RTC fast clock).
(RAV)
RTC_CNTL_REG_CK8M_WAIT Sets the 8 MHz clock waiting cycles (using the RTC slow clock).
(RAV)
RTC_CNTL_XTL_BUF_WAIT Sets the XTAL waiting cycles (using the RTC slow clock). (RW)
RTC_CNTL_PLL_BUF_WAIT Sets the PLL waiting cycles (using the RTC slow clock). (R/W)
Register 28.10: RTC_CNTL_TIMER2_REG (0x0020)
&
xv
§ ee
& or
4 <O
xX SS’
© ss
x e
ey ey
of oe e
€ € &
[1 x |2s 15 |14 o|
| oxt | ox10 Joo 0 9 0 0 0 0 0 9 0 0 0 0 Ofreset
RTC_CNTL_REG_ULPCP_TOUCH_START_WAIT Sets the waiting cycles (using the RTC slow
clock) before the ULP co-processor or touch controller starts to work. (R/W)
RTC_CNTL_REG_MIN_TIME CK8M_OFF Sets the minimal cycles for 8 MHz clock (using the RTC
slow clock) when powered down. (R/W)
Espressif Systems 607 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

Register 28.11: RTC_CNTL_TIMER5 REG (0x002C)

 

 

 

w
f
&
\
o>
&
> ow &
@ OZ a)
& &€ &
[a1 16 [is al o|
fo0 9 00009000000 0 0 9 0x80 jo 0 0 0 0 0 0 O]Reset

 

RTC_CNTL_REG_MIN_SLP_VAL Sets the minimal sleep cycles (using the RTC slow clock). (RAW)

Register 28.12: RTC_CNTL_TIME_LOW1_REG (0x00E8)

 

 

 

ws
y
“e
Ry
Sv
ws
O7
S
Ss
Oo 4
€
[= |
| 0x000000 | Reset

 

RTC_CNTL_RTC_TIMER_VALUE1_ LOW Stores the lower 32 bits of RTC timer 1. (RO)

Register 28.13: RTC_CNTL_TIME_HIGH1_REG (0x00EC)

 

 

 

 

&
NZ
ve
wey
w
Or
S
eo =
& KO?
€ <
[a1 16 [is o|
fo0 9 00009000000 0 0 9 0x00 |Reset
RTC_CNTL_RTC_TIMER_VALUE1_HIGH Stores the higher 16 bits of RTC timer. (RO)
Espressif Systems 608 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

Register 28.14: RTC_CNTL_ANA_CONF_REG (0x0034)

 

 

 

& Sa °
& LSEEEE &
[1 as| 2 | 2s | 2 | 21 | 2 [0 o|
fo 0 0 0 0 0 ofojifofifofo 0 9 9 0 0 89 09 0 0 0 8 0 0 0 9 0 0 0 OlReset

 

RTC_CNTL_REG_GLITCH_RST_EN Set this bit to enable a reset when the system detects a glitch.
(RAV)

RTC_CNTL_REG_SAR_I2C_FORCE_PD Set this bit to FPD the SAR_l2C. (R/W)
RTC_CNTL_REG_SAR_I2C_FORCE_PU Set this bit to FPU the SAR_l2C. (RW)
RTC_CNTL_REG_PLLA_FORCE PD Set this bit to FPD the PLLA. (R/W)

RTC_CNTL_REG_PLLA_FORCE_PU Sets this bit to FPU the PLLA. (R/W)

Espressif Systems 609 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.15: RTC_CNTL_REG_REG (0x0084)

 

 

 

x SX
SX
CO Re
OS & S &/ &?
PoP D Ss sx
Se gee” ¢ 2 OS
OE S gS S & <
O%07 O7 O7 NO/ > >
Le Se ee &
Soe & Ss SS SS Ss SS &
O%07 Q O7 O7 O7 O7 O7
ES FF SF &é &€ &€ &€ &
[ a1 | 2 [2 2a] 27 as | aa afar ws | 10 al o|
[ifofo of 4 [ 4 | 0 | 4 | 4 [o 0 0 0 0 0 0 OJreset

 

RTC_CNTL_REG_DIG_REG_DBIAS_SLP Configures the regulation factor for the digital system volt-
age regulator when the CPU is in sleep state. (RAV)

RTC_CNTL_REG_DIG_REG DBIAS_WAK Configures the regulation factor for the digital system
voltage regulator when the CPU is in active status. (RAV)

RTC_CNTL_REG_SCK_DCAP Configures the frequency of the RTC clocks. (R/W)

RTC_CNTL_REG_RTC_DBIAS SLP Configures the regulation factor for the low-power voltage reg-
ulator when the CPU is in sleep status. (RAV)

RTC_CNTL_REG_RTC_DBIAS_WAK Configures the regulation factor for the low-power voltage reg-
ulator when the CPU is in active status. (RAM)

RTC_CNTL_REG_RTC_ REGULATOR FORCE PD Set this bit to FPD the low-power voltage regu-
lator, which means decreasing its voltage to 0.8 V or lower. (R/W)

RTC_CNTL_REG_RTC_ REGULATOR FORCE PU Set this bit to FPU the low-power voltage regu-
lator, which means increasing its voltage to higher than 0.8 V. (R/V)

Espressif Systems 610 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.16: RTC_CNTL_PWC_REG (0x0088)

 

 

 

O
Oo
o > 2g o g
& » gL » & Oo
9 s SS PL SSL SSS Pg SS
oe SM SK SE KV EK SE SE PX SP SK
x LES LS S& Se SS & S&S & YS oO & &
& SS PPLE EE EE EEE EEE EEE S
SPS IO EO EE SP BE BS BS SS FS SE ES S&S oS
oe Ss ~ of of of Pe ae o” oo ”. oS oe of Ss of of of &
of & ce: s of ss & & & cy & cy & cy & x & c & of ss of
SS EE EEE EE EE E EE E EE E E E EF E
& Ss oo oo a, KS oF oS oS oS * Ss * a
g
& LEE EE EE EE EEE EE EEE EE EEE
[1 22] 21 20 19 8 [a 16 | 1s ufos elufofofe[-[els]f«fe]e[s]e]
[o 0000000 0 ofofofofofo[1fofo]+fo[1fofo]+fofo[1]ofo]1[o] 1 Jreset

 

RTC_CNTL_REG_RTC_FASTMEM_FORCE _NOISO Set this bit to disable the force isolation of the
RTC fast memory. (RAV)

RTC_CNTL_REG_RTC_FASTMEM_FORCE_ISO Set this bit to force isolation of the RTC fast mem-
ory. (RAN)

RTC_CNTL_REG_RTC_SLOWMEM _FORCE_NOISO Set this bit to disable the force isolation of the
RTC slow memory. (RAV)

RTC_CNTL_REG_RTC_SLOWMEM FORCE _ISO Set this bit to force isolation of the RTC slow
memory. (RAV)
RTC_CNTL_REG_RTC_FORCE_ISO Set this bit to force isolation of the RTC peripherals. (RAM)

RTC_CNTL_REG_RTC_ FORCE _NOISO Set this bit to disable the force isolation of the RTC periph-
erals. (RAN)

RTC_CNTL_REG_RTC_FASTMEM FOLW_CPU Set this bit to FPD the RTC fast memory when the
CPU is powered down. Reset this bit to FPD the RTC fast memory when the RTC main state
machine is powered down. (RAV)

RTC_CNTL_REG_RTC_FASTMEM_FORCE_LPD Set this bit to force not retain the RTC fast mem-
ory. (R/W)

RTC_CNTL_REG_RTC_FASTMEM FORCE_LPU Set this bit to force retain the RTC fast memory.
(RAV)

RTC_CNTL_REG_RTC_SLOWMEM FOLW_CPU Set this bit to FPD the RTC slow memory when
the CPU is powered down. Reset this bit to FPD the RTC slow memory when the RTC main state
machine is powered down. (RAV)

RTC_CNTL_REG_RTC_SLOWMEM_FORCE_LPD Set this bit to force not retain the RTC slow
memory. (RAV)

RTC_CNTL_REG_RTC_SLOWMEM FORCE _LPU Set this bit to force retain the RTC slow memory.
(RAV)

RTC_CNTL_REG_RTC_FASTMEM_FORCE PD Set this bit to FPD the RTC fast memory. (RAW)
RTC_CNTL_REG_RTC_FASTMEM_FORCE PU Set this bit to FPU the RTC fast memory. (RAW)

RTC_CNTL_REG_RTC_FASTMEM PD_EN Set this bit to enable PD for the RTC fast memory in
sleep. (RW)

Continued on the next page...

Espressif Systems 614 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.16: RTC_CNTL_PWC_REG (0x0088)

Continued from the previous page...
RTC_CNTL_REG_RTC_SLOWMEM FORCE PD Set this bit to FPD the RTC slow memory. (RAV)
RTC_CNTL_REG_RTC_SLOWMEM FORCE PU Set this bit to FPU the RTC slow memory. (RAM)

RTC_CNTL_REG_RTC_SLOWMEM PD _EN Set this bit to enable PD for the RTC slow memory in
sleep. (RW)

RTC_CNTL_REG_RTC_ FORCE PD Set this bit to FPD the RTC peripherals. (RW)
RTC_CNTL_REG_RTC_ FORCE PU Set this bit to FPU the RTC peripherals. (R/V)
RTC_CNTL_REG_RTC_PD_EN Set this bit to enable PD for the RTC peripherals in sleep. (RAW)

RTC_CNTL_REG_RTC_PAD_FORCE_HOLD Set this bit the force hold the RTC GPIOs. (R/W)

Register 28.17: RTC_CNTL_DIG_PWC_REG (0x008C)

 

 

 

YO x» &
xs
L757, Lie
S CELSO L CS
SS SI ye
ee CEES oe
Ss SESS a
LE EEE CL
Se & & & ASSESS S SX &
os CEC W NLS € g
[ a1 | 2 [2 oa] a3 | 22 | a1 | 20 [19 | | 17 Joe sJafe le o|
fofofo o 0 0 0 ofofifofifo]tfofo 0 0 0 0 0 90 0 0 0 0 ofifolo 0 OlReset

 

RTC_CNTL_REG_LSLP_MEM FORCE PD Set this bit to FPD the memories in the digital system in

sleep. (R/W)

RTC_CNTL_REG_LSLP_MEM FORCE PU Set this bit to FPU the memories in the digital system.
(RW)

RTC_CNTL_REG_WIFIFORCE PD Set this bit to FPD the Wi-Fi digital circuit in the digital system.
(RW)

RTC_CNTL_REG_WIFIFORCE PU Set this bit to FPU the Wi-Fi digital circuit in the digital system.
(RW)

RTC_CNTL_REG_DG_WRAP_FORCE PD Set this bit to FPD the digital system. (RW)
RTC_CNTL_REG_DG_WRAP_FORCE PU Set this bit to FPU the digital system. (RW)
RTC_CNTL_REG_WIFIPD_EN Set this bit to enable PD for the Wi-Fi digital circuit in sleep. (RAM)

RTC_CNTL_REG_DG_WRAP_PD_EN Set this bit to enable PD for the digital system in sleep. (RAM)

Espressif Systems 612 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.18: RTC_CNTL_DIG_ISO_REG (0x0090)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Oo 2
PC Yr OS
SS Sesto X9%
KM Se SSO
SELLS SOEKMEKESS
IK SSSI SSL”
CESS LP WOO S
MOE OLLI LLL’
OA OA OY / OVO4, 0470404 / op >
ie eee
688050 eo Seo SoSH e
CEES E|S & CLES ES E|S &
31 30 29 28 | 27 16] 15 14 13 12 i 10 9 8 0
iJo]ifofo 0 0 0 0 0 60 60 0 06 0 ofolifolifo}olofo 0 0 60 0 0 0 0 OlReset
RTC_CNTL_DG_PAD_ AUTOHOLD Indicates the auto-hold status of the digital GPIOs. (RO)
RTC_CNTL_CLR_DG_PAD AUTOHOLD Set this bit to clear the auto-hold enabler for the digital
GPIOs. (WO)
RTC_CNTL_REG_DG_PAD AUTOHOLD EN Set this bit to allow the digital GPIOs to enter the auto-
hold status. (RAV)
RTC_CNTL_REG_DG_PAD FORCE _NOISO Set this bit to disable the force isolation of the digital
GPIOs. (RAW)
RTC_CNTL_REG_DG_PAD FORCE _ISO Set this bit to force isolation of the digital GPIOs. (RAM)
RTC_CNTL_REG_DG_PAD FORCE _UNHOLD Set this bit the force unhold the digital GPIOs. (RAM)
RTC_CNTL_REG_DG_PAD FORCE HOLD Set this bit the force hold the digital GPIOs. (R/V)
RTC_CNTL_REG_WIFIFORCE_ISO_ Set this bit to force isolation of the Wi-Fi digital circuits. (RAV)
RTC_CNTL_REG_WIFI_FORCE_NOISO Set this bit to disable the force isolation of the Wi-Fi digital
circuits. (RAV)
RTC_CNTL_REG_DG_WRAP_FORCE _ ISO Set this bit to force isolation of the digital system. (RAM)
RTC_CNTL_REG_DG_WRAP_FORCE_NOISO Set this bit to disable the force isolation of the digital
system. (RAW)
Espressif Systems 613 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

Register 28.19: RTC_CNTL_LOW_POWER_ST_REG (0x00CC)

g

e&
aw
oe
7
of
S
& Ss &
& xO” g
€ ¢ NG

 

[a1 20] 19 [8 o|

 

 

fo 0 09 9 00 0 00 0 0 ofofo 0 090090000900 0 09 0 0 0 0 OlReset

 

RTC_CNTL_RTC_RDY_FOR_WAKEUP Indicates the RTC is ready to be triggered by any wakeup

 

 

 

 

 

 

source. (RO)
Register 28.20: RTC_CNTL_RESET_STATE_REG (0x0038)
g »
ov g
S ¥
< SS
noe er"
S? ee
gf Xe
& oe & oe
& «0% L xO"
€ < & <
[1 [13 [2 aE o|
[fo 0 0 0 9 0 0 0 000000 00 0 oftfo 0 0 0 9 0 Of 0 |Reset
RTC_CNTL_RESET CAUSE PROCPU Stores the CPU reset cause. (RO)
RTC_CNTL_PROCPU_STAT_VECTOR_SEL Selects the CPU static vector. (RAV)
Register 28.21: RTC_CNTL_WAKEUP_STATE_REG (0x003C)
wr
Q7
ry
i
&
O7
of
oS
S &
& &
31 15] 14 o
12 00000 0 0 0 0 0 0 0 0 0 Olpeset

 

 

 

 

RTC_CNTL_REG_RTC_WAKEUP_ENA Selects the wakeup source. For details, please refer to Table
156. (RAN)

Espressif Systems 614 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.22: RTC_CNTL_EXT_WAKEUP_CONF_REG (0x0064)

SS
ers x
LEK
SSS
SSS &
LEE EF

 

| st | 2 | 29 | 2 o|

 

 

fofof[ofo 0 0 0 0 0 9 9 9 9 0 0 0000000000009 0 0 0 0 OlReset

 

RTC_CNTL_REG_GPIO_WAKEUP_FILTER Set this bit to enable the GPIO wakeup eventfilter. (RAM)

RTC_CNTL_REG_EXT_WAKEUPO_LV 0: EXTO at low level, 1: EXTO at high level. (RAV)

RTC_CNTL_REG_EXT_WAKEUP1_LV 0: EXT1 at low level, 1: EXT1 at high level. (RAV)

Register 28.23: RTC_CNTL_SLP_REJECT_CONF_REG (0x0068)

 

 

 

eo
SS S
SS’ eo
OR &
27 Qe
SY &
Bos O7
eS $
VE &
WR” \/
OZ 7 O7 @
es € €
[ a | 2 [29 BE o|
[o]o] 0 jo 0 9 0 0 0 9 0 0 0 0 0 O]Reset

 

RTC_CNTL_REG_RTC_ SLEEP REJECT ENA Set this bit to enable reject-to-sleep. (R/W)
RTC_CNTL_REG_LIGHT SLP_REJECT_EN Set this bit to enable reject-to-light-sleep. (R/W)

RTC_CNTL_REG_DEEP_SLP_REJECT_EN Set this bit to enable reject-to-deep-sleep. (RAW)

Espressif Systems 615 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.24: RTC_CNTL_EXT_WAKEUP1_REG (0x00DC)

 

 

 

OS
7
x
SF
g g
& &
x x
f f
oF ee
@ O7 O7
& &€ &€
[a1 23 22 [21 o|
jo 0 0 9 0 90 0 0 ofo] 0 |Reset

 

RTC_CNTL_REG_EXT_ WAKEUP1 SEL Selects a RTC GPIO to be the EXT1 wakeup source. (RAW)

RTC_CNTL_REG_EXT_WAKEUP1_STATUS_CLR Clears the EXT1 wakeup status. (WO)

Register 28.25: RTC_CNTL_EXT_WAKEUP1_STATUS_REG (0x00E0)

 

 

 

<
&
AN/
Ss
Rs
Az
of
&
fo
& oe
& “
[1 2221 o|
jo 0 0 0 9 0 0 0 0 Of 0 |Reset

 

RTC_CNTL_REG_EXT_WAKEUP1_ STATUS Indicates the EXT1 wakeup status. (RO)

Register 28.26: RTC_CNTL_SLP_REJECT_CAUSE_REG (0x01 24)

 

 

 

 

X
S
»
AS
oO
vw
S x
§ oO”
& &€
[1 17] 6 o|
jo 0 9 009000000 00 9 0 |Reset
RTC_CNTL_REJECT CAUSE Stores the reject-to-sleep cause. (RO)
Espressif Systems 616 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

Register 28.27: RTC_CNTL_SLP_WAKEUP_CAUSE_REG (0x012C)

 

 

 

 

RTC_CNTL_WAKEUP_CAUSE Stores the wakeup cause. (RO)

Register 28.28: RTC_CNTL_INT_ENA RTC_REG (0x0040)

S LOR

é& «O ~O% O%0% O%0%O% O%O%O%KO KO %KO% O%O0% O%K%O7 &

[1 20] 19 [18 [a7 | 5

 

s[ulalel nol

Le[7[e]=]+]>]{']
foo 0 0 000 0 0 0 0 ofofofofofofofofojo]ofofo]ofo]o]ofo]o] oo Ireset

 

RTC_CNTL_SLP_WAKEUP_INT_ENA Enables interrupts when the chip wakes up from sleep. (RAV)

RTC_CNTL_SLP_REJECT_INT_ENA Enables interrupts when the chip rejects to go to sleep. (RAV)

RTC_CNTL_RTC_WDT_INT_ENA Enables the RTC watchdog interrupt. (RAV)

RTC_CNTL_RTC_TOUCH_ SCAN DONE _INT_ENA Enables interrupts upon the completion of a
touch scanning. (RAV)

RTC_CNTL_RTC_ULP_CP_INT_ENA Enables the ULP co-processor interrupt. (R/W)

Continued on the next page...

Espressif Systems 617 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.28: RTC_CNTL_INT_ENA RTC_REG (0x0040)

Continued from the previous page...

RTC_CNTL_RTC_TOUCH_DONE_INT_ENA Enables interrupts upon the completion of a single
touch. (R/W)

RTC_CNTL_RTC_TOUCH_ACTIVE_INT_ENA Enables interrupts when a touch is detected. (RAV)

RTC_CNTL_RTC_TOUCH_INACTIVE_INT_ENA Enables interrupts when a touch is released. (RAW)

RTC_CNTL_RTC_BROWN_OUT_INT_ENA Enables the brownout interrupt. (RAV)
RTC_CNTL_RTC_MAIN_TIMER_INT_ENA Enables the RTC main timer interrupt. (R/V)
RTC_CNTL_RTC_SARADC1_INT_ENA Enables the SAR ADC 1 interrupt. (RAV)
RTC_CNTL_RTC_TSENS_INT_ENA Enables the temperature sensor interrupt. (RAV)
RTC_CNTL_RTC_COCPU_INT_ENA Enables the ULP-RISCV interrupt. (RAW)
RTC_CNTL_RTC_SARADC2_INT_ENA Enables the SAR ADC 2 interrupt. (RAV)
RTC_CNTL_RTC_SWD_INT_ENA Enables the super watchdog interrupt. (RAV)

RTC_CNTL_RTC_XTAL32K_DEAD_INT_ENA Enables interrupts when the 32 kHz crystal is dead.
(RAV)

RTC_CNTL_RTC_COCPU_TRAP_INT_ENA Enables interrupts when the ULP-RISCV is trapped.
(RAV)

RTC_CNTL_RTC_TOUCH_TIMEOUT_INT_ENA Enables interrupts when touch sensor times out.
(RAV)

RTC_CNTL_RTC_GLITCH_DET_INT_ENA Enables interrupts when a glitch is detected. (RAM)

Espressif Systems 618 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.29: RTC_CNTL_INT_RAW_RTC_REG (0x0044)

AS SY &
oa ae s a & os re eS
LSSON SBA ELEEEASK
EEL ESET SLES ORE OS
SERIO ESE SII IIS OS
PP PPI PP GOK O 8 er OOS
a Owe OOOO OOOO ow
ge So SoS SSO OO OOo Oo ooo SOS
& SEE EE EO EEE EOE EES eS

 

31 20] 19 | 1g | 17 | 16 | 15 | 14] 13] 12] 11) 1] 9 | @ | 7 J oe] 5

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

0 0 0 000 00 0 0 0 OJ/0/0;/0/0])/0]/0/0];/0/0]/0;/0)/0)0

oO
oO

0/0] 0] 0 Reset

 

RTC_CNTL_SLP_WAKEUP_INT_RAW Stores the raw interrupt triggered when the chip wakes up
from sleep. (RO)

RTC_CNTL_SLP_REJECT_INT_RAW Stores the raw interrupt triggered when the chip rejects to go
to sleep. (RO)

RTC_CNTL_RTC_WDT_INT_RAW Stores the raw RTC watchdog interrupt. (RO)

RTC_CNTL_RTC_TOUCH SCAN DONE _INT_RAW Stores the raw interrupt triggered upon the
completion of a touch scanning. (RO)

RTC_CNTL_RTC_ULP_CP_INT_RAW Stores the raw ULP co-processor interrupt. (RO)

RTC_CNTL_RTC_TOUCH_DONE_INT_RAW Stores the raw interrupt triggered upon the completion
of a single touch. (RO)

RTC_CNTL_RTC_TOUCH_ACTIVE_INT_RAW Stores the raw interrupt triggered when a touch is
detected. (RO)

RTC_CNTL_RTC_TOUCH_INACTIVE_INT_RAW Stores the raw interrupt triggered when a touch is
released. (RO)

RTC_CNTL_RTC_BROWN_OUT_INT_RAW Stores the raw brownout interrupt. (RO)
RTC_CNTL_RTC_MAIN_TIMER_INT_RAW Stores the raw RTC main timer interrupt. (RO)
RTC_CNTL_RTC_SARADC1_INT_RAW Stores the raw SAR ADC 1 interrupt. (RO)
RTC_CNTL_RTC_TSENS_INT_RAW Stores the raw temperature sensor interrupt. (RO)
RTC_CNTL_RTC_COCPU_INT_RAW Stores the raw ULP-RISCV interrupt. (RO)
RTC_CNTL_RTC_SARADC2_INT_RAW Stores the raw SAR ADC 2 interrupt. (RO)
RTC_CNTL_RTC_SWD_INT_RAW Stores the raw super watchdog interrupt. (RO)

RTC_CNTL_RTC_XTAL32K_DEAD_INT_RAW Stores the raw interrupt triggered when the 82 kHz
crystal is dead. (RO)

Continued on the next page...

Espressif Systems 619 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

Register 28.29: RTC_CNTL_INT_RAW_RTC_REG (0x0044)

Continued from the previous page...

RTC_CNTL_RTC_COCPU_TRAP_INT_RAW Stores the raw interrupt triggered when the ULP-
RISCV is trapped. (RO)

RTC_CNTL_RTC_TOUCH_TIMEOUT_INT_RAW Stores the raw interrupt triggered when touch sen-
sor times out. (RO)

RTC_CNTL_RTC_GLITCH_DET_INT_RAW Stores the raw interrupt triggered when a glitch is de-
tected. (RO)

Espressif Systems 620 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.30: RTC_CNTL_INT_ST_RTC_REG (0x0048)

S LLLLYLRILILIYLIILOLRO'S

RS)

@ OZDKOKOZKOKOZOKOZG
a)

é SEEEEEEEE

 

Ee

offal fle] u]slefufio lo] s

 

| 0

[7 [e]s[-[: |e]
000000000 0 ofofofofo]fofofofofofofo]fofofo]fofofofo]o

 

RTC_CNTL_SLP_WAKEUP_INT_ST Stores the status of the interrupt triggered when the chip wakes
up from sleep. (RO)

RTC_CNTL_SLP_REJECT_INT_ST Stores the status of the interrupt triggered when the chip rejects
to go to sleep. (RO)

RTC_CNTL_RTC_WDT_INT_ST Stores the status of the RTC watchdog interrupt. (RO)

RTC_CNTL_RTC_TOUCH_ SCAN DONE _INT_ST Stores the status of the interrupt triggered upon
the completion of a touch scanning. (RO)

RTC_CNTL_RTC_ULP_CP_INT_ST Stores the status of the ULP co-processor interrupt. (RO)

RTC_CNTL_RTC_TOUCH_DONE_INT_ST Stores the status of the interrupt triggered upon the com-
pletion of a single touch. (RO)

RTC_CNTL_RTC_TOUCH_ACTIVE_INT_ST Stores the status of the interrupt triggered when a touch
is detected. (RO)

RTC_CNTL_RTC_TOUCH_INACTIVE_INT_ST Stores the status of the interrupt triggered when a
touch is released. (RO)

RTC_CNTL_RTC_BROWN_OUT_INT_ST Stores the status of the brownout interrupt. (RO)
RTC_CNTL_RTC_MAIN_TIMER_INT_ST Stores the status of the RTC main timer interrupt. (RO)
RTC_CNTL_RTC_SARADC1_INT_ST Stores the status of the SAR ADC 1 interrupt. (RO)
RTC_CNTL_RTC_TSENS_INT_ST Stores the status of the temperature sensor interrupt. (RO)
RTC_CNTL_RTC_COCPU_INT_ST Stores the status of the ULP-RISCV interrupt. (RO)
RTC_CNTL_RTC_SARADC2_INT_ST Stores the status of the SAR ADC 2 interrupt. (RO)
RTC_CNTL_RTC_SWD_INT_ST Stores the status of the super watchdog interrupt. (RO)

RTC_CNTL_RTC_XTAL32K_DEAD_INT_ST Stores the status of the interrupt triggered when the 32
kHz crystal is dead. (RO)

Continued on the next page...

Espressif Systems 621 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

Register 28.30: RTC_CNTL_INT_ST_RTC_REG (0x0048)

Continued from the previous page...

RTC_CNTL_RTC_COCPU_TRAP_INT_ST Stores the status of the interrupt triggered when the ULP-
RISCV is trapped. (RO)

RTC_CNTL_RTC_TOUCH_TIMEOUT_INT_ST Stores the status of the interrupt triggered when
touch sensor times out. (RO)

RTC_CNTL_RTC_GLITCH_DET_INT_ST Stores the status of the interrupt triggered when a glitch is
detected. (RO)

Espressif Systems 622 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.31: RTC_CNTL_INT_CLR_RTC_REG (0x004C)

SESE EEO EEE EOS
= YOO iON", RR
se LEER TOO OO OOS

é &EEELEESEEEREELEE ERE

 

[1 »fiofielifls[ulelelufole[e[7 [els ]s

 

[> [2]
[o 0000000000 ofofofolofofofofofofofofolfofo]fofofofo]o

 

RTC_CNTL_SLP_WAKEUP_INT_CLR Clears the interrupt triggered when the chip wakes up from
sleep. (WO)

RTC_CNTL_SLP_REJECT_INT_CLR Clears the interrupt triggered when the chip rejects to go to
sleep. (WO)

RTC_CNTL_RTC_WDT_INT_CLR Clears the RTC watchdog interrupt. (WO)

RTC_CNTL_RTC_TOUCH_ SCAN DONE _INT_CLR Clears the interrupt triggered upon the comple-
tion of a touch scanning. (WO)

RTC_CNTL_RTC_ULP_CP_INT_CLR Clears the ULP co-processor interrupt. (WO)

RTC_CNTL_RTC_TOUCH_DONE_INT_CLR Clears the interrupt triggered upon the completion of a
single touch. (WO)

RTC_CNTL_RTC_TOUCH_ACTIVE_INT_CLR Clears the interrupt triggered when a touch is de-
tected. (WO)

RTC_CNTL_RTC_TOUCH_INACTIVE_INT_CLR_ Clears the interrupt triggered when a touch is re-
leased. (WO)

RTC_CNTL_RTC_BROWN_OUT_INT_CLR Clears the brownout interrupt. (WO)
RTC_CNTL_RTC_MAIN_TIMER_INT_CLR Clears the RTC main timer interrupt. (WO)
RTC_CNTL_RTC_SARADC1_INT_CLR Clears the SAR ADC 1 interrupt. (WO)
RTC_CNTL_RTC_TSENS_INT_CLR Clears the temperature sensor interrupt. (WO)
RTC_CNTL_RTC_COCPU_INT_CLR Clears the ULP-RISCV interrupt. (WO)
RTC_CNTL_RTC_SARADC2_INT_CLR Clears the SAR ADC 2 interrupt. (WO)
RTC_CNTL_RTC_SWD_INT_CLR Clears the super watchdog interrupt. (WO)

RTC_CNTL_RTC_XTAL32K_DEAD_ INT_CLR Clears the interrupt triggered when the 32 kHz crystal
is dead. (WO)

Continued on the next page...

Espressif Systems 623 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

Register 28.31: RTC_CNTL_INT_CLR_RTC_REG (0x004C)

Continued from the previous page...

RTC_CNTL_RTC_COCPU_TRAP_INT_CLR Clears the interrupt triggered when the ULP-RISCV is
trapped. (WO)

RTC_CNTL_RTC_TOUCH_TIMEOUT_INT_CLR Clears the interrupt triggered when touch sensor
times out. (WO)

RTC_CNTL_RTC_GLITCH_DET_INT_CLR Clears the interrupt triggered when a glitch is detected.
(WO)

Register 28.32: RTC_CNTL_STOREO_REG (0x0050)

 

31

 

 

 

Reset

 

RTC_CNTL_RTC_SCRATCHO Reservation register 0. (RW)

Register 28.33: RTC_CNTL_STORE1_REG (0x0054)

| 0 | Reset

RTC_CNTL_RTC_SCRATCH1 Reservation register 1. (RW)

Espressif Systems 624 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.34: RTC_CNTL_STORE2_REG (0x0058)

 

 

| 0 | Reset

 

RTC_CNTL_RTC_SCRATCH2 Reservation register 2. (R/W)

Register 28.35: RTC_CNTL_STORE3_REG (0x005C)

Oo
oe
&
$

 

[2 |

| 0 | Reset

 

 

RTC_CNTL_RTC_SCRATCH3 Reservation register 3. (RW)

Register 28.36: RTC_CNTL_STORE4_REG (0x00BC)

 

 

| 0 | Reset

 

RTC_CNTL_RTC_SCRATCH4 Reservation register 4. (RW)

Espressif Systems 625 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.37: RTC_CNTL_STORES_REG (0x00C0)

 

 

| 0 | Reset

 

RTC_CNTL_RTC_SCRATCHS5 Reservation register 5. (RW)

Register 28.38: RTC_CNTL_STORE6_REG (0x00C4)

©
oe
&
$

 

[2 |

| 0 | Reset

 

 

RTC_CNTL_RTC_SCRATCH6 Reservation register 6. (RW)

Register 28.39: RTC_CNTL_STORE7_REG (0x00C8)

 

 

| 0 | Reset

 

RTC_CNTL_RTC_SCRATCH7 Reservation register 7. (R/W)

Espressif Systems 626 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.40: RTC_CNTL_EXT_XTL_CONF_REG (0x0060)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Aj
gy INS °
S vs oO
0” t SEE. Os Ss
Ss SS & Po oS OP KE NS
Le PS SLES SECLOL™
Sy gv Sooo”
we’ & & Ss. WAY RYY, YAY. YAY. wv
OZ Lo Or Or Oz O74 OZ O74 OZ O74 Or Oz Or
oe se “S = se OTS
&é & << é é SEEEREEE
31 30 | 29 24] 23 | 22 20) 19 9 8 7 6 5 4 3 2 1 0
o}olo 0 6 0 0 ofo oo §=|0 0 60 0 0 0 0 0 0 0 ofo]1{o]o]o]o]o]o] 0 IReset
RTC_CNTL_REG_XTAL32K_WDT_EN Set this bit to enable the 32 kHz crystal watchdog. (R/W)
RTC_CNTL_REG_XTAL32K_WDT_CLK_FO Set this bit to FPU the 32 kHz crystal watchdog clock.
(RAV)
RTC_CNTL_REG_XTAL32K_WDT_RESET Set this bit to reset the 32 kHz crystal watchdog by SW.
(RAV)
RTC_CNTL_REG_XTAL32K_EXT_CLK_FO Set this bit to FPU the external clock of 32 kHz crystal.
(RAV)
RTC_CNTL_REG_XTAL32K_AUTO BACKUP Set this bit to switch to the backup clock when the
82 kHz crystal is dead. (RAW)
RTC_CNTL_REG_XTAL32K_AUTO_ RESTART Set this bit to restart the 32 kHz crystal automatically
when the 82 kHz crystal is dead. (RAV)
RTC_CNTL_REG_XTAL32K_AUTO_ RETURN Set this bit to switch back to 82 kHz crystal when the
82 kHz crystal is restarted. (R/W)
RTC_CNTL_REG_XTAL32K_XPD_FORCE Set this bit to allow the software to FPD the 32 kHz crys-
tal; Reset this bit to allow the FSM to FPD the 32 kHz crystal. (R/V)
RTC_CNTL_REG_ENCKINIT_XTAL_ 32K Set 1 to apply an internal clock to help the 32 kHz crystal
to start. (RAV)
RTC_CNTL_REG_RTC_WDT_STATE Stores the status of the 32 kHz watchdog. (RO)
RTC_CNTL_REG_RTC_XTAL32K_GPIO_SEL Selects the 32 kHz crystal clock. 0: selects the ex-
ternal 82 kHz clock; 1: selects clock from the RTC GPIO X32P_C. (RAM)
RTC_CNTL_REG_XTL_EXT_CTR_LV 0: powers down XTAL at high level; 1: powers down XTAL at
low level. (RAN)
RTC_CNTL_REG_XTL_EXT_CTR_EN Enables the GPIO to power down the crystal oscillator. (RAM)
Espressif Systems 627 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

Register 28.41: RTC_CNTL_CLK_CONF_REG (0x0074)

 

 

 

SL
& SF ae ox 4 NS
LV & SOKO SK SY ATs 2
For SS EF SN PEELS S SY
s & eo av & ve PLE i ee
CO e OE 7 LE 7 ee EEEEL E & 7
of we set & os < ow PSSEES eX oe
CLE EE € EE EEEEEE ES
fb f-— => Perf te PPP Pe br
| 0 [0 Jo ofofofo o 0 0 9 9 9 ofofo] 3 fofo[i]ofofo| 1 [1 Jo 0 O|Reset

 

RTC_CNTL_REG_CK8M_DIV_SEL_ VLD Synchronizes the reg_ck8m_div_sel. Note that you have to
invalidate the bus before modifying the frequency divider, and then validate the new divider clock.

(RW)

RTC_CNTL_REG_CK8M_DIV Set the CK8M_D256_OUT divider. 00: divided by 128, 01: divided by
256, 10: divided by 512, 11: divided by 1024. (RAW)

RTC_CNTL_REG_ENB _CK8M Set this bit to disable CK8M and CK8M_D256_OUT. (RWW)

RTC_CNTL_REG_ENB CK8M_DIV Selects the CK8M_D256_OUT. 1: CK8M, 0: CK8M divided by
256. (RW)

RTC_CNTL_REG_DIG_XTAL32K_EN Set this bit to enable CK_XTAL_32K clock for the digital core.
(RAV)

RTC_CNTL_REG_DIG_CLK8M_D256_EN Set this bit to enable CK8M_D256_OUT clock for the dig-
ital core. (RAV)

RTC_CNTL_REG_DIG_CLK8M_EN Set this bit to enable 8 MHz clock for the digital core. (RW)
RTC_CNTL_REG_CK8M_DIV_SEL Stores the 8 MHz divider, which is reg_ck8m_div_sel + 1. (RAV)

RTC_CNTL_REG_XTAL_ FORCE NOGATING Set this bit to force no gating to crystal during sleep.
(RAV)

RTC_CNTL_REG_CK8M_FORCE_NOGATING Set this bit to disable force gating to 8 MHz crystal
during sleep. (RAV)

RTC_CNTL_REG_CK8M_FORCE_PD Set this bit to FPD the 8 MHz clock. (R/W)
RTC_CNTL_REG_CK8M_FORCE_PU Set this bit to FPU the 8 MHz clock. (R/W)

RTC_CNTL_REG_FAST_CLK_RTC_SEL Set this bit to select the RTC fast clock. 0: XTAL div 4, 1:
CKéM. (RW)

RTC_CNTL_REG_ANA CLK_RTC_SEL Set this bit to select the RTC slow clock. O: 90K rtc_clk, 1:
832k XTAL, 2: 8md256. (RAV)

Espressif Systems 628 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.42: RTC_CNTL_SLOW_CLK_CONF_REG (0x0078)

 

 

 

ww
Ss ae
ow Na
7 7
& &
S$ Ss
& &
fo fo
& eS oS
& & & &
[ st [20 23] 2 [at o|
[o| 0 [iJo 0 0 0 0 090 000900 0 00 0 0 0 0 0 Ofreset

 

RTC_CNTL_REG_RTC_ANA CLK _DIV_VLD Synchronizes the reg_rtc_ana_clk_div. Note that you
have to invalidate the bus before modifying the frequency divider, and then validate the new divider
clock. (RAV)

RTC_CNTL_REG_RTC_ANA_CLK_DIV Set the divider for the RTC clock. (RWW)

Register 28.43: RTC_CNTL_XTAL32K_CLK_FACTOR_REG (0x00F0)

 

[ “|

| 0x000000 | Reset

 

 

RTC_CNTL_REG_XTAL32K_CLK_FACTOR Configures the divider factor for the 82 kHz crystal os-
cillator. (R/V)

Espressif Systems 629 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
28. Low-power Management

 

Register 28.44: RTC_CNTL_XTAL32K_CONF_REG (0x00F4)

 

 

S xj j
& & . s
» ww 4 &€ 7 ¥ 7
av
we? & €<
a a eo a
o oO o ?
ee ee ay ve
Or Or & ZL & f
x’ x’ ae’ a’
~ ~ S ~
Oo Oo Oo Oo
wo" mo’ mo’ mo’
g g g g
31 28 | 27 20 | 19 4]3 o
0) Oxff 0x00 Oxo Reset

 

 

 

 

 

 

RTC_CNTL_REG_XTAL32K_RETURN_WAIT Defines the waiting cycles before returning to the nor-
mal 32 kHz crystal oscillator. (RAV)

RTC_CNTL_REG_XTAL32K_RESTART_WAIT Defines the waiting cycles before restarting the 32
kHz crystal oscillator. (RAV)

RTC_CNTL_REG_XTAL32K_WDT_TIMEOUT Defines the waiting period for clock detection. If no
clock is detected after this period, the 32 kHz crystal oscillator can be regarded as dead. (RAV)

RTC_CNTL_REG_XTAL32K_ STABLE _THRES Defines the allowed restarting period, within which
the 32 kHz crystal oscillator can be regarded as stable. (R/V)

Espressif Systems 630 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

Register 28.45: RTC_CNTL_WDTCONFIGO_REG (0x0094)

 

 

 

Y SE Ss
gS x’ NY a?
@ FX ONY, X
9 x y % “ £ SS
&S S SI S ss? wo GS
K K K x g 20” AWK
S S g g S Se < is
x7 K7 Kg7 K7 Kg7 EA z}R RAK7 K7
wW © © © wW © wW © © wW
Or Or Ov Or Ov Lo Or O20” Ov
SF SK SS SK SF KE OS
O7 O7 O7 O7 O7 O7 O7 OZ 7 L Oz &
€ € € é € € SLL EES &
| 31 E 227 [2 2221 [18 16 [15 13] 12 | 11 | 10 | 9 E o|
[o| x0 | x0 | x0 | x0 | oxt | Oxt [i fo[e] fo 000 00 0 0 0]Reset

 

RTC_CNTL_REG_WDT_PAUSE_IN_SLP Set this bit to pause the watchdog in sleep. (RAV)

RTC_CNTL_REG_WDT_PROCPU_RESET_EN Set this bit to allow the watchdog to be able to reset
CPU. (RAV)

RTC_CNTL_REG_WDT_FLASHBOOT_MOD_EN Set this bit to enable watchdog when the chip
boots from flash. (RAV)

RTC_CNTL_REG_WDT_SYS_ RESET LENGTH Sets the length of the system reset counter. (RAV)
RTC_CNTL_REG_WDT_CPU_RESET_LENGTH Sets the length of the CPU reset counter. (RAV)

RTC_CNTL_REG_WDT_STG3 1: enable at the interrupt stage, 2: enable at the CPU stage, 3: enable
at the system stage, 4: enable at the system and RTC stage. (RAV)

RTC_CNTL_REG_WDT_STG2_ 1: enable at the interrupt stage, 2: enable at the CPU stage, 3: enable
at the system stage, 4: enable at the system and RTC stage. (RAV)

RTC_CNTL_REG_WDT_STG1_ 1: enable at the interrupt stage, 2: enable at the CPU stage, 3: enable
at the system stage, 4: enable at the system and RTC stage. (RAV)

RTC_CNTL_REG_WDT_STGO 1: enable at the interrupt stage, 2: enable at the CPU stage, 3: enable
at the system stage, 4: enable at the system and RTC stage. (RAV)

RTC_CNTL_REG_WDT_EN Set this bit to enable the RTC watchdog. (RAW)

 

Note:
For details, please refer to Chapter 14 XTAL32K Watchdog.

 

 

 

Espressif Systems 631 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.46: RTC_CNTL_WDTCONFIG1_REG (0x0098)

 

[2 |

| 200000 | Reset

 

 

RTC_CNTL_REG_WDT_STGO_HOLD Configures the hold time of RTC watchdog at level 1. (R/W)

Register 28.47: RTC_CNTL_WDTCONFIG2_REG (0x009C)

 

 

 

S
~
e
é 7
&
ow
>
&
[2 |
| 80000 | Reset

 

RTC_CNTL_REG_WDT_STG1_HOLD Configures the hold time of RTC watchdog at level 2. (R/W)

Register 28.48: RTC_CNTL_WDTCONFIG3_REG (0x00A0)

 

 

 

re
Y7
KO
4?
©
Y
&
3s
Oo 4
€
[2 |
| OxOOOfff |Reset

 

RTC_CNTL_REG_WDT_STG2_ HOLD Configures the hold time of RTC watchdog at level 3. (R/W)

Espressif Systems 632 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.49: RTC_CNTL_WDTCONFIG4_REG (0x00A4)

S
Kor
a7
>
&
~
&

[ “|

| OxOOOrff | Reset

 

 

 

RTC_CNTL_REG_WDT_STG3_HOLD Configures the hold time of RTC watchdog at level 4. (R/W)

Register 28.50: RTC_CNTL_WDTFEED_REG (0x00A8)

O7 &
&é ee

[ st [20 o|

 

 

 

[ojo 0 0 0 0000900000009 90900000000 0 0 0 0 0 OlReset

 

RTC_CNTL_RTC_WDT_FEED Set this bit to feed the RTC watchdog. (WO)

Register 28.51: RTC_CNTL_WDTWPROTECT_REG (0x00AC)

 

E |

| Ox50d83aa1 | Reset

 

 

RTC_CNTL_REG_WDT_WKEY Sets the write protection key of the watchdog. (R/WV)

Espressif Systems 633 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.52: RTC_CNTL_SWD_CONF_REG (0x00B0)

 

 

 

S Ss
7 oO ©
S oO ws
So, x ww we
SPES & se
O”% O”% O”% f O7% OS
SF s foe
&. OS & SO & ws
WRN A? VR
SESS < é Xe
O%~04~O%O7 O7 ia) O%x.07
LEE é é *
[a1 | 29 | 28 | 27 te | afi fo]
fofofofo] 300 [o 9 000000000000 0 0[ 0] 0 |Reset

 

RTC_CNTL_SWD_RESET_FLAG Indicates the super watchdog reset flag. (RO)

RTC_CNTL_SWD_ FEED INT Receiving this interrupt leads to feeding the super watchdog via SW.
(RO)

RTC_CNTL_REG_SWD_ SIGNAL WIDTH Adjusts the signal width sent to the super watchdog.
(RAV)

RTC_CNTL_REG_SWD_RST_FLAG_CLR Set to reset the super watchdog reset flag. (WO)
RTC_CNTL_REG_SWD_FEED Set to feed the super watchdog via SW. (WO)
RTC_CNTL_REG_SWD_DISABLE Set this bit to disable super watchdog. (R/V)

RTC_CNTL_REG_SWD_AUTO FEED EN Set this bit to enable automatic watchdog feeding upon
interrupts. (RAV)

Register 28.53: RTC_CNTL_SWD_WPROTECT_REG (0x00B4)

 

 

| Ox8fid312a |Reset

 

RTC_CNTL_REG_SWD_WKEY Sets the write protection key of the super watchdog. (R/W)

Espressif Systems 634
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
28. Low-power Management

 

Register 28.54: RTC_CNTL_SW_CPU_STALL_REG (0x00B8)

 

 

se
S
&
S$
ww
a?
?
&
V7
ss &
O7 g
€ &
31 26) 25
0 000000000 0000000 0 0

 

 

 

 

Reset

RTC_CNTL_REG_SW_STALL_PROCPU_C1 When RTC_CNTL_REG_SW_STALL_PROCPU_CO is

configured to Ox2, setting this bit to Ox21 stalls the CPU by SW. (R/V)

Espressif Systems 635
Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
28. Low-power Management

 

Register 28.55: RTC_CNTL_PAD_HOLD_REG (0x00D4)

 

E

22] a] 2 |] ae [1

7] [|e [23 | 2 | 2 [10

 

[0 0000000 0 ofofofofo]fofofofo]ofo]o]ofo

 

RTC_CNTL_REG_TOUCH_PADO_HOLD
RTC_CNTL_REG_TOUCH_PAD1_HOLD
RTC_CNTL_REG_TOUCH_PAD2_HOLD
RTC_CNTL_REG_TOUCH_PAD3_HOLD
RTC_CNTL_REG_TOUCH_PAD4_HOLD
RTC_CNTL_REG_TOUCH_PAD5_HOLD
RTC_CNTL_REG_TOUCH_PAD6_HOLD
RTC_CNTL_REG_TOUCH_PAD7_HOLD
RTC_CNTL_REG_TOUCH_PAD8_HOLD

RTC_CNTL_REG_TOUCH_PAD9_HOLD

Sets the touch GPIO 0 to the holding state.
Sets the touch GPIO 1 to the holding state.
Sets the touch GPIO 2 to the holding state.
Sets the touch GPIO 3 to the holding state.
Sets the touch GPIO 4 to the holding state.
Sets the touch GPIO 5 to the holding state.
Sets the touch GPIO 6 to the holding state.
Sets the touch GPIO 7 to the holding state.
Sets the touch GPIO 8 to the holding state.

Sets the touch GPIO 9 to the holding state.

(RW)
(RW)
(RW)
(RW)
(RW)
(RW)
(RW)
(RW)
(RW)

(RW)

RTC_CNTL_REG_TOUCH_PAD10_HOLD Sets the touch GPIO 10 to the holding state. (R/(W)

RTC_CNTL_REG_TOUCH_PAD11_ HOLD Sets the touch GPIO 11 to the holding state.
RTC_CNTL_REG_TOUCH_PAD12 HOLD Sets the touch GPIO 12 to the holding state.
RTC_CNTL_REG_TOUCH_PAD13 HOLD Sets the touch GPIO 13 to the holding state.

RTC_CNTL_REG_TOUCH_PAD14 HOLD Sets the touch GPIO 14 to the holding state.

RTC_CNTL_REG_X32P_HOLD Sets the x32p to the holding state. (RAM)

RTC_CNTL_REG_X32N_ HOLD Sets the x82n to the holding state. (RAM)

RTC_CNTL_REG_PDAC1_HOLD Sets th

RTC_CNTL_REG_PDAC2_HOLD Sets th

e pdact to the holding state. (RAM)

€ pdacz2 to the holding state. (RAM)

RTC_CNTL_REG_RTC_PAD19_ HOLD Sets the RTG GPIO 19 to the holding state. (R/W)

RTC_CNTL_REG_RTC_PAD20_ HOLD Sets the RTG GPIO 20 to the holding state. (R/W)

RTC_CNTL_REG_RTC_PAD21_HOLD Sets the RTG GPIO 21 to the holding state. (R/W)

Espressif Systems

636

Submit Documentation Feedback

ESP32-S2 TRM (Preliminary V0.4)
28. Low-power Management

 

Register 28.56: RTC_CNTL_DIG_PAD_HOLD_REG (0x00D8)

 

31 °

 

0 Reset

 

 

 

RTC_CNTL_REG_DIG_PAD HOLD Set GPIO 21 to GPIO 45 to the holding state. (See bitmap to
locate any GPIO). (RW)

Espressif Systems 637 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
28. Low-power Management

 

Register 28.57: RTC_CNTL_BROWN_OUT_REG (0x00E4)

 

 

 

 

e
e
g < vo é
o we . EE ‘ :
EM SS oS re < S
KES KE é SO S &
eo ores o ot RS RS
SS’ ahae’ RS RSAS4 we’ we’
S OS S OKO S S
SeSeF SF of Soo of S
“ “ev” & &
eT * eP 2 °
EEEEEE & LE & € &
[a1 | 2 | 2 | 25 | 2 | 2 [25 6] 5 | [13 [3 if o |
fofofofofo]o] OX [ofo| Ox2ff [o 9 0] 7 |Reset
RTC_CNTL_REG_BROWN_OUT2_ENA Enables the brown_out2 to initiate a chip reset. (RAV)
RTC_CNTL_REG_BROWN_OUT_INT_WAIT Configures the waiting cycles before sending an inter-
rupt. (R/V)
RTC_CNTL_REG_BROWN_OUT_CLOSE_FLASH_ENA Set this bit to enable PD the flash when a
brown-out happens. (R/W)
RTC_CNTL_REG_BROWN_OUT_PD_RF_ENA Set this bit to enable PD the RF circuits when a
brown-out happens. (R/W)
RTC_CNTL_REG_BROWN_OUT_RST_WAIT Configures the waiting cycles before the reset after a
brown-out. (R/W)
RTC_CNTL_REG_BROWN_OUT_RST_ENA Enables to reset brown-out. (R/W)
RTC_CNTL_REG_BROWN_OUT_RST_SEL Selects the reset type when a brown-out happens. 1:
chip reset, 0: system reset. (R/W)
RTC_CNTL_REG_BROWN_OUT_CNT_CLR Clears the brown-out counter. (WO)
RTC_CNTL_REG_BROWN_OUT_ENA Set this bit to enable brown-out detection. (RAV)
RTC_CNTL_RTC_BROWN_OUT_DET Indicates the status of the brown-out signal. (RO)
Espressif Systems 638 ESP32-S2 TRM (Preliminary V0.4)

Submit Documentation Feedback
Revision History

 

Revision History

 

Date

Version

Release notes

 

2020-05-21

V0.4

Added the following chapters:
* Chapter 18 7WAI
* Chapter 28 Low-power Management
Updated the following chapters:
° Added a new section 5.4 Dedicated GPIO in Chapter 5 /O MUX and GPIO
Matrix
* Removed bit EFUSE_PGM_DATA1_REG[16] from the list of bits that are
reserved and can only be used by software; added bit
EFUSE_RPT4_RESERVED5 and EFUSE_RPT4 RESERVEDS5_ERR in
Chapter 16 eFuse Controller
* Updated the base address in Chapter 22 Random Number Generator

 

2020-04-01

V0.3

Added the following chapters:
® Chapter 14 XTAL 32k Watchdog
© Chapter 15 System Timer
* Chapter 24 Permission Control
° Chapter 26 HMAC Module
* Chapter 27 ULP Coprocessor
Updated RTC_CLK frequency in Chapter 2 Reset and Clock

 

2020-01-20

V0.2

Added the following chapters:

* Chapter 5 /O MUX and GPIO Matrix

* Chapter 7 DMA Controller

* Chapter 8 UAART Controller
Updated the configurations of eFuse-programming and eFuse-read timing
parameters in Chapter 16 eFuse Controller

 

2019-11-27

 

 

V0.1

 

 

Preliminary release

 

Espressif Systems

639 ESP32-S2 TRM (Preliminary V0.4)
Submit Documentation Feedback
